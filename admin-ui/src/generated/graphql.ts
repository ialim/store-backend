import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format. */
  DateTime: { input: any; output: any; }
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { input: any; output: any; }
};

export enum AdjustmentType {
  Discount = 'DISCOUNT',
  Increase = 'INCREASE',
  None = 'NONE'
}

export type AdminActionLog = {
  __typename?: 'AdminActionLog';
  action: Scalars['String']['output'];
  admin: User;
  adminId: Scalars['String']['output'];
  afterChange?: Maybe<Scalars['JSON']['output']>;
  beforeChange?: Maybe<Scalars['JSON']['output']>;
  entityId: Scalars['String']['output'];
  entityType: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  timestamp: Scalars['DateTime']['output'];
};

export type AdminActionLogCreateManyAdminInput = {
  action: Scalars['String']['input'];
  afterChange?: InputMaybe<Scalars['JSON']['input']>;
  beforeChange?: InputMaybe<Scalars['JSON']['input']>;
  entityId: Scalars['String']['input'];
  entityType: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['DateTime']['input']>;
};

export type AdminActionLogCreateManyAdminInputEnvelope = {
  data: Array<AdminActionLogCreateManyAdminInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AdminActionLogCreateNestedManyWithoutAdminInput = {
  connect?: InputMaybe<Array<AdminActionLogWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<AdminActionLogCreateOrConnectWithoutAdminInput>>;
  create?: InputMaybe<Array<AdminActionLogCreateWithoutAdminInput>>;
  createMany?: InputMaybe<AdminActionLogCreateManyAdminInputEnvelope>;
};

export type AdminActionLogCreateOrConnectWithoutAdminInput = {
  create: AdminActionLogCreateWithoutAdminInput;
  where: AdminActionLogWhereUniqueInput;
};

export type AdminActionLogCreateWithoutAdminInput = {
  action: Scalars['String']['input'];
  afterChange?: InputMaybe<Scalars['JSON']['input']>;
  beforeChange?: InputMaybe<Scalars['JSON']['input']>;
  entityId: Scalars['String']['input'];
  entityType: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['DateTime']['input']>;
};

export type AdminActionLogListRelationFilter = {
  every?: InputMaybe<AdminActionLogWhereInput>;
  none?: InputMaybe<AdminActionLogWhereInput>;
  some?: InputMaybe<AdminActionLogWhereInput>;
};

export type AdminActionLogOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type AdminActionLogScalarWhereInput = {
  AND?: InputMaybe<Array<AdminActionLogScalarWhereInput>>;
  NOT?: InputMaybe<Array<AdminActionLogScalarWhereInput>>;
  OR?: InputMaybe<Array<AdminActionLogScalarWhereInput>>;
  action?: InputMaybe<StringFilter>;
  adminId?: InputMaybe<StringFilter>;
  afterChange?: InputMaybe<JsonNullableFilter>;
  beforeChange?: InputMaybe<JsonNullableFilter>;
  entityId?: InputMaybe<StringFilter>;
  entityType?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
};

export type AdminActionLogUpdateManyMutationInput = {
  action?: InputMaybe<StringFieldUpdateOperationsInput>;
  afterChange?: InputMaybe<Scalars['JSON']['input']>;
  beforeChange?: InputMaybe<Scalars['JSON']['input']>;
  entityId?: InputMaybe<StringFieldUpdateOperationsInput>;
  entityType?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type AdminActionLogUpdateManyWithWhereWithoutAdminInput = {
  data: AdminActionLogUpdateManyMutationInput;
  where: AdminActionLogScalarWhereInput;
};

export type AdminActionLogUpdateManyWithoutAdminNestedInput = {
  connect?: InputMaybe<Array<AdminActionLogWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<AdminActionLogCreateOrConnectWithoutAdminInput>>;
  create?: InputMaybe<Array<AdminActionLogCreateWithoutAdminInput>>;
  createMany?: InputMaybe<AdminActionLogCreateManyAdminInputEnvelope>;
  delete?: InputMaybe<Array<AdminActionLogWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<AdminActionLogScalarWhereInput>>;
  disconnect?: InputMaybe<Array<AdminActionLogWhereUniqueInput>>;
  set?: InputMaybe<Array<AdminActionLogWhereUniqueInput>>;
  update?: InputMaybe<Array<AdminActionLogUpdateWithWhereUniqueWithoutAdminInput>>;
  updateMany?: InputMaybe<Array<AdminActionLogUpdateManyWithWhereWithoutAdminInput>>;
  upsert?: InputMaybe<Array<AdminActionLogUpsertWithWhereUniqueWithoutAdminInput>>;
};

export type AdminActionLogUpdateWithWhereUniqueWithoutAdminInput = {
  data: AdminActionLogUpdateWithoutAdminInput;
  where: AdminActionLogWhereUniqueInput;
};

export type AdminActionLogUpdateWithoutAdminInput = {
  action?: InputMaybe<StringFieldUpdateOperationsInput>;
  afterChange?: InputMaybe<Scalars['JSON']['input']>;
  beforeChange?: InputMaybe<Scalars['JSON']['input']>;
  entityId?: InputMaybe<StringFieldUpdateOperationsInput>;
  entityType?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  timestamp?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type AdminActionLogUpsertWithWhereUniqueWithoutAdminInput = {
  create: AdminActionLogCreateWithoutAdminInput;
  update: AdminActionLogUpdateWithoutAdminInput;
  where: AdminActionLogWhereUniqueInput;
};

export type AdminActionLogWhereInput = {
  AND?: InputMaybe<Array<AdminActionLogWhereInput>>;
  NOT?: InputMaybe<Array<AdminActionLogWhereInput>>;
  OR?: InputMaybe<Array<AdminActionLogWhereInput>>;
  action?: InputMaybe<StringFilter>;
  admin?: InputMaybe<UserScalarRelationFilter>;
  adminId?: InputMaybe<StringFilter>;
  afterChange?: InputMaybe<JsonNullableFilter>;
  beforeChange?: InputMaybe<JsonNullableFilter>;
  entityId?: InputMaybe<StringFilter>;
  entityType?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  timestamp?: InputMaybe<DateTimeFilter>;
};

export type AdminActionLogWhereUniqueInput = {
  AND?: InputMaybe<Array<AdminActionLogWhereInput>>;
  NOT?: InputMaybe<Array<AdminActionLogWhereInput>>;
  OR?: InputMaybe<Array<AdminActionLogWhereInput>>;
  action?: InputMaybe<StringFilter>;
  admin?: InputMaybe<UserScalarRelationFilter>;
  adminId?: InputMaybe<StringFilter>;
  afterChange?: InputMaybe<JsonNullableFilter>;
  beforeChange?: InputMaybe<JsonNullableFilter>;
  entityId?: InputMaybe<StringFilter>;
  entityType?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<DateTimeFilter>;
};

export type AdminCreateCustomerInput = {
  email: Scalars['String']['input'];
  fullName?: InputMaybe<Scalars['String']['input']>;
  password: Scalars['String']['input'];
  phone?: InputMaybe<Scalars['String']['input']>;
  preferredStoreId?: InputMaybe<Scalars['String']['input']>;
  profileStatus?: InputMaybe<Scalars['String']['input']>;
};

export type AdminProcurementDashboard = {
  __typename?: 'AdminProcurementDashboard';
  creditBlockedSuppliers: Array<SupplierCreditStatus>;
  noSubmissionRequisitions: Array<RequisitionSummary>;
  overduePOs: Array<PurchaseOrder>;
  partialSubmissionRequisitions: Array<RequisitionSummary>;
};

export type AdminSendSupportMessageInput = {
  message: Scalars['String']['input'];
  userId: Scalars['String']['input'];
};

export type AdminUpdateCustomerProfileInput = {
  birthday?: InputMaybe<Scalars['DateTime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  gender?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  preferredStoreId?: InputMaybe<Scalars['String']['input']>;
  profileStatus?: InputMaybe<Scalars['String']['input']>;
};

export type AffectedRows = {
  __typename?: 'AffectedRows';
  count: Scalars['Int']['output'];
};

export type AggregateAsset = {
  __typename?: 'AggregateAsset';
  _avg?: Maybe<AssetAvgAggregate>;
  _count?: Maybe<AssetCountAggregate>;
  _max?: Maybe<AssetMaxAggregate>;
  _min?: Maybe<AssetMinAggregate>;
  _sum?: Maybe<AssetSumAggregate>;
};

export type AggregateProduct = {
  __typename?: 'AggregateProduct';
  _count?: Maybe<ProductCountAggregate>;
  _max?: Maybe<ProductMaxAggregate>;
  _min?: Maybe<ProductMinAggregate>;
};

export type AggregateProductVariant = {
  __typename?: 'AggregateProductVariant';
  _avg?: Maybe<ProductVariantAvgAggregate>;
  _count?: Maybe<ProductVariantCountAggregate>;
  _max?: Maybe<ProductVariantMaxAggregate>;
  _min?: Maybe<ProductVariantMinAggregate>;
  _sum?: Maybe<ProductVariantSumAggregate>;
};

export type AggregateStore = {
  __typename?: 'AggregateStore';
  _count?: Maybe<StoreCountAggregate>;
  _max?: Maybe<StoreMaxAggregate>;
  _min?: Maybe<StoreMinAggregate>;
};

export type AggregateUser = {
  __typename?: 'AggregateUser';
  _count?: Maybe<UserCountAggregate>;
  _max?: Maybe<UserMaxAggregate>;
  _min?: Maybe<UserMinAggregate>;
};

export type ApplyResellerInput = {
  creditLimit: Scalars['Float']['input'];
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  requestedBillerId?: InputMaybe<Scalars['String']['input']>;
  tier: UserTier;
};

export type ApproveInvoiceImportInput = {
  confirmedById?: InputMaybe<Scalars['String']['input']>;
  createPurchaseOrder?: InputMaybe<Scalars['Boolean']['input']>;
  createSupplierPayment?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['String']['input'];
  overrideLines?: InputMaybe<Array<InvoiceImportLineInput>>;
  receiveStock?: InputMaybe<Scalars['Boolean']['input']>;
  receivedById?: InputMaybe<Scalars['String']['input']>;
  storeId?: InputMaybe<Scalars['String']['input']>;
  supplierName?: InputMaybe<Scalars['String']['input']>;
  useParsedTotal?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ApproveInvoiceResult = {
  __typename?: 'ApproveInvoiceResult';
  invoiceImport: InvoiceImport;
  purchaseOrderId?: Maybe<Scalars['String']['output']>;
};

export type ApproveResellerInput = {
  billerId?: InputMaybe<Scalars['String']['input']>;
  creditLimit: Scalars['Float']['input'];
  tier: UserTier;
};

export type Asset = {
  __typename?: 'Asset';
  _count: AssetCount;
  assignments?: Maybe<Array<AssetAssignment>>;
  bucket: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  filename?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  kind: AssetKind;
  metadata?: Maybe<Scalars['JSON']['output']>;
  mimetype?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  url: Scalars['String']['output'];
};

export type AssetAssignment = {
  __typename?: 'AssetAssignment';
  asset: Asset;
  assetId: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  entityId: Scalars['String']['output'];
  entityType: AssetEntityType;
  id: Scalars['ID']['output'];
  isPrimary: Scalars['Boolean']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type AssetAssignmentListRelationFilter = {
  every?: InputMaybe<AssetAssignmentWhereInput>;
  none?: InputMaybe<AssetAssignmentWhereInput>;
  some?: InputMaybe<AssetAssignmentWhereInput>;
};

export type AssetAssignmentOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type AssetAssignmentWhereInput = {
  AND?: InputMaybe<Array<AssetAssignmentWhereInput>>;
  NOT?: InputMaybe<Array<AssetAssignmentWhereInput>>;
  OR?: InputMaybe<Array<AssetAssignmentWhereInput>>;
  asset?: InputMaybe<AssetScalarRelationFilter>;
  assetId?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  entityId?: InputMaybe<StringFilter>;
  entityType?: InputMaybe<EnumAssetEntityTypeFilter>;
  id?: InputMaybe<StringFilter>;
  isPrimary?: InputMaybe<BoolFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type AssetAssignmentsByEntityInput = {
  entityId: Scalars['String']['input'];
  entityType: AssetEntityType;
};

export type AssetAvgAggregate = {
  __typename?: 'AssetAvgAggregate';
  size?: Maybe<Scalars['Float']['output']>;
};

export type AssetAvgAggregateInput = {
  size?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AssetAvgOrderByAggregateInput = {
  size?: InputMaybe<SortOrder>;
};

export type AssetCount = {
  __typename?: 'AssetCount';
  assignments: Scalars['Int']['output'];
};

export type AssetCountAggregate = {
  __typename?: 'AssetCountAggregate';
  _all: Scalars['Int']['output'];
  bucket: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  filename: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  key: Scalars['Int']['output'];
  kind: Scalars['Int']['output'];
  metadata: Scalars['Int']['output'];
  mimetype: Scalars['Int']['output'];
  size: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
  url: Scalars['Int']['output'];
};

export type AssetCountAggregateInput = {
  _all?: InputMaybe<Scalars['Boolean']['input']>;
  bucket?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  filename?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  key?: InputMaybe<Scalars['Boolean']['input']>;
  kind?: InputMaybe<Scalars['Boolean']['input']>;
  metadata?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['Boolean']['input']>;
  size?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  url?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AssetCountOrderByAggregateInput = {
  bucket?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  filename?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  kind?: InputMaybe<SortOrder>;
  metadata?: InputMaybe<SortOrder>;
  mimetype?: InputMaybe<SortOrder>;
  size?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  url?: InputMaybe<SortOrder>;
};

export enum AssetEntityType {
  Collection = 'COLLECTION',
  Hero = 'HERO',
  Page = 'PAGE',
  Product = 'PRODUCT',
  ProductVariant = 'PRODUCT_VARIANT',
  User = 'USER'
}

export type AssetGroupBy = {
  __typename?: 'AssetGroupBy';
  _avg?: Maybe<AssetAvgAggregate>;
  _count?: Maybe<AssetCountAggregate>;
  _max?: Maybe<AssetMaxAggregate>;
  _min?: Maybe<AssetMinAggregate>;
  _sum?: Maybe<AssetSumAggregate>;
  bucket: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  filename?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  key: Scalars['String']['output'];
  kind: AssetKind;
  metadata?: Maybe<Scalars['JSON']['output']>;
  mimetype?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  url: Scalars['String']['output'];
};

export enum AssetKind {
  Document = 'DOCUMENT',
  Image = 'IMAGE',
  Other = 'OTHER',
  Video = 'VIDEO'
}

export type AssetMaxAggregate = {
  __typename?: 'AssetMaxAggregate';
  bucket?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  filename?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  kind?: Maybe<AssetKind>;
  mimetype?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

export type AssetMaxAggregateInput = {
  bucket?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  filename?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  key?: InputMaybe<Scalars['Boolean']['input']>;
  kind?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['Boolean']['input']>;
  size?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  url?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AssetMaxOrderByAggregateInput = {
  bucket?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  filename?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  kind?: InputMaybe<SortOrder>;
  mimetype?: InputMaybe<SortOrder>;
  size?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  url?: InputMaybe<SortOrder>;
};

export type AssetMinAggregate = {
  __typename?: 'AssetMinAggregate';
  bucket?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  filename?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  kind?: Maybe<AssetKind>;
  mimetype?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

export type AssetMinAggregateInput = {
  bucket?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  filename?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  key?: InputMaybe<Scalars['Boolean']['input']>;
  kind?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['Boolean']['input']>;
  size?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
  url?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AssetMinOrderByAggregateInput = {
  bucket?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  filename?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  kind?: InputMaybe<SortOrder>;
  mimetype?: InputMaybe<SortOrder>;
  size?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  url?: InputMaybe<SortOrder>;
};

export type AssetOrderByWithAggregationInput = {
  _avg?: InputMaybe<AssetAvgOrderByAggregateInput>;
  _count?: InputMaybe<AssetCountOrderByAggregateInput>;
  _max?: InputMaybe<AssetMaxOrderByAggregateInput>;
  _min?: InputMaybe<AssetMinOrderByAggregateInput>;
  _sum?: InputMaybe<AssetSumOrderByAggregateInput>;
  bucket?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  filename?: InputMaybe<SortOrderInput>;
  id?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  kind?: InputMaybe<SortOrder>;
  metadata?: InputMaybe<SortOrderInput>;
  mimetype?: InputMaybe<SortOrderInput>;
  size?: InputMaybe<SortOrderInput>;
  updatedAt?: InputMaybe<SortOrder>;
  url?: InputMaybe<SortOrder>;
};

export type AssetOrderByWithRelationInput = {
  assignments?: InputMaybe<AssetAssignmentOrderByRelationAggregateInput>;
  bucket?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  filename?: InputMaybe<SortOrderInput>;
  id?: InputMaybe<SortOrder>;
  key?: InputMaybe<SortOrder>;
  kind?: InputMaybe<SortOrder>;
  metadata?: InputMaybe<SortOrderInput>;
  mimetype?: InputMaybe<SortOrderInput>;
  size?: InputMaybe<SortOrderInput>;
  updatedAt?: InputMaybe<SortOrder>;
  url?: InputMaybe<SortOrder>;
};

export enum AssetScalarFieldEnum {
  Bucket = 'bucket',
  CreatedAt = 'createdAt',
  Filename = 'filename',
  Id = 'id',
  Key = 'key',
  Kind = 'kind',
  Metadata = 'metadata',
  Mimetype = 'mimetype',
  Size = 'size',
  UpdatedAt = 'updatedAt',
  Url = 'url'
}

export type AssetScalarRelationFilter = {
  is?: InputMaybe<AssetWhereInput>;
  isNot?: InputMaybe<AssetWhereInput>;
};

export type AssetScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<AssetScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<AssetScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<AssetScalarWhereWithAggregatesInput>>;
  bucket?: InputMaybe<StringWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  filename?: InputMaybe<StringNullableWithAggregatesFilter>;
  id?: InputMaybe<StringWithAggregatesFilter>;
  key?: InputMaybe<StringWithAggregatesFilter>;
  kind?: InputMaybe<EnumAssetKindWithAggregatesFilter>;
  metadata?: InputMaybe<JsonNullableWithAggregatesFilter>;
  mimetype?: InputMaybe<StringNullableWithAggregatesFilter>;
  size?: InputMaybe<IntNullableWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  url?: InputMaybe<StringWithAggregatesFilter>;
};

export type AssetSumAggregate = {
  __typename?: 'AssetSumAggregate';
  size?: Maybe<Scalars['Int']['output']>;
};

export type AssetSumAggregateInput = {
  size?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AssetSumOrderByAggregateInput = {
  size?: InputMaybe<SortOrder>;
};

export type AssetWhereInput = {
  AND?: InputMaybe<Array<AssetWhereInput>>;
  NOT?: InputMaybe<Array<AssetWhereInput>>;
  OR?: InputMaybe<Array<AssetWhereInput>>;
  assignments?: InputMaybe<AssetAssignmentListRelationFilter>;
  bucket?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  filename?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<StringFilter>;
  key?: InputMaybe<StringFilter>;
  kind?: InputMaybe<EnumAssetKindFilter>;
  metadata?: InputMaybe<JsonNullableFilter>;
  mimetype?: InputMaybe<StringNullableFilter>;
  size?: InputMaybe<IntNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  url?: InputMaybe<StringFilter>;
};

export type AssetWhereUniqueInput = {
  AND?: InputMaybe<Array<AssetWhereInput>>;
  NOT?: InputMaybe<Array<AssetWhereInput>>;
  OR?: InputMaybe<Array<AssetWhereInput>>;
  assignments?: InputMaybe<AssetAssignmentListRelationFilter>;
  bucket?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  filename?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  kind?: InputMaybe<EnumAssetKindFilter>;
  metadata?: InputMaybe<JsonNullableFilter>;
  mimetype?: InputMaybe<StringNullableFilter>;
  size?: InputMaybe<IntNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  url?: InputMaybe<StringFilter>;
};

export type AssignAssetInput = {
  assetId: Scalars['String']['input'];
  entityId: Scalars['String']['input'];
  entityType: AssetEntityType;
  isPrimary?: InputMaybe<Scalars['Boolean']['input']>;
};

export type AssignBillerInput = {
  billerId: Scalars['ID']['input'];
  resellerId: Scalars['ID']['input'];
};

export type AssignFulfillmentPersonnelInput = {
  deliveryPersonnelId: Scalars['String']['input'];
  saleOrderId: Scalars['String']['input'];
};

export type AuthResponse = {
  __typename?: 'AuthResponse';
  accessToken: Scalars['String']['output'];
  user: User;
};

export type BillerConvertQuotationInput = {
  billerId: Scalars['ID']['input'];
  quotationId: Scalars['ID']['input'];
};

export type BillerPaymentsSummary = {
  __typename?: 'BillerPaymentsSummary';
  billerId: Scalars['String']['output'];
  consumerCount: Scalars['Int']['output'];
  consumerPaid: Scalars['Float']['output'];
  month?: Maybe<Scalars['String']['output']>;
  resellerCount: Scalars['Int']['output'];
  resellerPaid: Scalars['Float']['output'];
  storeId?: Maybe<Scalars['String']['output']>;
  totalPaid: Scalars['Float']['output'];
};

export type BoolFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['Boolean']['input']>;
};

export type BoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type BoolWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBoolFilter>;
  _min?: InputMaybe<NestedBoolFilter>;
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolWithAggregatesFilter>;
};

export type ChangePasswordInput = {
  currentPassword: Scalars['String']['input'];
  newPassword: Scalars['String']['input'];
};

export type CheckoutConsumerQuotationInput = {
  billerId: Scalars['ID']['input'];
  quotationId: Scalars['ID']['input'];
};

export type CloseRfqInput = {
  rejectDrafts?: InputMaybe<Scalars['Boolean']['input']>;
  rejectUnsubmitted?: InputMaybe<Scalars['Boolean']['input']>;
  requisitionId: Scalars['String']['input'];
};

export type CollectionGql = {
  __typename?: 'CollectionGQL';
  code: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  filters: Scalars['JSON']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  target: CollectionTarget;
  updatedAt: Scalars['DateTime']['output'];
};

export enum CollectionTarget {
  Product = 'PRODUCT',
  Variant = 'VARIANT'
}

export type ConfirmConsumerPaymentInput = {
  paymentId: Scalars['ID']['input'];
};

export type ConfirmResellerQuotationInput = {
  billerId: Scalars['ID']['input'];
  quotationId: Scalars['ID']['input'];
};

export type ConsumerPayment = {
  __typename?: 'ConsumerPayment';
  amount: Scalars['Float']['output'];
  consumerSaleId: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  method: PaymentMethod;
  receivedAt: Scalars['DateTime']['output'];
  reference?: Maybe<Scalars['String']['output']>;
  sale: ConsumerSale;
  saleOrder: SaleOrder;
  saleOrderId: Scalars['String']['output'];
  status: PaymentStatus;
};

export type ConsumerPaymentAvgAggregate = {
  __typename?: 'ConsumerPaymentAvgAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
};

export type ConsumerPaymentCountAggregate = {
  __typename?: 'ConsumerPaymentCountAggregate';
  _all: Scalars['Int']['output'];
  amount: Scalars['Int']['output'];
  consumerSaleId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  method: Scalars['Int']['output'];
  receivedAt: Scalars['Int']['output'];
  reference: Scalars['Int']['output'];
  saleOrderId: Scalars['Int']['output'];
  status: Scalars['Int']['output'];
};

export type ConsumerPaymentCreateManySaleInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  saleOrderId: Scalars['String']['input'];
  status?: InputMaybe<PaymentStatus>;
};

export type ConsumerPaymentCreateManySaleInputEnvelope = {
  data: Array<ConsumerPaymentCreateManySaleInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConsumerPaymentCreateManySaleOrderInput = {
  amount: Scalars['Float']['input'];
  consumerSaleId: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<PaymentStatus>;
};

export type ConsumerPaymentCreateManySaleOrderInputEnvelope = {
  data: Array<ConsumerPaymentCreateManySaleOrderInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConsumerPaymentCreateNestedManyWithoutSaleInput = {
  connect?: InputMaybe<Array<ConsumerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerPaymentCreateOrConnectWithoutSaleInput>>;
  create?: InputMaybe<Array<ConsumerPaymentCreateWithoutSaleInput>>;
  createMany?: InputMaybe<ConsumerPaymentCreateManySaleInputEnvelope>;
};

export type ConsumerPaymentCreateNestedManyWithoutSaleOrderInput = {
  connect?: InputMaybe<Array<ConsumerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerPaymentCreateOrConnectWithoutSaleOrderInput>>;
  create?: InputMaybe<Array<ConsumerPaymentCreateWithoutSaleOrderInput>>;
  createMany?: InputMaybe<ConsumerPaymentCreateManySaleOrderInputEnvelope>;
};

export type ConsumerPaymentCreateOrConnectWithoutSaleInput = {
  create: ConsumerPaymentCreateWithoutSaleInput;
  where: ConsumerPaymentWhereUniqueInput;
};

export type ConsumerPaymentCreateOrConnectWithoutSaleOrderInput = {
  create: ConsumerPaymentCreateWithoutSaleOrderInput;
  where: ConsumerPaymentWhereUniqueInput;
};

export type ConsumerPaymentCreateWithoutSaleInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  saleOrder: SaleOrderCreateNestedOneWithoutConsumerPaymentInput;
  status?: InputMaybe<PaymentStatus>;
};

export type ConsumerPaymentCreateWithoutSaleOrderInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  sale: ConsumerSaleCreateNestedOneWithoutPaymentsInput;
  status?: InputMaybe<PaymentStatus>;
};

export type ConsumerPaymentListRelationFilter = {
  every?: InputMaybe<ConsumerPaymentWhereInput>;
  none?: InputMaybe<ConsumerPaymentWhereInput>;
  some?: InputMaybe<ConsumerPaymentWhereInput>;
};

export type ConsumerPaymentMaxAggregate = {
  __typename?: 'ConsumerPaymentMaxAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
  consumerSaleId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  method?: Maybe<PaymentMethod>;
  receivedAt?: Maybe<Scalars['DateTime']['output']>;
  reference?: Maybe<Scalars['String']['output']>;
  saleOrderId?: Maybe<Scalars['String']['output']>;
  status?: Maybe<PaymentStatus>;
};

export type ConsumerPaymentMinAggregate = {
  __typename?: 'ConsumerPaymentMinAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
  consumerSaleId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  method?: Maybe<PaymentMethod>;
  receivedAt?: Maybe<Scalars['DateTime']['output']>;
  reference?: Maybe<Scalars['String']['output']>;
  saleOrderId?: Maybe<Scalars['String']['output']>;
  status?: Maybe<PaymentStatus>;
};

export type ConsumerPaymentScalarWhereInput = {
  AND?: InputMaybe<Array<ConsumerPaymentScalarWhereInput>>;
  NOT?: InputMaybe<Array<ConsumerPaymentScalarWhereInput>>;
  OR?: InputMaybe<Array<ConsumerPaymentScalarWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  consumerSaleId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  method?: InputMaybe<EnumPaymentMethodFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  reference?: InputMaybe<StringNullableFilter>;
  saleOrderId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumPaymentStatusFilter>;
};

export type ConsumerPaymentSumAggregate = {
  __typename?: 'ConsumerPaymentSumAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
};

export type ConsumerPaymentUpdateManyMutationInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<EnumPaymentMethodFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  reference?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumPaymentStatusFieldUpdateOperationsInput>;
};

export type ConsumerPaymentUpdateManyWithWhereWithoutSaleInput = {
  data: ConsumerPaymentUpdateManyMutationInput;
  where: ConsumerPaymentScalarWhereInput;
};

export type ConsumerPaymentUpdateManyWithWhereWithoutSaleOrderInput = {
  data: ConsumerPaymentUpdateManyMutationInput;
  where: ConsumerPaymentScalarWhereInput;
};

export type ConsumerPaymentUpdateManyWithoutSaleNestedInput = {
  connect?: InputMaybe<Array<ConsumerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerPaymentCreateOrConnectWithoutSaleInput>>;
  create?: InputMaybe<Array<ConsumerPaymentCreateWithoutSaleInput>>;
  createMany?: InputMaybe<ConsumerPaymentCreateManySaleInputEnvelope>;
  delete?: InputMaybe<Array<ConsumerPaymentWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ConsumerPaymentScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ConsumerPaymentWhereUniqueInput>>;
  set?: InputMaybe<Array<ConsumerPaymentWhereUniqueInput>>;
  update?: InputMaybe<Array<ConsumerPaymentUpdateWithWhereUniqueWithoutSaleInput>>;
  updateMany?: InputMaybe<Array<ConsumerPaymentUpdateManyWithWhereWithoutSaleInput>>;
  upsert?: InputMaybe<Array<ConsumerPaymentUpsertWithWhereUniqueWithoutSaleInput>>;
};

export type ConsumerPaymentUpdateManyWithoutSaleOrderNestedInput = {
  connect?: InputMaybe<Array<ConsumerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerPaymentCreateOrConnectWithoutSaleOrderInput>>;
  create?: InputMaybe<Array<ConsumerPaymentCreateWithoutSaleOrderInput>>;
  createMany?: InputMaybe<ConsumerPaymentCreateManySaleOrderInputEnvelope>;
  delete?: InputMaybe<Array<ConsumerPaymentWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ConsumerPaymentScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ConsumerPaymentWhereUniqueInput>>;
  set?: InputMaybe<Array<ConsumerPaymentWhereUniqueInput>>;
  update?: InputMaybe<Array<ConsumerPaymentUpdateWithWhereUniqueWithoutSaleOrderInput>>;
  updateMany?: InputMaybe<Array<ConsumerPaymentUpdateManyWithWhereWithoutSaleOrderInput>>;
  upsert?: InputMaybe<Array<ConsumerPaymentUpsertWithWhereUniqueWithoutSaleOrderInput>>;
};

export type ConsumerPaymentUpdateWithWhereUniqueWithoutSaleInput = {
  data: ConsumerPaymentUpdateWithoutSaleInput;
  where: ConsumerPaymentWhereUniqueInput;
};

export type ConsumerPaymentUpdateWithWhereUniqueWithoutSaleOrderInput = {
  data: ConsumerPaymentUpdateWithoutSaleOrderInput;
  where: ConsumerPaymentWhereUniqueInput;
};

export type ConsumerPaymentUpdateWithoutSaleInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<EnumPaymentMethodFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  reference?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  saleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutConsumerPaymentNestedInput>;
  status?: InputMaybe<EnumPaymentStatusFieldUpdateOperationsInput>;
};

export type ConsumerPaymentUpdateWithoutSaleOrderInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<EnumPaymentMethodFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  reference?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  sale?: InputMaybe<ConsumerSaleUpdateOneRequiredWithoutPaymentsNestedInput>;
  status?: InputMaybe<EnumPaymentStatusFieldUpdateOperationsInput>;
};

export type ConsumerPaymentUpsertWithWhereUniqueWithoutSaleInput = {
  create: ConsumerPaymentCreateWithoutSaleInput;
  update: ConsumerPaymentUpdateWithoutSaleInput;
  where: ConsumerPaymentWhereUniqueInput;
};

export type ConsumerPaymentUpsertWithWhereUniqueWithoutSaleOrderInput = {
  create: ConsumerPaymentCreateWithoutSaleOrderInput;
  update: ConsumerPaymentUpdateWithoutSaleOrderInput;
  where: ConsumerPaymentWhereUniqueInput;
};

export type ConsumerPaymentWhereInput = {
  AND?: InputMaybe<Array<ConsumerPaymentWhereInput>>;
  NOT?: InputMaybe<Array<ConsumerPaymentWhereInput>>;
  OR?: InputMaybe<Array<ConsumerPaymentWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  consumerSaleId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  method?: InputMaybe<EnumPaymentMethodFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  reference?: InputMaybe<StringNullableFilter>;
  sale?: InputMaybe<ConsumerSaleScalarRelationFilter>;
  saleOrder?: InputMaybe<SaleOrderScalarRelationFilter>;
  saleOrderId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumPaymentStatusFilter>;
};

export type ConsumerPaymentWhereUniqueInput = {
  AND?: InputMaybe<Array<ConsumerPaymentWhereInput>>;
  NOT?: InputMaybe<Array<ConsumerPaymentWhereInput>>;
  OR?: InputMaybe<Array<ConsumerPaymentWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  consumerSaleId?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  method?: InputMaybe<EnumPaymentMethodFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  reference?: InputMaybe<StringNullableFilter>;
  sale?: InputMaybe<ConsumerSaleScalarRelationFilter>;
  saleOrder?: InputMaybe<SaleOrderScalarRelationFilter>;
  saleOrderId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumPaymentStatusFilter>;
};

export type ConsumerReceipt = {
  __typename?: 'ConsumerReceipt';
  consumerSaleId: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  issuedAt: Scalars['DateTime']['output'];
  issuedBy: User;
  issuedById: Scalars['String']['output'];
  receiptUrl?: Maybe<Scalars['String']['output']>;
  sale: ConsumerSale;
};

export type ConsumerReceiptCountAggregate = {
  __typename?: 'ConsumerReceiptCountAggregate';
  _all: Scalars['Int']['output'];
  consumerSaleId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  issuedAt: Scalars['Int']['output'];
  issuedById: Scalars['Int']['output'];
  receiptUrl: Scalars['Int']['output'];
};

export type ConsumerReceiptCreateManyIssuedByInput = {
  consumerSaleId: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  issuedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receiptUrl?: InputMaybe<Scalars['String']['input']>;
};

export type ConsumerReceiptCreateManyIssuedByInputEnvelope = {
  data: Array<ConsumerReceiptCreateManyIssuedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConsumerReceiptCreateNestedManyWithoutIssuedByInput = {
  connect?: InputMaybe<Array<ConsumerReceiptWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerReceiptCreateOrConnectWithoutIssuedByInput>>;
  create?: InputMaybe<Array<ConsumerReceiptCreateWithoutIssuedByInput>>;
  createMany?: InputMaybe<ConsumerReceiptCreateManyIssuedByInputEnvelope>;
};

export type ConsumerReceiptCreateNestedOneWithoutSaleInput = {
  connect?: InputMaybe<ConsumerReceiptWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerReceiptCreateOrConnectWithoutSaleInput>;
  create?: InputMaybe<ConsumerReceiptCreateWithoutSaleInput>;
};

export type ConsumerReceiptCreateOrConnectWithoutIssuedByInput = {
  create: ConsumerReceiptCreateWithoutIssuedByInput;
  where: ConsumerReceiptWhereUniqueInput;
};

export type ConsumerReceiptCreateOrConnectWithoutSaleInput = {
  create: ConsumerReceiptCreateWithoutSaleInput;
  where: ConsumerReceiptWhereUniqueInput;
};

export type ConsumerReceiptCreateWithoutIssuedByInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  issuedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receiptUrl?: InputMaybe<Scalars['String']['input']>;
  sale: ConsumerSaleCreateNestedOneWithoutReceiptInput;
};

export type ConsumerReceiptCreateWithoutSaleInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  issuedAt?: InputMaybe<Scalars['DateTime']['input']>;
  issuedBy: UserCreateNestedOneWithoutConsumerReceiptInput;
  receiptUrl?: InputMaybe<Scalars['String']['input']>;
};

export type ConsumerReceiptListRelationFilter = {
  every?: InputMaybe<ConsumerReceiptWhereInput>;
  none?: InputMaybe<ConsumerReceiptWhereInput>;
  some?: InputMaybe<ConsumerReceiptWhereInput>;
};

export type ConsumerReceiptMaxAggregate = {
  __typename?: 'ConsumerReceiptMaxAggregate';
  consumerSaleId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  issuedAt?: Maybe<Scalars['DateTime']['output']>;
  issuedById?: Maybe<Scalars['String']['output']>;
  receiptUrl?: Maybe<Scalars['String']['output']>;
};

export type ConsumerReceiptMinAggregate = {
  __typename?: 'ConsumerReceiptMinAggregate';
  consumerSaleId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  issuedAt?: Maybe<Scalars['DateTime']['output']>;
  issuedById?: Maybe<Scalars['String']['output']>;
  receiptUrl?: Maybe<Scalars['String']['output']>;
};

export type ConsumerReceiptNullableScalarRelationFilter = {
  is?: InputMaybe<ConsumerReceiptWhereInput>;
  isNot?: InputMaybe<ConsumerReceiptWhereInput>;
};

export type ConsumerReceiptOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ConsumerReceiptScalarWhereInput = {
  AND?: InputMaybe<Array<ConsumerReceiptScalarWhereInput>>;
  NOT?: InputMaybe<Array<ConsumerReceiptScalarWhereInput>>;
  OR?: InputMaybe<Array<ConsumerReceiptScalarWhereInput>>;
  consumerSaleId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  issuedAt?: InputMaybe<DateTimeFilter>;
  issuedById?: InputMaybe<StringFilter>;
  receiptUrl?: InputMaybe<StringNullableFilter>;
};

export type ConsumerReceiptUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  issuedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  receiptUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type ConsumerReceiptUpdateManyWithWhereWithoutIssuedByInput = {
  data: ConsumerReceiptUpdateManyMutationInput;
  where: ConsumerReceiptScalarWhereInput;
};

export type ConsumerReceiptUpdateManyWithoutIssuedByNestedInput = {
  connect?: InputMaybe<Array<ConsumerReceiptWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerReceiptCreateOrConnectWithoutIssuedByInput>>;
  create?: InputMaybe<Array<ConsumerReceiptCreateWithoutIssuedByInput>>;
  createMany?: InputMaybe<ConsumerReceiptCreateManyIssuedByInputEnvelope>;
  delete?: InputMaybe<Array<ConsumerReceiptWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ConsumerReceiptScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ConsumerReceiptWhereUniqueInput>>;
  set?: InputMaybe<Array<ConsumerReceiptWhereUniqueInput>>;
  update?: InputMaybe<Array<ConsumerReceiptUpdateWithWhereUniqueWithoutIssuedByInput>>;
  updateMany?: InputMaybe<Array<ConsumerReceiptUpdateManyWithWhereWithoutIssuedByInput>>;
  upsert?: InputMaybe<Array<ConsumerReceiptUpsertWithWhereUniqueWithoutIssuedByInput>>;
};

export type ConsumerReceiptUpdateOneWithoutSaleNestedInput = {
  connect?: InputMaybe<ConsumerReceiptWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerReceiptCreateOrConnectWithoutSaleInput>;
  create?: InputMaybe<ConsumerReceiptCreateWithoutSaleInput>;
  delete?: InputMaybe<ConsumerReceiptWhereInput>;
  disconnect?: InputMaybe<ConsumerReceiptWhereInput>;
  update?: InputMaybe<ConsumerReceiptUpdateToOneWithWhereWithoutSaleInput>;
  upsert?: InputMaybe<ConsumerReceiptUpsertWithoutSaleInput>;
};

export type ConsumerReceiptUpdateToOneWithWhereWithoutSaleInput = {
  data: ConsumerReceiptUpdateWithoutSaleInput;
  where?: InputMaybe<ConsumerReceiptWhereInput>;
};

export type ConsumerReceiptUpdateWithWhereUniqueWithoutIssuedByInput = {
  data: ConsumerReceiptUpdateWithoutIssuedByInput;
  where: ConsumerReceiptWhereUniqueInput;
};

export type ConsumerReceiptUpdateWithoutIssuedByInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  issuedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  receiptUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  sale?: InputMaybe<ConsumerSaleUpdateOneRequiredWithoutReceiptNestedInput>;
};

export type ConsumerReceiptUpdateWithoutSaleInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  issuedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  issuedBy?: InputMaybe<UserUpdateOneRequiredWithoutConsumerReceiptNestedInput>;
  receiptUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type ConsumerReceiptUpsertWithWhereUniqueWithoutIssuedByInput = {
  create: ConsumerReceiptCreateWithoutIssuedByInput;
  update: ConsumerReceiptUpdateWithoutIssuedByInput;
  where: ConsumerReceiptWhereUniqueInput;
};

export type ConsumerReceiptUpsertWithoutSaleInput = {
  create: ConsumerReceiptCreateWithoutSaleInput;
  update: ConsumerReceiptUpdateWithoutSaleInput;
  where?: InputMaybe<ConsumerReceiptWhereInput>;
};

export type ConsumerReceiptWhereInput = {
  AND?: InputMaybe<Array<ConsumerReceiptWhereInput>>;
  NOT?: InputMaybe<Array<ConsumerReceiptWhereInput>>;
  OR?: InputMaybe<Array<ConsumerReceiptWhereInput>>;
  consumerSaleId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  issuedAt?: InputMaybe<DateTimeFilter>;
  issuedBy?: InputMaybe<UserScalarRelationFilter>;
  issuedById?: InputMaybe<StringFilter>;
  receiptUrl?: InputMaybe<StringNullableFilter>;
  sale?: InputMaybe<ConsumerSaleScalarRelationFilter>;
};

export type ConsumerReceiptWhereUniqueInput = {
  AND?: InputMaybe<Array<ConsumerReceiptWhereInput>>;
  NOT?: InputMaybe<Array<ConsumerReceiptWhereInput>>;
  OR?: InputMaybe<Array<ConsumerReceiptWhereInput>>;
  consumerSaleId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  issuedAt?: InputMaybe<DateTimeFilter>;
  issuedBy?: InputMaybe<UserScalarRelationFilter>;
  issuedById?: InputMaybe<StringFilter>;
  receiptUrl?: InputMaybe<StringNullableFilter>;
  sale?: InputMaybe<ConsumerSaleScalarRelationFilter>;
};

export type ConsumerSale = {
  __typename?: 'ConsumerSale';
  CustomerProfile?: Maybe<Array<CustomerProfile>>;
  SaleOrder: SaleOrder;
  SalesReturn?: Maybe<Array<SalesReturn>>;
  _count: ConsumerSaleCount;
  adjustedBy?: Maybe<User>;
  adjustedById?: Maybe<Scalars['String']['output']>;
  adjustmentType?: Maybe<AdjustmentType>;
  biller: User;
  billerId: Scalars['String']['output'];
  channel: SaleChannel;
  createdAt: Scalars['DateTime']['output'];
  customer?: Maybe<Customer>;
  customerId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  items?: Maybe<Array<ConsumerSaleItem>>;
  payments?: Maybe<Array<ConsumerPayment>>;
  quotation?: Maybe<Quotation>;
  quotationId?: Maybe<Scalars['String']['output']>;
  receipt?: Maybe<ConsumerReceipt>;
  saleOrderId: Scalars['String']['output'];
  status: SaleStatus;
  store: Store;
  storeId: Scalars['String']['output'];
  totalAmount: Scalars['Float']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type ConsumerSaleAvgAggregate = {
  __typename?: 'ConsumerSaleAvgAggregate';
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

export type ConsumerSaleCount = {
  __typename?: 'ConsumerSaleCount';
  CustomerProfile: Scalars['Int']['output'];
  SalesReturn: Scalars['Int']['output'];
  items: Scalars['Int']['output'];
  payments: Scalars['Int']['output'];
};

export type ConsumerSaleCountAggregate = {
  __typename?: 'ConsumerSaleCountAggregate';
  _all: Scalars['Int']['output'];
  adjustedById: Scalars['Int']['output'];
  adjustmentType: Scalars['Int']['output'];
  billerId: Scalars['Int']['output'];
  channel: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  customerId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  quotationId: Scalars['Int']['output'];
  saleOrderId: Scalars['Int']['output'];
  status: Scalars['Int']['output'];
  storeId: Scalars['Int']['output'];
  totalAmount: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
};

export type ConsumerSaleCreateManyAdjustedByInput = {
  adjustmentType?: InputMaybe<AdjustmentType>;
  billerId: Scalars['String']['input'];
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  quotationId?: InputMaybe<Scalars['String']['input']>;
  saleOrderId: Scalars['String']['input'];
  status: SaleStatus;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateManyAdjustedByInputEnvelope = {
  data: Array<ConsumerSaleCreateManyAdjustedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConsumerSaleCreateManyBillerInput = {
  adjustedById?: InputMaybe<Scalars['String']['input']>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  quotationId?: InputMaybe<Scalars['String']['input']>;
  saleOrderId: Scalars['String']['input'];
  status: SaleStatus;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateManyBillerInputEnvelope = {
  data: Array<ConsumerSaleCreateManyBillerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConsumerSaleCreateManyCustomerInput = {
  adjustedById?: InputMaybe<Scalars['String']['input']>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  billerId: Scalars['String']['input'];
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  quotationId?: InputMaybe<Scalars['String']['input']>;
  saleOrderId: Scalars['String']['input'];
  status: SaleStatus;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateManyCustomerInputEnvelope = {
  data: Array<ConsumerSaleCreateManyCustomerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConsumerSaleCreateManyQuotationInput = {
  adjustedById?: InputMaybe<Scalars['String']['input']>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  billerId: Scalars['String']['input'];
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  saleOrderId: Scalars['String']['input'];
  status: SaleStatus;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateManyQuotationInputEnvelope = {
  data: Array<ConsumerSaleCreateManyQuotationInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConsumerSaleCreateManyStoreInput = {
  adjustedById?: InputMaybe<Scalars['String']['input']>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  billerId: Scalars['String']['input'];
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerId?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  quotationId?: InputMaybe<Scalars['String']['input']>;
  saleOrderId: Scalars['String']['input'];
  status: SaleStatus;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateManyStoreInputEnvelope = {
  data: Array<ConsumerSaleCreateManyStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConsumerSaleCreateNestedManyWithoutAdjustedByInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutAdjustedByInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutAdjustedByInput>>;
  createMany?: InputMaybe<ConsumerSaleCreateManyAdjustedByInputEnvelope>;
};

export type ConsumerSaleCreateNestedManyWithoutBillerInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutBillerInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutBillerInput>>;
  createMany?: InputMaybe<ConsumerSaleCreateManyBillerInputEnvelope>;
};

export type ConsumerSaleCreateNestedManyWithoutCustomerInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutCustomerInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutCustomerInput>>;
  createMany?: InputMaybe<ConsumerSaleCreateManyCustomerInputEnvelope>;
};

export type ConsumerSaleCreateNestedManyWithoutCustomerProfileInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutCustomerProfileInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutCustomerProfileInput>>;
};

export type ConsumerSaleCreateNestedManyWithoutQuotationInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutQuotationInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutQuotationInput>>;
  createMany?: InputMaybe<ConsumerSaleCreateManyQuotationInputEnvelope>;
};

export type ConsumerSaleCreateNestedManyWithoutStoreInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutStoreInput>>;
  createMany?: InputMaybe<ConsumerSaleCreateManyStoreInputEnvelope>;
};

export type ConsumerSaleCreateNestedOneWithoutItemsInput = {
  connect?: InputMaybe<ConsumerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerSaleCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<ConsumerSaleCreateWithoutItemsInput>;
};

export type ConsumerSaleCreateNestedOneWithoutPaymentsInput = {
  connect?: InputMaybe<ConsumerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerSaleCreateOrConnectWithoutPaymentsInput>;
  create?: InputMaybe<ConsumerSaleCreateWithoutPaymentsInput>;
};

export type ConsumerSaleCreateNestedOneWithoutReceiptInput = {
  connect?: InputMaybe<ConsumerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerSaleCreateOrConnectWithoutReceiptInput>;
  create?: InputMaybe<ConsumerSaleCreateWithoutReceiptInput>;
};

export type ConsumerSaleCreateNestedOneWithoutSaleOrderInput = {
  connect?: InputMaybe<ConsumerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerSaleCreateOrConnectWithoutSaleOrderInput>;
  create?: InputMaybe<ConsumerSaleCreateWithoutSaleOrderInput>;
};

export type ConsumerSaleCreateNestedOneWithoutSalesReturnInput = {
  connect?: InputMaybe<ConsumerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerSaleCreateOrConnectWithoutSalesReturnInput>;
  create?: InputMaybe<ConsumerSaleCreateWithoutSalesReturnInput>;
};

export type ConsumerSaleCreateOrConnectWithoutAdjustedByInput = {
  create: ConsumerSaleCreateWithoutAdjustedByInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleCreateOrConnectWithoutBillerInput = {
  create: ConsumerSaleCreateWithoutBillerInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleCreateOrConnectWithoutCustomerInput = {
  create: ConsumerSaleCreateWithoutCustomerInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleCreateOrConnectWithoutCustomerProfileInput = {
  create: ConsumerSaleCreateWithoutCustomerProfileInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleCreateOrConnectWithoutItemsInput = {
  create: ConsumerSaleCreateWithoutItemsInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleCreateOrConnectWithoutPaymentsInput = {
  create: ConsumerSaleCreateWithoutPaymentsInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleCreateOrConnectWithoutQuotationInput = {
  create: ConsumerSaleCreateWithoutQuotationInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleCreateOrConnectWithoutReceiptInput = {
  create: ConsumerSaleCreateWithoutReceiptInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleCreateOrConnectWithoutSaleOrderInput = {
  create: ConsumerSaleCreateWithoutSaleOrderInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleCreateOrConnectWithoutSalesReturnInput = {
  create: ConsumerSaleCreateWithoutSalesReturnInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleCreateOrConnectWithoutStoreInput = {
  create: ConsumerSaleCreateWithoutStoreInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleCreateWithoutAdjustedByInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutSalesInput>;
  SaleOrder: SaleOrderCreateNestedOneWithoutConsumerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutConsumerSaleInput>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  biller: UserCreateNestedOneWithoutConsumerSaleInput;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customer?: InputMaybe<CustomerCreateNestedOneWithoutSalesInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutConsumerSaleInput>;
  receipt?: InputMaybe<ConsumerReceiptCreateNestedOneWithoutSaleInput>;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutCustomerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateWithoutBillerInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutSalesInput>;
  SaleOrder: SaleOrderCreateNestedOneWithoutConsumerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutConsumerSaleInput>;
  adjustedBy?: InputMaybe<UserCreateNestedOneWithoutConsumerSaleAdjustedBysInput>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customer?: InputMaybe<CustomerCreateNestedOneWithoutSalesInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutConsumerSaleInput>;
  receipt?: InputMaybe<ConsumerReceiptCreateNestedOneWithoutSaleInput>;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutCustomerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateWithoutCustomerInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutSalesInput>;
  SaleOrder: SaleOrderCreateNestedOneWithoutConsumerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutConsumerSaleInput>;
  adjustedBy?: InputMaybe<UserCreateNestedOneWithoutConsumerSaleAdjustedBysInput>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  biller: UserCreateNestedOneWithoutConsumerSaleInput;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutConsumerSaleInput>;
  receipt?: InputMaybe<ConsumerReceiptCreateNestedOneWithoutSaleInput>;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutCustomerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateWithoutCustomerProfileInput = {
  SaleOrder: SaleOrderCreateNestedOneWithoutConsumerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutConsumerSaleInput>;
  adjustedBy?: InputMaybe<UserCreateNestedOneWithoutConsumerSaleAdjustedBysInput>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  biller: UserCreateNestedOneWithoutConsumerSaleInput;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customer?: InputMaybe<CustomerCreateNestedOneWithoutSalesInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutConsumerSaleInput>;
  receipt?: InputMaybe<ConsumerReceiptCreateNestedOneWithoutSaleInput>;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutCustomerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateWithoutItemsInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutSalesInput>;
  SaleOrder: SaleOrderCreateNestedOneWithoutConsumerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutConsumerSaleInput>;
  adjustedBy?: InputMaybe<UserCreateNestedOneWithoutConsumerSaleAdjustedBysInput>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  biller: UserCreateNestedOneWithoutConsumerSaleInput;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customer?: InputMaybe<CustomerCreateNestedOneWithoutSalesInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  payments?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutConsumerSaleInput>;
  receipt?: InputMaybe<ConsumerReceiptCreateNestedOneWithoutSaleInput>;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutCustomerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateWithoutPaymentsInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutSalesInput>;
  SaleOrder: SaleOrderCreateNestedOneWithoutConsumerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutConsumerSaleInput>;
  adjustedBy?: InputMaybe<UserCreateNestedOneWithoutConsumerSaleAdjustedBysInput>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  biller: UserCreateNestedOneWithoutConsumerSaleInput;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customer?: InputMaybe<CustomerCreateNestedOneWithoutSalesInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutConsumerSaleInput>;
  receipt?: InputMaybe<ConsumerReceiptCreateNestedOneWithoutSaleInput>;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutCustomerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateWithoutQuotationInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutSalesInput>;
  SaleOrder: SaleOrderCreateNestedOneWithoutConsumerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutConsumerSaleInput>;
  adjustedBy?: InputMaybe<UserCreateNestedOneWithoutConsumerSaleAdjustedBysInput>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  biller: UserCreateNestedOneWithoutConsumerSaleInput;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customer?: InputMaybe<CustomerCreateNestedOneWithoutSalesInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleInput>;
  receipt?: InputMaybe<ConsumerReceiptCreateNestedOneWithoutSaleInput>;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutCustomerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateWithoutReceiptInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutSalesInput>;
  SaleOrder: SaleOrderCreateNestedOneWithoutConsumerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutConsumerSaleInput>;
  adjustedBy?: InputMaybe<UserCreateNestedOneWithoutConsumerSaleAdjustedBysInput>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  biller: UserCreateNestedOneWithoutConsumerSaleInput;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customer?: InputMaybe<CustomerCreateNestedOneWithoutSalesInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutConsumerSaleInput>;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutCustomerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateWithoutSaleOrderInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutSalesInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutConsumerSaleInput>;
  adjustedBy?: InputMaybe<UserCreateNestedOneWithoutConsumerSaleAdjustedBysInput>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  biller: UserCreateNestedOneWithoutConsumerSaleInput;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customer?: InputMaybe<CustomerCreateNestedOneWithoutSalesInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutConsumerSaleInput>;
  receipt?: InputMaybe<ConsumerReceiptCreateNestedOneWithoutSaleInput>;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutCustomerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateWithoutSalesReturnInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutSalesInput>;
  SaleOrder: SaleOrderCreateNestedOneWithoutConsumerSaleInput;
  adjustedBy?: InputMaybe<UserCreateNestedOneWithoutConsumerSaleAdjustedBysInput>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  biller: UserCreateNestedOneWithoutConsumerSaleInput;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customer?: InputMaybe<CustomerCreateNestedOneWithoutSalesInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutConsumerSaleInput>;
  receipt?: InputMaybe<ConsumerReceiptCreateNestedOneWithoutSaleInput>;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutCustomerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleCreateWithoutStoreInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutSalesInput>;
  SaleOrder: SaleOrderCreateNestedOneWithoutConsumerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutConsumerSaleInput>;
  adjustedBy?: InputMaybe<UserCreateNestedOneWithoutConsumerSaleAdjustedBysInput>;
  adjustmentType?: InputMaybe<AdjustmentType>;
  biller: UserCreateNestedOneWithoutConsumerSaleInput;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customer?: InputMaybe<CustomerCreateNestedOneWithoutSalesInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutConsumerSaleInput>;
  receipt?: InputMaybe<ConsumerReceiptCreateNestedOneWithoutSaleInput>;
  status: SaleStatus;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ConsumerSaleItem = {
  __typename?: 'ConsumerSaleItem';
  consumerSaleId: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  sale: ConsumerSale;
  unitPrice: Scalars['Float']['output'];
};

export type ConsumerSaleItemCreateManyProductVariantInput = {
  consumerSaleId: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type ConsumerSaleItemCreateManyProductVariantInputEnvelope = {
  data: Array<ConsumerSaleItemCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConsumerSaleItemCreateManySaleInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type ConsumerSaleItemCreateManySaleInputEnvelope = {
  data: Array<ConsumerSaleItemCreateManySaleInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ConsumerSaleItemCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<ConsumerSaleItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<ConsumerSaleItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<ConsumerSaleItemCreateManyProductVariantInputEnvelope>;
};

export type ConsumerSaleItemCreateNestedManyWithoutSaleInput = {
  connect?: InputMaybe<Array<ConsumerSaleItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleItemCreateOrConnectWithoutSaleInput>>;
  create?: InputMaybe<Array<ConsumerSaleItemCreateWithoutSaleInput>>;
  createMany?: InputMaybe<ConsumerSaleItemCreateManySaleInputEnvelope>;
};

export type ConsumerSaleItemCreateOrConnectWithoutProductVariantInput = {
  create: ConsumerSaleItemCreateWithoutProductVariantInput;
  where: ConsumerSaleItemWhereUniqueInput;
};

export type ConsumerSaleItemCreateOrConnectWithoutSaleInput = {
  create: ConsumerSaleItemCreateWithoutSaleInput;
  where: ConsumerSaleItemWhereUniqueInput;
};

export type ConsumerSaleItemCreateWithoutProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  sale: ConsumerSaleCreateNestedOneWithoutItemsInput;
  unitPrice: Scalars['Float']['input'];
};

export type ConsumerSaleItemCreateWithoutSaleInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutConsumerItemsInput;
  quantity: Scalars['Int']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type ConsumerSaleItemListRelationFilter = {
  every?: InputMaybe<ConsumerSaleItemWhereInput>;
  none?: InputMaybe<ConsumerSaleItemWhereInput>;
  some?: InputMaybe<ConsumerSaleItemWhereInput>;
};

export type ConsumerSaleItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ConsumerSaleItemScalarWhereInput = {
  AND?: InputMaybe<Array<ConsumerSaleItemScalarWhereInput>>;
  NOT?: InputMaybe<Array<ConsumerSaleItemScalarWhereInput>>;
  OR?: InputMaybe<Array<ConsumerSaleItemScalarWhereInput>>;
  consumerSaleId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  unitPrice?: InputMaybe<FloatFilter>;
};

export type ConsumerSaleItemUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  unitPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type ConsumerSaleItemUpdateManyWithWhereWithoutProductVariantInput = {
  data: ConsumerSaleItemUpdateManyMutationInput;
  where: ConsumerSaleItemScalarWhereInput;
};

export type ConsumerSaleItemUpdateManyWithWhereWithoutSaleInput = {
  data: ConsumerSaleItemUpdateManyMutationInput;
  where: ConsumerSaleItemScalarWhereInput;
};

export type ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<ConsumerSaleItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<ConsumerSaleItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<ConsumerSaleItemCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<ConsumerSaleItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ConsumerSaleItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ConsumerSaleItemWhereUniqueInput>>;
  set?: InputMaybe<Array<ConsumerSaleItemWhereUniqueInput>>;
  update?: InputMaybe<Array<ConsumerSaleItemUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<ConsumerSaleItemUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<ConsumerSaleItemUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type ConsumerSaleItemUpdateManyWithoutSaleNestedInput = {
  connect?: InputMaybe<Array<ConsumerSaleItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleItemCreateOrConnectWithoutSaleInput>>;
  create?: InputMaybe<Array<ConsumerSaleItemCreateWithoutSaleInput>>;
  createMany?: InputMaybe<ConsumerSaleItemCreateManySaleInputEnvelope>;
  delete?: InputMaybe<Array<ConsumerSaleItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ConsumerSaleItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ConsumerSaleItemWhereUniqueInput>>;
  set?: InputMaybe<Array<ConsumerSaleItemWhereUniqueInput>>;
  update?: InputMaybe<Array<ConsumerSaleItemUpdateWithWhereUniqueWithoutSaleInput>>;
  updateMany?: InputMaybe<Array<ConsumerSaleItemUpdateManyWithWhereWithoutSaleInput>>;
  upsert?: InputMaybe<Array<ConsumerSaleItemUpsertWithWhereUniqueWithoutSaleInput>>;
};

export type ConsumerSaleItemUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: ConsumerSaleItemUpdateWithoutProductVariantInput;
  where: ConsumerSaleItemWhereUniqueInput;
};

export type ConsumerSaleItemUpdateWithWhereUniqueWithoutSaleInput = {
  data: ConsumerSaleItemUpdateWithoutSaleInput;
  where: ConsumerSaleItemWhereUniqueInput;
};

export type ConsumerSaleItemUpdateWithoutProductVariantInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  sale?: InputMaybe<ConsumerSaleUpdateOneRequiredWithoutItemsNestedInput>;
  unitPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type ConsumerSaleItemUpdateWithoutSaleInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutConsumerItemsNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  unitPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type ConsumerSaleItemUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: ConsumerSaleItemCreateWithoutProductVariantInput;
  update: ConsumerSaleItemUpdateWithoutProductVariantInput;
  where: ConsumerSaleItemWhereUniqueInput;
};

export type ConsumerSaleItemUpsertWithWhereUniqueWithoutSaleInput = {
  create: ConsumerSaleItemCreateWithoutSaleInput;
  update: ConsumerSaleItemUpdateWithoutSaleInput;
  where: ConsumerSaleItemWhereUniqueInput;
};

export type ConsumerSaleItemWhereInput = {
  AND?: InputMaybe<Array<ConsumerSaleItemWhereInput>>;
  NOT?: InputMaybe<Array<ConsumerSaleItemWhereInput>>;
  OR?: InputMaybe<Array<ConsumerSaleItemWhereInput>>;
  consumerSaleId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  sale?: InputMaybe<ConsumerSaleScalarRelationFilter>;
  unitPrice?: InputMaybe<FloatFilter>;
};

export type ConsumerSaleItemWhereUniqueInput = {
  AND?: InputMaybe<Array<ConsumerSaleItemWhereInput>>;
  NOT?: InputMaybe<Array<ConsumerSaleItemWhereInput>>;
  OR?: InputMaybe<Array<ConsumerSaleItemWhereInput>>;
  consumerSaleId?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  sale?: InputMaybe<ConsumerSaleScalarRelationFilter>;
  unitPrice?: InputMaybe<FloatFilter>;
};

export type ConsumerSaleListRelationFilter = {
  every?: InputMaybe<ConsumerSaleWhereInput>;
  none?: InputMaybe<ConsumerSaleWhereInput>;
  some?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleMaxAggregate = {
  __typename?: 'ConsumerSaleMaxAggregate';
  adjustedById?: Maybe<Scalars['String']['output']>;
  adjustmentType?: Maybe<AdjustmentType>;
  billerId?: Maybe<Scalars['String']['output']>;
  channel?: Maybe<SaleChannel>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  customerId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  quotationId?: Maybe<Scalars['String']['output']>;
  saleOrderId?: Maybe<Scalars['String']['output']>;
  status?: Maybe<SaleStatus>;
  storeId?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ConsumerSaleMinAggregate = {
  __typename?: 'ConsumerSaleMinAggregate';
  adjustedById?: Maybe<Scalars['String']['output']>;
  adjustmentType?: Maybe<AdjustmentType>;
  billerId?: Maybe<Scalars['String']['output']>;
  channel?: Maybe<SaleChannel>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  customerId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  quotationId?: Maybe<Scalars['String']['output']>;
  saleOrderId?: Maybe<Scalars['String']['output']>;
  status?: Maybe<SaleStatus>;
  storeId?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ConsumerSaleNullableScalarRelationFilter = {
  is?: InputMaybe<ConsumerSaleWhereInput>;
  isNot?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ConsumerSaleScalarRelationFilter = {
  is?: InputMaybe<ConsumerSaleWhereInput>;
  isNot?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleScalarWhereInput = {
  AND?: InputMaybe<Array<ConsumerSaleScalarWhereInput>>;
  NOT?: InputMaybe<Array<ConsumerSaleScalarWhereInput>>;
  OR?: InputMaybe<Array<ConsumerSaleScalarWhereInput>>;
  adjustedById?: InputMaybe<StringNullableFilter>;
  adjustmentType?: InputMaybe<EnumAdjustmentTypeNullableFilter>;
  billerId?: InputMaybe<StringFilter>;
  channel?: InputMaybe<EnumSaleChannelFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  customerId?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<StringFilter>;
  quotationId?: InputMaybe<StringNullableFilter>;
  saleOrderId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumSaleStatusFilter>;
  storeId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type ConsumerSaleSumAggregate = {
  __typename?: 'ConsumerSaleSumAggregate';
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

export type ConsumerSaleUpdateManyMutationInput = {
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpdateManyWithWhereWithoutAdjustedByInput = {
  data: ConsumerSaleUpdateManyMutationInput;
  where: ConsumerSaleScalarWhereInput;
};

export type ConsumerSaleUpdateManyWithWhereWithoutBillerInput = {
  data: ConsumerSaleUpdateManyMutationInput;
  where: ConsumerSaleScalarWhereInput;
};

export type ConsumerSaleUpdateManyWithWhereWithoutCustomerInput = {
  data: ConsumerSaleUpdateManyMutationInput;
  where: ConsumerSaleScalarWhereInput;
};

export type ConsumerSaleUpdateManyWithWhereWithoutCustomerProfileInput = {
  data: ConsumerSaleUpdateManyMutationInput;
  where: ConsumerSaleScalarWhereInput;
};

export type ConsumerSaleUpdateManyWithWhereWithoutQuotationInput = {
  data: ConsumerSaleUpdateManyMutationInput;
  where: ConsumerSaleScalarWhereInput;
};

export type ConsumerSaleUpdateManyWithWhereWithoutStoreInput = {
  data: ConsumerSaleUpdateManyMutationInput;
  where: ConsumerSaleScalarWhereInput;
};

export type ConsumerSaleUpdateManyWithoutAdjustedByNestedInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutAdjustedByInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutAdjustedByInput>>;
  createMany?: InputMaybe<ConsumerSaleCreateManyAdjustedByInputEnvelope>;
  delete?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ConsumerSaleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  set?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  update?: InputMaybe<Array<ConsumerSaleUpdateWithWhereUniqueWithoutAdjustedByInput>>;
  updateMany?: InputMaybe<Array<ConsumerSaleUpdateManyWithWhereWithoutAdjustedByInput>>;
  upsert?: InputMaybe<Array<ConsumerSaleUpsertWithWhereUniqueWithoutAdjustedByInput>>;
};

export type ConsumerSaleUpdateManyWithoutBillerNestedInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutBillerInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutBillerInput>>;
  createMany?: InputMaybe<ConsumerSaleCreateManyBillerInputEnvelope>;
  delete?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ConsumerSaleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  set?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  update?: InputMaybe<Array<ConsumerSaleUpdateWithWhereUniqueWithoutBillerInput>>;
  updateMany?: InputMaybe<Array<ConsumerSaleUpdateManyWithWhereWithoutBillerInput>>;
  upsert?: InputMaybe<Array<ConsumerSaleUpsertWithWhereUniqueWithoutBillerInput>>;
};

export type ConsumerSaleUpdateManyWithoutCustomerNestedInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutCustomerInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutCustomerInput>>;
  createMany?: InputMaybe<ConsumerSaleCreateManyCustomerInputEnvelope>;
  delete?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ConsumerSaleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  set?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  update?: InputMaybe<Array<ConsumerSaleUpdateWithWhereUniqueWithoutCustomerInput>>;
  updateMany?: InputMaybe<Array<ConsumerSaleUpdateManyWithWhereWithoutCustomerInput>>;
  upsert?: InputMaybe<Array<ConsumerSaleUpsertWithWhereUniqueWithoutCustomerInput>>;
};

export type ConsumerSaleUpdateManyWithoutCustomerProfileNestedInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutCustomerProfileInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutCustomerProfileInput>>;
  delete?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ConsumerSaleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  set?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  update?: InputMaybe<Array<ConsumerSaleUpdateWithWhereUniqueWithoutCustomerProfileInput>>;
  updateMany?: InputMaybe<Array<ConsumerSaleUpdateManyWithWhereWithoutCustomerProfileInput>>;
  upsert?: InputMaybe<Array<ConsumerSaleUpsertWithWhereUniqueWithoutCustomerProfileInput>>;
};

export type ConsumerSaleUpdateManyWithoutQuotationNestedInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutQuotationInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutQuotationInput>>;
  createMany?: InputMaybe<ConsumerSaleCreateManyQuotationInputEnvelope>;
  delete?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ConsumerSaleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  set?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  update?: InputMaybe<Array<ConsumerSaleUpdateWithWhereUniqueWithoutQuotationInput>>;
  updateMany?: InputMaybe<Array<ConsumerSaleUpdateManyWithWhereWithoutQuotationInput>>;
  upsert?: InputMaybe<Array<ConsumerSaleUpsertWithWhereUniqueWithoutQuotationInput>>;
};

export type ConsumerSaleUpdateManyWithoutStoreNestedInput = {
  connect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ConsumerSaleCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<ConsumerSaleCreateWithoutStoreInput>>;
  createMany?: InputMaybe<ConsumerSaleCreateManyStoreInputEnvelope>;
  delete?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ConsumerSaleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  set?: InputMaybe<Array<ConsumerSaleWhereUniqueInput>>;
  update?: InputMaybe<Array<ConsumerSaleUpdateWithWhereUniqueWithoutStoreInput>>;
  updateMany?: InputMaybe<Array<ConsumerSaleUpdateManyWithWhereWithoutStoreInput>>;
  upsert?: InputMaybe<Array<ConsumerSaleUpsertWithWhereUniqueWithoutStoreInput>>;
};

export type ConsumerSaleUpdateOneRequiredWithoutItemsNestedInput = {
  connect?: InputMaybe<ConsumerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerSaleCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<ConsumerSaleCreateWithoutItemsInput>;
  update?: InputMaybe<ConsumerSaleUpdateToOneWithWhereWithoutItemsInput>;
  upsert?: InputMaybe<ConsumerSaleUpsertWithoutItemsInput>;
};

export type ConsumerSaleUpdateOneRequiredWithoutPaymentsNestedInput = {
  connect?: InputMaybe<ConsumerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerSaleCreateOrConnectWithoutPaymentsInput>;
  create?: InputMaybe<ConsumerSaleCreateWithoutPaymentsInput>;
  update?: InputMaybe<ConsumerSaleUpdateToOneWithWhereWithoutPaymentsInput>;
  upsert?: InputMaybe<ConsumerSaleUpsertWithoutPaymentsInput>;
};

export type ConsumerSaleUpdateOneRequiredWithoutReceiptNestedInput = {
  connect?: InputMaybe<ConsumerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerSaleCreateOrConnectWithoutReceiptInput>;
  create?: InputMaybe<ConsumerSaleCreateWithoutReceiptInput>;
  update?: InputMaybe<ConsumerSaleUpdateToOneWithWhereWithoutReceiptInput>;
  upsert?: InputMaybe<ConsumerSaleUpsertWithoutReceiptInput>;
};

export type ConsumerSaleUpdateOneWithoutSaleOrderNestedInput = {
  connect?: InputMaybe<ConsumerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerSaleCreateOrConnectWithoutSaleOrderInput>;
  create?: InputMaybe<ConsumerSaleCreateWithoutSaleOrderInput>;
  delete?: InputMaybe<ConsumerSaleWhereInput>;
  disconnect?: InputMaybe<ConsumerSaleWhereInput>;
  update?: InputMaybe<ConsumerSaleUpdateToOneWithWhereWithoutSaleOrderInput>;
  upsert?: InputMaybe<ConsumerSaleUpsertWithoutSaleOrderInput>;
};

export type ConsumerSaleUpdateOneWithoutSalesReturnNestedInput = {
  connect?: InputMaybe<ConsumerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ConsumerSaleCreateOrConnectWithoutSalesReturnInput>;
  create?: InputMaybe<ConsumerSaleCreateWithoutSalesReturnInput>;
  delete?: InputMaybe<ConsumerSaleWhereInput>;
  disconnect?: InputMaybe<ConsumerSaleWhereInput>;
  update?: InputMaybe<ConsumerSaleUpdateToOneWithWhereWithoutSalesReturnInput>;
  upsert?: InputMaybe<ConsumerSaleUpsertWithoutSalesReturnInput>;
};

export type ConsumerSaleUpdateToOneWithWhereWithoutItemsInput = {
  data: ConsumerSaleUpdateWithoutItemsInput;
  where?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleUpdateToOneWithWhereWithoutPaymentsInput = {
  data: ConsumerSaleUpdateWithoutPaymentsInput;
  where?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleUpdateToOneWithWhereWithoutReceiptInput = {
  data: ConsumerSaleUpdateWithoutReceiptInput;
  where?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleUpdateToOneWithWhereWithoutSaleOrderInput = {
  data: ConsumerSaleUpdateWithoutSaleOrderInput;
  where?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleUpdateToOneWithWhereWithoutSalesReturnInput = {
  data: ConsumerSaleUpdateWithoutSalesReturnInput;
  where?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleUpdateWithWhereUniqueWithoutAdjustedByInput = {
  data: ConsumerSaleUpdateWithoutAdjustedByInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpdateWithWhereUniqueWithoutBillerInput = {
  data: ConsumerSaleUpdateWithoutBillerInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpdateWithWhereUniqueWithoutCustomerInput = {
  data: ConsumerSaleUpdateWithoutCustomerInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpdateWithWhereUniqueWithoutCustomerProfileInput = {
  data: ConsumerSaleUpdateWithoutCustomerProfileInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpdateWithWhereUniqueWithoutQuotationInput = {
  data: ConsumerSaleUpdateWithoutQuotationInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpdateWithWhereUniqueWithoutStoreInput = {
  data: ConsumerSaleUpdateWithoutStoreInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpdateWithoutAdjustedByInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutSalesNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutConsumerSaleNestedInput>;
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customer?: InputMaybe<CustomerUpdateOneWithoutSalesNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ConsumerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutConsumerSaleNestedInput>;
  receipt?: InputMaybe<ConsumerReceiptUpdateOneWithoutSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutCustomerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpdateWithoutBillerInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutSalesNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutConsumerSaleNestedInput>;
  adjustedBy?: InputMaybe<UserUpdateOneWithoutConsumerSaleAdjustedBysNestedInput>;
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customer?: InputMaybe<CustomerUpdateOneWithoutSalesNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ConsumerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutConsumerSaleNestedInput>;
  receipt?: InputMaybe<ConsumerReceiptUpdateOneWithoutSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutCustomerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpdateWithoutCustomerInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutSalesNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutConsumerSaleNestedInput>;
  adjustedBy?: InputMaybe<UserUpdateOneWithoutConsumerSaleAdjustedBysNestedInput>;
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ConsumerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutConsumerSaleNestedInput>;
  receipt?: InputMaybe<ConsumerReceiptUpdateOneWithoutSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutCustomerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpdateWithoutCustomerProfileInput = {
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutConsumerSaleNestedInput>;
  adjustedBy?: InputMaybe<UserUpdateOneWithoutConsumerSaleAdjustedBysNestedInput>;
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customer?: InputMaybe<CustomerUpdateOneWithoutSalesNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ConsumerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutConsumerSaleNestedInput>;
  receipt?: InputMaybe<ConsumerReceiptUpdateOneWithoutSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutCustomerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpdateWithoutItemsInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutSalesNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutConsumerSaleNestedInput>;
  adjustedBy?: InputMaybe<UserUpdateOneWithoutConsumerSaleAdjustedBysNestedInput>;
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customer?: InputMaybe<CustomerUpdateOneWithoutSalesNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  payments?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutConsumerSaleNestedInput>;
  receipt?: InputMaybe<ConsumerReceiptUpdateOneWithoutSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutCustomerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpdateWithoutPaymentsInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutSalesNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutConsumerSaleNestedInput>;
  adjustedBy?: InputMaybe<UserUpdateOneWithoutConsumerSaleAdjustedBysNestedInput>;
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customer?: InputMaybe<CustomerUpdateOneWithoutSalesNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ConsumerSaleItemUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutConsumerSaleNestedInput>;
  receipt?: InputMaybe<ConsumerReceiptUpdateOneWithoutSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutCustomerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpdateWithoutQuotationInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutSalesNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutConsumerSaleNestedInput>;
  adjustedBy?: InputMaybe<UserUpdateOneWithoutConsumerSaleAdjustedBysNestedInput>;
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customer?: InputMaybe<CustomerUpdateOneWithoutSalesNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ConsumerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleNestedInput>;
  receipt?: InputMaybe<ConsumerReceiptUpdateOneWithoutSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutCustomerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpdateWithoutReceiptInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutSalesNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutConsumerSaleNestedInput>;
  adjustedBy?: InputMaybe<UserUpdateOneWithoutConsumerSaleAdjustedBysNestedInput>;
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customer?: InputMaybe<CustomerUpdateOneWithoutSalesNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ConsumerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutConsumerSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutCustomerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpdateWithoutSaleOrderInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutSalesNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutConsumerSaleNestedInput>;
  adjustedBy?: InputMaybe<UserUpdateOneWithoutConsumerSaleAdjustedBysNestedInput>;
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customer?: InputMaybe<CustomerUpdateOneWithoutSalesNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ConsumerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutConsumerSaleNestedInput>;
  receipt?: InputMaybe<ConsumerReceiptUpdateOneWithoutSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutCustomerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpdateWithoutSalesReturnInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutSalesNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  adjustedBy?: InputMaybe<UserUpdateOneWithoutConsumerSaleAdjustedBysNestedInput>;
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customer?: InputMaybe<CustomerUpdateOneWithoutSalesNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ConsumerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutConsumerSaleNestedInput>;
  receipt?: InputMaybe<ConsumerReceiptUpdateOneWithoutSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutCustomerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpdateWithoutStoreInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutSalesNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutConsumerSaleNestedInput>;
  adjustedBy?: InputMaybe<UserUpdateOneWithoutConsumerSaleAdjustedBysNestedInput>;
  adjustmentType?: InputMaybe<NullableEnumAdjustmentTypeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutConsumerSaleNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customer?: InputMaybe<CustomerUpdateOneWithoutSalesNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ConsumerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutConsumerSaleNestedInput>;
  receipt?: InputMaybe<ConsumerReceiptUpdateOneWithoutSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ConsumerSaleUpsertWithWhereUniqueWithoutAdjustedByInput = {
  create: ConsumerSaleCreateWithoutAdjustedByInput;
  update: ConsumerSaleUpdateWithoutAdjustedByInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpsertWithWhereUniqueWithoutBillerInput = {
  create: ConsumerSaleCreateWithoutBillerInput;
  update: ConsumerSaleUpdateWithoutBillerInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpsertWithWhereUniqueWithoutCustomerInput = {
  create: ConsumerSaleCreateWithoutCustomerInput;
  update: ConsumerSaleUpdateWithoutCustomerInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpsertWithWhereUniqueWithoutCustomerProfileInput = {
  create: ConsumerSaleCreateWithoutCustomerProfileInput;
  update: ConsumerSaleUpdateWithoutCustomerProfileInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpsertWithWhereUniqueWithoutQuotationInput = {
  create: ConsumerSaleCreateWithoutQuotationInput;
  update: ConsumerSaleUpdateWithoutQuotationInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpsertWithWhereUniqueWithoutStoreInput = {
  create: ConsumerSaleCreateWithoutStoreInput;
  update: ConsumerSaleUpdateWithoutStoreInput;
  where: ConsumerSaleWhereUniqueInput;
};

export type ConsumerSaleUpsertWithoutItemsInput = {
  create: ConsumerSaleCreateWithoutItemsInput;
  update: ConsumerSaleUpdateWithoutItemsInput;
  where?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleUpsertWithoutPaymentsInput = {
  create: ConsumerSaleCreateWithoutPaymentsInput;
  update: ConsumerSaleUpdateWithoutPaymentsInput;
  where?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleUpsertWithoutReceiptInput = {
  create: ConsumerSaleCreateWithoutReceiptInput;
  update: ConsumerSaleUpdateWithoutReceiptInput;
  where?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleUpsertWithoutSaleOrderInput = {
  create: ConsumerSaleCreateWithoutSaleOrderInput;
  update: ConsumerSaleUpdateWithoutSaleOrderInput;
  where?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleUpsertWithoutSalesReturnInput = {
  create: ConsumerSaleCreateWithoutSalesReturnInput;
  update: ConsumerSaleUpdateWithoutSalesReturnInput;
  where?: InputMaybe<ConsumerSaleWhereInput>;
};

export type ConsumerSaleWhereInput = {
  AND?: InputMaybe<Array<ConsumerSaleWhereInput>>;
  CustomerProfile?: InputMaybe<CustomerProfileListRelationFilter>;
  NOT?: InputMaybe<Array<ConsumerSaleWhereInput>>;
  OR?: InputMaybe<Array<ConsumerSaleWhereInput>>;
  SaleOrder?: InputMaybe<SaleOrderScalarRelationFilter>;
  SalesReturn?: InputMaybe<SalesReturnListRelationFilter>;
  adjustedBy?: InputMaybe<UserNullableScalarRelationFilter>;
  adjustedById?: InputMaybe<StringNullableFilter>;
  adjustmentType?: InputMaybe<EnumAdjustmentTypeNullableFilter>;
  biller?: InputMaybe<UserScalarRelationFilter>;
  billerId?: InputMaybe<StringFilter>;
  channel?: InputMaybe<EnumSaleChannelFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  customer?: InputMaybe<CustomerNullableScalarRelationFilter>;
  customerId?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<StringFilter>;
  items?: InputMaybe<ConsumerSaleItemListRelationFilter>;
  payments?: InputMaybe<ConsumerPaymentListRelationFilter>;
  quotation?: InputMaybe<QuotationNullableScalarRelationFilter>;
  quotationId?: InputMaybe<StringNullableFilter>;
  receipt?: InputMaybe<ConsumerReceiptNullableScalarRelationFilter>;
  saleOrderId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumSaleStatusFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type ConsumerSaleWhereUniqueInput = {
  AND?: InputMaybe<Array<ConsumerSaleWhereInput>>;
  CustomerProfile?: InputMaybe<CustomerProfileListRelationFilter>;
  NOT?: InputMaybe<Array<ConsumerSaleWhereInput>>;
  OR?: InputMaybe<Array<ConsumerSaleWhereInput>>;
  SaleOrder?: InputMaybe<SaleOrderScalarRelationFilter>;
  SalesReturn?: InputMaybe<SalesReturnListRelationFilter>;
  adjustedBy?: InputMaybe<UserNullableScalarRelationFilter>;
  adjustedById?: InputMaybe<StringNullableFilter>;
  adjustmentType?: InputMaybe<EnumAdjustmentTypeNullableFilter>;
  biller?: InputMaybe<UserScalarRelationFilter>;
  billerId?: InputMaybe<StringFilter>;
  channel?: InputMaybe<EnumSaleChannelFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  customer?: InputMaybe<CustomerNullableScalarRelationFilter>;
  customerId?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ConsumerSaleItemListRelationFilter>;
  payments?: InputMaybe<ConsumerPaymentListRelationFilter>;
  quotation?: InputMaybe<QuotationNullableScalarRelationFilter>;
  quotationId?: InputMaybe<StringNullableFilter>;
  receipt?: InputMaybe<ConsumerReceiptNullableScalarRelationFilter>;
  saleOrderId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<EnumSaleStatusFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type CreateCollectionInput = {
  code: Scalars['String']['input'];
  filters: Array<FacetFilterInput>;
  name: Scalars['String']['input'];
  target: CollectionTarget;
};

export type CreateConsumerPaymentInput = {
  amount: Scalars['Float']['input'];
  consumerSaleId: Scalars['ID']['input'];
  method: PaymentMethod;
  reference?: InputMaybe<Scalars['String']['input']>;
  saleOrderId: Scalars['ID']['input'];
};

export type CreateConsumerReceiptInput = {
  consumerSaleId: Scalars['ID']['input'];
  issuedById: Scalars['ID']['input'];
  receiptUrl?: InputMaybe<Scalars['String']['input']>;
};

export type CreateConsumerSaleInput = {
  billerId: Scalars['ID']['input'];
  channel: SaleChannel;
  customerId: Scalars['ID']['input'];
  items: Array<CreateConsumerSaleItemInput>;
  storeId: Scalars['ID']['input'];
};

export type CreateConsumerSaleItemInput = {
  productVariantId: Scalars['ID']['input'];
  quantity: Scalars['Float']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type CreateFacetInput = {
  code: Scalars['String']['input'];
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  values: Array<Scalars['String']['input']>;
};

export type CreateFulfillmentInput = {
  cost?: InputMaybe<Scalars['Float']['input']>;
  deliveryAddress?: InputMaybe<Scalars['String']['input']>;
  deliveryPersonnelId?: InputMaybe<Scalars['ID']['input']>;
  saleOrderId: Scalars['ID']['input'];
  type: Scalars['String']['input'];
};

export type CreateInvoiceImportInput = {
  storeId?: InputMaybe<Scalars['String']['input']>;
  supplierName?: InputMaybe<Scalars['String']['input']>;
  url: Scalars['String']['input'];
};

export type CreateOrderReturnInput = {
  items: Array<CreateSalesReturnItemInput>;
  orderId: Scalars['String']['input'];
  receivedById: Scalars['String']['input'];
  returnLocation: ReturnLocation;
  returnedById: Scalars['String']['input'];
};

export type CreatePOsFromSelectionInput = {
  dueDate?: InputMaybe<Scalars['DateTime']['input']>;
  items: Array<PurchaseSelectionItemInput>;
  requisitionId: Scalars['String']['input'];
};

export type CreatePurchaseOrderInput = {
  dueDate: Scalars['DateTime']['input'];
  invoiceNumber: Scalars['String']['input'];
  items: Array<PurchaseOrderItemInput>;
  supplierId: Scalars['ID']['input'];
  totalAmount: Scalars['Float']['input'];
};

export type CreatePurchaseRequisitionInput = {
  items: Array<CreatePurchaseRequisitionItemInput>;
  requestedById: Scalars['String']['input'];
  storeId: Scalars['String']['input'];
};

export type CreatePurchaseRequisitionItemInput = {
  notes?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  requestedQty: Scalars['Float']['input'];
};

export type CreatePurchaseReturnInput = {
  approvedById: Scalars['String']['input'];
  initiatedById: Scalars['String']['input'];
  items: Array<CreatePurchaseReturnItemInput>;
  reason?: InputMaybe<Scalars['String']['input']>;
  supplierId: Scalars['String']['input'];
};

export type CreatePurchaseReturnItemInput = {
  batchId: Scalars['String']['input'];
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type CreateQuotationDraftInput = {
  billerId?: InputMaybe<Scalars['ID']['input']>;
  channel: SaleChannel;
  consumerId?: InputMaybe<Scalars['ID']['input']>;
  items: Array<CreateQuotationDraftItemInput>;
  resellerId?: InputMaybe<Scalars['ID']['input']>;
  storeId: Scalars['ID']['input'];
  type: SaleType;
};

export type CreateQuotationDraftItemInput = {
  productVariantId: Scalars['ID']['input'];
  quantity: Scalars['Float']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type CreateRequisitionFromLowStockInput = {
  requestedById: Scalars['String']['input'];
  storeId: Scalars['String']['input'];
};

export type CreateResellerPaymentInput = {
  amount: Scalars['Float']['input'];
  method: PaymentMethod;
  receivedById: Scalars['ID']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  resellerId: Scalars['ID']['input'];
  resellerSaleId?: InputMaybe<Scalars['ID']['input']>;
  saleOrderId: Scalars['ID']['input'];
};

export type CreateResellerSaleInput = {
  billerId: Scalars['ID']['input'];
  items: Array<CreateResellerSaleItemInput>;
  resellerId: Scalars['ID']['input'];
  storeId: Scalars['ID']['input'];
};

export type CreateResellerSaleItemInput = {
  productVariantId: Scalars['ID']['input'];
  quantity: Scalars['Float']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type CreateSalesReturnInput = {
  consumerSaleId?: InputMaybe<Scalars['String']['input']>;
  items: Array<CreateSalesReturnItemInput>;
  receivedById: Scalars['String']['input'];
  resellerSaleId?: InputMaybe<Scalars['String']['input']>;
  returnLocation: ReturnLocation;
  returnedById: Scalars['String']['input'];
  type: SaleType;
};

export type CreateSalesReturnItemInput = {
  condition: Scalars['String']['input'];
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type CreateStaffInput = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  role: RoleName;
};

export type CreateSupplierInput = {
  contactInfo?: InputMaybe<Scalars['String']['input']>;
  creditLimit: Scalars['Float']['input'];
  isFrequent: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentTerms?: InputMaybe<Scalars['String']['input']>;
};

export type CreateSupplierPaymentInput = {
  amount: Scalars['Float']['input'];
  method: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentDate: Scalars['DateTime']['input'];
  purchaseOrderId?: InputMaybe<Scalars['ID']['input']>;
  supplierId: Scalars['ID']['input'];
};

export type CreateUserInput = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  tier?: InputMaybe<UserTier>;
};

export type Customer = {
  __typename?: 'Customer';
  CustomerPreferenceProfile?: Maybe<Array<CustomerPreferenceProfile>>;
  Quotation?: Maybe<Array<Quotation>>;
  _count: CustomerCount;
  email?: Maybe<Scalars['String']['output']>;
  fullName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  phone?: Maybe<Scalars['String']['output']>;
  preferredStore?: Maybe<Store>;
  preferredStoreId?: Maybe<Scalars['String']['output']>;
  sales?: Maybe<Array<ConsumerSale>>;
};

export type CustomerAffinityEntry = {
  __typename?: 'CustomerAffinityEntry';
  count: Scalars['Int']['output'];
  productVariantId: Scalars['String']['output'];
};

export type CustomerCount = {
  __typename?: 'CustomerCount';
  CustomerPreferenceProfile: Scalars['Int']['output'];
  Quotation: Scalars['Int']['output'];
  sales: Scalars['Int']['output'];
};

export type CustomerCreateManyPreferredStoreInput = {
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerCreateManyPreferredStoreInputEnvelope = {
  data: Array<CustomerCreateManyPreferredStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CustomerCreateNestedManyWithoutPreferredStoreInput = {
  connect?: InputMaybe<Array<CustomerWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerCreateOrConnectWithoutPreferredStoreInput>>;
  create?: InputMaybe<Array<CustomerCreateWithoutPreferredStoreInput>>;
  createMany?: InputMaybe<CustomerCreateManyPreferredStoreInputEnvelope>;
};

export type CustomerCreateNestedOneWithoutCustomerPreferenceProfileInput = {
  connect?: InputMaybe<CustomerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerCreateOrConnectWithoutCustomerPreferenceProfileInput>;
  create?: InputMaybe<CustomerCreateWithoutCustomerPreferenceProfileInput>;
};

export type CustomerCreateNestedOneWithoutQuotationInput = {
  connect?: InputMaybe<CustomerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerCreateOrConnectWithoutQuotationInput>;
  create?: InputMaybe<CustomerCreateWithoutQuotationInput>;
};

export type CustomerCreateNestedOneWithoutSalesInput = {
  connect?: InputMaybe<CustomerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerCreateOrConnectWithoutSalesInput>;
  create?: InputMaybe<CustomerCreateWithoutSalesInput>;
};

export type CustomerCreateOrConnectWithoutCustomerPreferenceProfileInput = {
  create: CustomerCreateWithoutCustomerPreferenceProfileInput;
  where: CustomerWhereUniqueInput;
};

export type CustomerCreateOrConnectWithoutPreferredStoreInput = {
  create: CustomerCreateWithoutPreferredStoreInput;
  where: CustomerWhereUniqueInput;
};

export type CustomerCreateOrConnectWithoutQuotationInput = {
  create: CustomerCreateWithoutQuotationInput;
  where: CustomerWhereUniqueInput;
};

export type CustomerCreateOrConnectWithoutSalesInput = {
  create: CustomerCreateWithoutSalesInput;
  where: CustomerWhereUniqueInput;
};

export type CustomerCreateWithoutCustomerPreferenceProfileInput = {
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutConsumerInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  preferredStore?: InputMaybe<StoreCreateNestedOneWithoutCustomerInput>;
  sales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutCustomerInput>;
};

export type CustomerCreateWithoutPreferredStoreInput = {
  CustomerPreferenceProfile?: InputMaybe<CustomerPreferenceProfileCreateNestedManyWithoutCustomerInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutConsumerInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  sales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutCustomerInput>;
};

export type CustomerCreateWithoutQuotationInput = {
  CustomerPreferenceProfile?: InputMaybe<CustomerPreferenceProfileCreateNestedManyWithoutCustomerInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  preferredStore?: InputMaybe<StoreCreateNestedOneWithoutCustomerInput>;
  sales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutCustomerInput>;
};

export type CustomerCreateWithoutSalesInput = {
  CustomerPreferenceProfile?: InputMaybe<CustomerPreferenceProfileCreateNestedManyWithoutCustomerInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutConsumerInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  preferredStore?: InputMaybe<StoreCreateNestedOneWithoutCustomerInput>;
};

export type CustomerListRelationFilter = {
  every?: InputMaybe<CustomerWhereInput>;
  none?: InputMaybe<CustomerWhereInput>;
  some?: InputMaybe<CustomerWhereInput>;
};

export type CustomerNullableScalarRelationFilter = {
  is?: InputMaybe<CustomerWhereInput>;
  isNot?: InputMaybe<CustomerWhereInput>;
};

export type CustomerOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type CustomerOrderByWithRelationInput = {
  CustomerPreferenceProfile?: InputMaybe<CustomerPreferenceProfileOrderByRelationAggregateInput>;
  Quotation?: InputMaybe<QuotationOrderByRelationAggregateInput>;
  email?: InputMaybe<SortOrderInput>;
  fullName?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  phone?: InputMaybe<SortOrderInput>;
  preferredStore?: InputMaybe<StoreOrderByWithRelationInput>;
  preferredStoreId?: InputMaybe<SortOrderInput>;
  sales?: InputMaybe<ConsumerSaleOrderByRelationAggregateInput>;
};

export type CustomerPreferenceProfile = {
  __typename?: 'CustomerPreferenceProfile';
  CustomerProfile?: Maybe<Array<CustomerProfile>>;
  _count: CustomerPreferenceProfileCount;
  customer: Customer;
  customerId: Scalars['String']['output'];
  eligibleForDiscounts: Scalars['Boolean']['output'];
  frequentlyBoughtVariants: Scalars['JSON']['output'];
  id: Scalars['ID']['output'];
  lastPurchaseDate?: Maybe<Scalars['DateTime']['output']>;
};

export type CustomerPreferenceProfileCount = {
  __typename?: 'CustomerPreferenceProfileCount';
  CustomerProfile: Scalars['Int']['output'];
};

export type CustomerPreferenceProfileCreateManyCustomerInput = {
  eligibleForDiscounts?: InputMaybe<Scalars['Boolean']['input']>;
  frequentlyBoughtVariants: Scalars['JSON']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  lastPurchaseDate?: InputMaybe<Scalars['DateTime']['input']>;
};

export type CustomerPreferenceProfileCreateManyCustomerInputEnvelope = {
  data: Array<CustomerPreferenceProfileCreateManyCustomerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CustomerPreferenceProfileCreateNestedManyWithoutCustomerInput = {
  connect?: InputMaybe<Array<CustomerPreferenceProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerPreferenceProfileCreateOrConnectWithoutCustomerInput>>;
  create?: InputMaybe<Array<CustomerPreferenceProfileCreateWithoutCustomerInput>>;
  createMany?: InputMaybe<CustomerPreferenceProfileCreateManyCustomerInputEnvelope>;
};

export type CustomerPreferenceProfileCreateNestedOneWithoutCustomerProfileInput = {
  connect?: InputMaybe<CustomerPreferenceProfileWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerPreferenceProfileCreateOrConnectWithoutCustomerProfileInput>;
  create?: InputMaybe<CustomerPreferenceProfileCreateWithoutCustomerProfileInput>;
};

export type CustomerPreferenceProfileCreateOrConnectWithoutCustomerInput = {
  create: CustomerPreferenceProfileCreateWithoutCustomerInput;
  where: CustomerPreferenceProfileWhereUniqueInput;
};

export type CustomerPreferenceProfileCreateOrConnectWithoutCustomerProfileInput = {
  create: CustomerPreferenceProfileCreateWithoutCustomerProfileInput;
  where: CustomerPreferenceProfileWhereUniqueInput;
};

export type CustomerPreferenceProfileCreateWithoutCustomerInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferencesInput>;
  eligibleForDiscounts?: InputMaybe<Scalars['Boolean']['input']>;
  frequentlyBoughtVariants: Scalars['JSON']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  lastPurchaseDate?: InputMaybe<Scalars['DateTime']['input']>;
};

export type CustomerPreferenceProfileCreateWithoutCustomerProfileInput = {
  customer: CustomerCreateNestedOneWithoutCustomerPreferenceProfileInput;
  eligibleForDiscounts?: InputMaybe<Scalars['Boolean']['input']>;
  frequentlyBoughtVariants: Scalars['JSON']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  lastPurchaseDate?: InputMaybe<Scalars['DateTime']['input']>;
};

export type CustomerPreferenceProfileListRelationFilter = {
  every?: InputMaybe<CustomerPreferenceProfileWhereInput>;
  none?: InputMaybe<CustomerPreferenceProfileWhereInput>;
  some?: InputMaybe<CustomerPreferenceProfileWhereInput>;
};

export type CustomerPreferenceProfileNullableScalarRelationFilter = {
  is?: InputMaybe<CustomerPreferenceProfileWhereInput>;
  isNot?: InputMaybe<CustomerPreferenceProfileWhereInput>;
};

export type CustomerPreferenceProfileOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type CustomerPreferenceProfileOrderByWithRelationInput = {
  CustomerProfile?: InputMaybe<CustomerProfileOrderByRelationAggregateInput>;
  customer?: InputMaybe<CustomerOrderByWithRelationInput>;
  customerId?: InputMaybe<SortOrder>;
  eligibleForDiscounts?: InputMaybe<SortOrder>;
  frequentlyBoughtVariants?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  lastPurchaseDate?: InputMaybe<SortOrderInput>;
};

export type CustomerPreferenceProfileScalarWhereInput = {
  AND?: InputMaybe<Array<CustomerPreferenceProfileScalarWhereInput>>;
  NOT?: InputMaybe<Array<CustomerPreferenceProfileScalarWhereInput>>;
  OR?: InputMaybe<Array<CustomerPreferenceProfileScalarWhereInput>>;
  customerId?: InputMaybe<StringFilter>;
  eligibleForDiscounts?: InputMaybe<BoolFilter>;
  frequentlyBoughtVariants?: InputMaybe<JsonFilter>;
  id?: InputMaybe<StringFilter>;
  lastPurchaseDate?: InputMaybe<DateTimeNullableFilter>;
};

export type CustomerPreferenceProfileUpdateManyMutationInput = {
  eligibleForDiscounts?: InputMaybe<BoolFieldUpdateOperationsInput>;
  frequentlyBoughtVariants?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastPurchaseDate?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
};

export type CustomerPreferenceProfileUpdateManyWithWhereWithoutCustomerInput = {
  data: CustomerPreferenceProfileUpdateManyMutationInput;
  where: CustomerPreferenceProfileScalarWhereInput;
};

export type CustomerPreferenceProfileUpdateManyWithoutCustomerNestedInput = {
  connect?: InputMaybe<Array<CustomerPreferenceProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerPreferenceProfileCreateOrConnectWithoutCustomerInput>>;
  create?: InputMaybe<Array<CustomerPreferenceProfileCreateWithoutCustomerInput>>;
  createMany?: InputMaybe<CustomerPreferenceProfileCreateManyCustomerInputEnvelope>;
  delete?: InputMaybe<Array<CustomerPreferenceProfileWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<CustomerPreferenceProfileScalarWhereInput>>;
  disconnect?: InputMaybe<Array<CustomerPreferenceProfileWhereUniqueInput>>;
  set?: InputMaybe<Array<CustomerPreferenceProfileWhereUniqueInput>>;
  update?: InputMaybe<Array<CustomerPreferenceProfileUpdateWithWhereUniqueWithoutCustomerInput>>;
  updateMany?: InputMaybe<Array<CustomerPreferenceProfileUpdateManyWithWhereWithoutCustomerInput>>;
  upsert?: InputMaybe<Array<CustomerPreferenceProfileUpsertWithWhereUniqueWithoutCustomerInput>>;
};

export type CustomerPreferenceProfileUpdateOneWithoutCustomerProfileNestedInput = {
  connect?: InputMaybe<CustomerPreferenceProfileWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerPreferenceProfileCreateOrConnectWithoutCustomerProfileInput>;
  create?: InputMaybe<CustomerPreferenceProfileCreateWithoutCustomerProfileInput>;
  delete?: InputMaybe<CustomerPreferenceProfileWhereInput>;
  disconnect?: InputMaybe<CustomerPreferenceProfileWhereInput>;
  update?: InputMaybe<CustomerPreferenceProfileUpdateToOneWithWhereWithoutCustomerProfileInput>;
  upsert?: InputMaybe<CustomerPreferenceProfileUpsertWithoutCustomerProfileInput>;
};

export type CustomerPreferenceProfileUpdateToOneWithWhereWithoutCustomerProfileInput = {
  data: CustomerPreferenceProfileUpdateWithoutCustomerProfileInput;
  where?: InputMaybe<CustomerPreferenceProfileWhereInput>;
};

export type CustomerPreferenceProfileUpdateWithWhereUniqueWithoutCustomerInput = {
  data: CustomerPreferenceProfileUpdateWithoutCustomerInput;
  where: CustomerPreferenceProfileWhereUniqueInput;
};

export type CustomerPreferenceProfileUpdateWithoutCustomerInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferencesNestedInput>;
  eligibleForDiscounts?: InputMaybe<BoolFieldUpdateOperationsInput>;
  frequentlyBoughtVariants?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastPurchaseDate?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
};

export type CustomerPreferenceProfileUpdateWithoutCustomerProfileInput = {
  customer?: InputMaybe<CustomerUpdateOneRequiredWithoutCustomerPreferenceProfileNestedInput>;
  eligibleForDiscounts?: InputMaybe<BoolFieldUpdateOperationsInput>;
  frequentlyBoughtVariants?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastPurchaseDate?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
};

export type CustomerPreferenceProfileUpsertWithWhereUniqueWithoutCustomerInput = {
  create: CustomerPreferenceProfileCreateWithoutCustomerInput;
  update: CustomerPreferenceProfileUpdateWithoutCustomerInput;
  where: CustomerPreferenceProfileWhereUniqueInput;
};

export type CustomerPreferenceProfileUpsertWithoutCustomerProfileInput = {
  create: CustomerPreferenceProfileCreateWithoutCustomerProfileInput;
  update: CustomerPreferenceProfileUpdateWithoutCustomerProfileInput;
  where?: InputMaybe<CustomerPreferenceProfileWhereInput>;
};

export type CustomerPreferenceProfileWhereInput = {
  AND?: InputMaybe<Array<CustomerPreferenceProfileWhereInput>>;
  CustomerProfile?: InputMaybe<CustomerProfileListRelationFilter>;
  NOT?: InputMaybe<Array<CustomerPreferenceProfileWhereInput>>;
  OR?: InputMaybe<Array<CustomerPreferenceProfileWhereInput>>;
  customer?: InputMaybe<CustomerScalarRelationFilter>;
  customerId?: InputMaybe<StringFilter>;
  eligibleForDiscounts?: InputMaybe<BoolFilter>;
  frequentlyBoughtVariants?: InputMaybe<JsonFilter>;
  id?: InputMaybe<StringFilter>;
  lastPurchaseDate?: InputMaybe<DateTimeNullableFilter>;
};

export type CustomerPreferenceProfileWhereUniqueInput = {
  AND?: InputMaybe<Array<CustomerPreferenceProfileWhereInput>>;
  CustomerProfile?: InputMaybe<CustomerProfileListRelationFilter>;
  NOT?: InputMaybe<Array<CustomerPreferenceProfileWhereInput>>;
  OR?: InputMaybe<Array<CustomerPreferenceProfileWhereInput>>;
  customer?: InputMaybe<CustomerScalarRelationFilter>;
  customerId?: InputMaybe<Scalars['String']['input']>;
  eligibleForDiscounts?: InputMaybe<BoolFilter>;
  frequentlyBoughtVariants?: InputMaybe<JsonFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  lastPurchaseDate?: InputMaybe<DateTimeNullableFilter>;
};

export type CustomerProfile = {
  __typename?: 'CustomerProfile';
  _count: CustomerProfileCount;
  activatedAt?: Maybe<Scalars['DateTime']['output']>;
  birthday?: Maybe<Scalars['DateTime']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  fullName: Scalars['String']['output'];
  gender?: Maybe<Scalars['String']['output']>;
  isPhoneVerified: Scalars['Boolean']['output'];
  phone?: Maybe<Scalars['String']['output']>;
  phoneVerificationCode?: Maybe<Scalars['String']['output']>;
  phoneVerificationCodeExpiry?: Maybe<Scalars['DateTime']['output']>;
  preferences?: Maybe<CustomerPreferenceProfile>;
  preferencesid?: Maybe<Scalars['String']['output']>;
  preferredStore?: Maybe<Store>;
  preferredStoreId?: Maybe<Scalars['String']['output']>;
  profileStatus: ProfileStatus;
  referrals?: Maybe<Array<CustomerProfile>>;
  referredBy?: Maybe<CustomerProfile>;
  referredById?: Maybe<Scalars['String']['output']>;
  requestedAt: Scalars['DateTime']['output'];
  sales?: Maybe<Array<ConsumerSale>>;
  user: User;
  userId: Scalars['ID']['output'];
};

export type CustomerProfileCount = {
  __typename?: 'CustomerProfileCount';
  referrals: Scalars['Int']['output'];
  sales: Scalars['Int']['output'];
};

export type CustomerProfileCreateManyPreferencesInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  birthday?: InputMaybe<Scalars['DateTime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  gender?: InputMaybe<Scalars['String']['input']>;
  isPhoneVerified?: InputMaybe<Scalars['Boolean']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCode?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCodeExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  preferredStoreId?: InputMaybe<Scalars['String']['input']>;
  profileStatus?: InputMaybe<ProfileStatus>;
  referredById?: InputMaybe<Scalars['String']['input']>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  userId: Scalars['String']['input'];
};

export type CustomerProfileCreateManyPreferencesInputEnvelope = {
  data: Array<CustomerProfileCreateManyPreferencesInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CustomerProfileCreateManyPreferredStoreInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  birthday?: InputMaybe<Scalars['DateTime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  gender?: InputMaybe<Scalars['String']['input']>;
  isPhoneVerified?: InputMaybe<Scalars['Boolean']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCode?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCodeExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  preferencesid?: InputMaybe<Scalars['String']['input']>;
  profileStatus?: InputMaybe<ProfileStatus>;
  referredById?: InputMaybe<Scalars['String']['input']>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  userId: Scalars['String']['input'];
};

export type CustomerProfileCreateManyPreferredStoreInputEnvelope = {
  data: Array<CustomerProfileCreateManyPreferredStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CustomerProfileCreateManyReferredByInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  birthday?: InputMaybe<Scalars['DateTime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  gender?: InputMaybe<Scalars['String']['input']>;
  isPhoneVerified?: InputMaybe<Scalars['Boolean']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCode?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCodeExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  preferencesid?: InputMaybe<Scalars['String']['input']>;
  preferredStoreId?: InputMaybe<Scalars['String']['input']>;
  profileStatus?: InputMaybe<ProfileStatus>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  userId: Scalars['String']['input'];
};

export type CustomerProfileCreateManyReferredByInputEnvelope = {
  data: Array<CustomerProfileCreateManyReferredByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CustomerProfileCreateNestedManyWithoutPreferencesInput = {
  connect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerProfileCreateOrConnectWithoutPreferencesInput>>;
  create?: InputMaybe<Array<CustomerProfileCreateWithoutPreferencesInput>>;
  createMany?: InputMaybe<CustomerProfileCreateManyPreferencesInputEnvelope>;
};

export type CustomerProfileCreateNestedManyWithoutPreferredStoreInput = {
  connect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerProfileCreateOrConnectWithoutPreferredStoreInput>>;
  create?: InputMaybe<Array<CustomerProfileCreateWithoutPreferredStoreInput>>;
  createMany?: InputMaybe<CustomerProfileCreateManyPreferredStoreInputEnvelope>;
};

export type CustomerProfileCreateNestedManyWithoutReferredByInput = {
  connect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerProfileCreateOrConnectWithoutReferredByInput>>;
  create?: InputMaybe<Array<CustomerProfileCreateWithoutReferredByInput>>;
  createMany?: InputMaybe<CustomerProfileCreateManyReferredByInputEnvelope>;
};

export type CustomerProfileCreateNestedManyWithoutSalesInput = {
  connect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerProfileCreateOrConnectWithoutSalesInput>>;
  create?: InputMaybe<Array<CustomerProfileCreateWithoutSalesInput>>;
};

export type CustomerProfileCreateNestedOneWithoutReferralsInput = {
  connect?: InputMaybe<CustomerProfileWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerProfileCreateOrConnectWithoutReferralsInput>;
  create?: InputMaybe<CustomerProfileCreateWithoutReferralsInput>;
};

export type CustomerProfileCreateNestedOneWithoutUserInput = {
  connect?: InputMaybe<CustomerProfileWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerProfileCreateOrConnectWithoutUserInput>;
  create?: InputMaybe<CustomerProfileCreateWithoutUserInput>;
};

export type CustomerProfileCreateOrConnectWithoutPreferencesInput = {
  create: CustomerProfileCreateWithoutPreferencesInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileCreateOrConnectWithoutPreferredStoreInput = {
  create: CustomerProfileCreateWithoutPreferredStoreInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileCreateOrConnectWithoutReferralsInput = {
  create: CustomerProfileCreateWithoutReferralsInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileCreateOrConnectWithoutReferredByInput = {
  create: CustomerProfileCreateWithoutReferredByInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileCreateOrConnectWithoutSalesInput = {
  create: CustomerProfileCreateWithoutSalesInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileCreateOrConnectWithoutUserInput = {
  create: CustomerProfileCreateWithoutUserInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileCreateWithoutPreferencesInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  birthday?: InputMaybe<Scalars['DateTime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  gender?: InputMaybe<Scalars['String']['input']>;
  isPhoneVerified?: InputMaybe<Scalars['Boolean']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCode?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCodeExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  preferredStore?: InputMaybe<StoreCreateNestedOneWithoutCustomerProfileInput>;
  profileStatus?: InputMaybe<ProfileStatus>;
  referrals?: InputMaybe<CustomerProfileCreateNestedManyWithoutReferredByInput>;
  referredBy?: InputMaybe<CustomerProfileCreateNestedOneWithoutReferralsInput>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  sales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutCustomerProfileInput>;
  user: UserCreateNestedOneWithoutCustomerProfileInput;
};

export type CustomerProfileCreateWithoutPreferredStoreInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  birthday?: InputMaybe<Scalars['DateTime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  gender?: InputMaybe<Scalars['String']['input']>;
  isPhoneVerified?: InputMaybe<Scalars['Boolean']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCode?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCodeExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  preferences?: InputMaybe<CustomerPreferenceProfileCreateNestedOneWithoutCustomerProfileInput>;
  profileStatus?: InputMaybe<ProfileStatus>;
  referrals?: InputMaybe<CustomerProfileCreateNestedManyWithoutReferredByInput>;
  referredBy?: InputMaybe<CustomerProfileCreateNestedOneWithoutReferralsInput>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  sales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutCustomerProfileInput>;
  user: UserCreateNestedOneWithoutCustomerProfileInput;
};

export type CustomerProfileCreateWithoutReferralsInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  birthday?: InputMaybe<Scalars['DateTime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  gender?: InputMaybe<Scalars['String']['input']>;
  isPhoneVerified?: InputMaybe<Scalars['Boolean']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCode?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCodeExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  preferences?: InputMaybe<CustomerPreferenceProfileCreateNestedOneWithoutCustomerProfileInput>;
  preferredStore?: InputMaybe<StoreCreateNestedOneWithoutCustomerProfileInput>;
  profileStatus?: InputMaybe<ProfileStatus>;
  referredBy?: InputMaybe<CustomerProfileCreateNestedOneWithoutReferralsInput>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  sales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutCustomerProfileInput>;
  user: UserCreateNestedOneWithoutCustomerProfileInput;
};

export type CustomerProfileCreateWithoutReferredByInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  birthday?: InputMaybe<Scalars['DateTime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  gender?: InputMaybe<Scalars['String']['input']>;
  isPhoneVerified?: InputMaybe<Scalars['Boolean']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCode?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCodeExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  preferences?: InputMaybe<CustomerPreferenceProfileCreateNestedOneWithoutCustomerProfileInput>;
  preferredStore?: InputMaybe<StoreCreateNestedOneWithoutCustomerProfileInput>;
  profileStatus?: InputMaybe<ProfileStatus>;
  referrals?: InputMaybe<CustomerProfileCreateNestedManyWithoutReferredByInput>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  sales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutCustomerProfileInput>;
  user: UserCreateNestedOneWithoutCustomerProfileInput;
};

export type CustomerProfileCreateWithoutSalesInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  birthday?: InputMaybe<Scalars['DateTime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  gender?: InputMaybe<Scalars['String']['input']>;
  isPhoneVerified?: InputMaybe<Scalars['Boolean']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCode?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCodeExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  preferences?: InputMaybe<CustomerPreferenceProfileCreateNestedOneWithoutCustomerProfileInput>;
  preferredStore?: InputMaybe<StoreCreateNestedOneWithoutCustomerProfileInput>;
  profileStatus?: InputMaybe<ProfileStatus>;
  referrals?: InputMaybe<CustomerProfileCreateNestedManyWithoutReferredByInput>;
  referredBy?: InputMaybe<CustomerProfileCreateNestedOneWithoutReferralsInput>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  user: UserCreateNestedOneWithoutCustomerProfileInput;
};

export type CustomerProfileCreateWithoutUserInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  birthday?: InputMaybe<Scalars['DateTime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  gender?: InputMaybe<Scalars['String']['input']>;
  isPhoneVerified?: InputMaybe<Scalars['Boolean']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCode?: InputMaybe<Scalars['String']['input']>;
  phoneVerificationCodeExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  preferences?: InputMaybe<CustomerPreferenceProfileCreateNestedOneWithoutCustomerProfileInput>;
  preferredStore?: InputMaybe<StoreCreateNestedOneWithoutCustomerProfileInput>;
  profileStatus?: InputMaybe<ProfileStatus>;
  referrals?: InputMaybe<CustomerProfileCreateNestedManyWithoutReferredByInput>;
  referredBy?: InputMaybe<CustomerProfileCreateNestedOneWithoutReferralsInput>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  sales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutCustomerProfileInput>;
};

export type CustomerProfileListRelationFilter = {
  every?: InputMaybe<CustomerProfileWhereInput>;
  none?: InputMaybe<CustomerProfileWhereInput>;
  some?: InputMaybe<CustomerProfileWhereInput>;
};

export type CustomerProfileNullableScalarRelationFilter = {
  is?: InputMaybe<CustomerProfileWhereInput>;
  isNot?: InputMaybe<CustomerProfileWhereInput>;
};

export type CustomerProfileOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type CustomerProfileOrderByWithRelationInput = {
  activatedAt?: InputMaybe<SortOrderInput>;
  birthday?: InputMaybe<SortOrderInput>;
  email?: InputMaybe<SortOrderInput>;
  fullName?: InputMaybe<SortOrder>;
  gender?: InputMaybe<SortOrderInput>;
  isPhoneVerified?: InputMaybe<SortOrder>;
  phone?: InputMaybe<SortOrderInput>;
  phoneVerificationCode?: InputMaybe<SortOrderInput>;
  phoneVerificationCodeExpiry?: InputMaybe<SortOrderInput>;
  preferences?: InputMaybe<CustomerPreferenceProfileOrderByWithRelationInput>;
  preferencesid?: InputMaybe<SortOrderInput>;
  preferredStore?: InputMaybe<StoreOrderByWithRelationInput>;
  preferredStoreId?: InputMaybe<SortOrderInput>;
  profileStatus?: InputMaybe<SortOrder>;
  referrals?: InputMaybe<CustomerProfileOrderByRelationAggregateInput>;
  referredBy?: InputMaybe<CustomerProfileOrderByWithRelationInput>;
  referredById?: InputMaybe<SortOrderInput>;
  requestedAt?: InputMaybe<SortOrder>;
  sales?: InputMaybe<ConsumerSaleOrderByRelationAggregateInput>;
  user?: InputMaybe<UserOrderByWithRelationInput>;
  userId?: InputMaybe<SortOrder>;
};

export type CustomerProfileScalarWhereInput = {
  AND?: InputMaybe<Array<CustomerProfileScalarWhereInput>>;
  NOT?: InputMaybe<Array<CustomerProfileScalarWhereInput>>;
  OR?: InputMaybe<Array<CustomerProfileScalarWhereInput>>;
  activatedAt?: InputMaybe<DateTimeNullableFilter>;
  birthday?: InputMaybe<DateTimeNullableFilter>;
  email?: InputMaybe<StringNullableFilter>;
  fullName?: InputMaybe<StringFilter>;
  gender?: InputMaybe<StringNullableFilter>;
  isPhoneVerified?: InputMaybe<BoolFilter>;
  phone?: InputMaybe<StringNullableFilter>;
  phoneVerificationCode?: InputMaybe<StringNullableFilter>;
  phoneVerificationCodeExpiry?: InputMaybe<DateTimeNullableFilter>;
  preferencesid?: InputMaybe<StringNullableFilter>;
  preferredStoreId?: InputMaybe<StringNullableFilter>;
  profileStatus?: InputMaybe<EnumProfileStatusFilter>;
  referredById?: InputMaybe<StringNullableFilter>;
  requestedAt?: InputMaybe<DateTimeFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type CustomerProfileUpdateManyMutationInput = {
  activatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  birthday?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  gender?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  isPhoneVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCodeExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  profileStatus?: InputMaybe<EnumProfileStatusFieldUpdateOperationsInput>;
  requestedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type CustomerProfileUpdateManyWithWhereWithoutPreferencesInput = {
  data: CustomerProfileUpdateManyMutationInput;
  where: CustomerProfileScalarWhereInput;
};

export type CustomerProfileUpdateManyWithWhereWithoutPreferredStoreInput = {
  data: CustomerProfileUpdateManyMutationInput;
  where: CustomerProfileScalarWhereInput;
};

export type CustomerProfileUpdateManyWithWhereWithoutReferredByInput = {
  data: CustomerProfileUpdateManyMutationInput;
  where: CustomerProfileScalarWhereInput;
};

export type CustomerProfileUpdateManyWithWhereWithoutSalesInput = {
  data: CustomerProfileUpdateManyMutationInput;
  where: CustomerProfileScalarWhereInput;
};

export type CustomerProfileUpdateManyWithoutPreferencesNestedInput = {
  connect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerProfileCreateOrConnectWithoutPreferencesInput>>;
  create?: InputMaybe<Array<CustomerProfileCreateWithoutPreferencesInput>>;
  createMany?: InputMaybe<CustomerProfileCreateManyPreferencesInputEnvelope>;
  delete?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<CustomerProfileScalarWhereInput>>;
  disconnect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  set?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  update?: InputMaybe<Array<CustomerProfileUpdateWithWhereUniqueWithoutPreferencesInput>>;
  updateMany?: InputMaybe<Array<CustomerProfileUpdateManyWithWhereWithoutPreferencesInput>>;
  upsert?: InputMaybe<Array<CustomerProfileUpsertWithWhereUniqueWithoutPreferencesInput>>;
};

export type CustomerProfileUpdateManyWithoutPreferredStoreNestedInput = {
  connect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerProfileCreateOrConnectWithoutPreferredStoreInput>>;
  create?: InputMaybe<Array<CustomerProfileCreateWithoutPreferredStoreInput>>;
  createMany?: InputMaybe<CustomerProfileCreateManyPreferredStoreInputEnvelope>;
  delete?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<CustomerProfileScalarWhereInput>>;
  disconnect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  set?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  update?: InputMaybe<Array<CustomerProfileUpdateWithWhereUniqueWithoutPreferredStoreInput>>;
  updateMany?: InputMaybe<Array<CustomerProfileUpdateManyWithWhereWithoutPreferredStoreInput>>;
  upsert?: InputMaybe<Array<CustomerProfileUpsertWithWhereUniqueWithoutPreferredStoreInput>>;
};

export type CustomerProfileUpdateManyWithoutReferredByNestedInput = {
  connect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerProfileCreateOrConnectWithoutReferredByInput>>;
  create?: InputMaybe<Array<CustomerProfileCreateWithoutReferredByInput>>;
  createMany?: InputMaybe<CustomerProfileCreateManyReferredByInputEnvelope>;
  delete?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<CustomerProfileScalarWhereInput>>;
  disconnect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  set?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  update?: InputMaybe<Array<CustomerProfileUpdateWithWhereUniqueWithoutReferredByInput>>;
  updateMany?: InputMaybe<Array<CustomerProfileUpdateManyWithWhereWithoutReferredByInput>>;
  upsert?: InputMaybe<Array<CustomerProfileUpsertWithWhereUniqueWithoutReferredByInput>>;
};

export type CustomerProfileUpdateManyWithoutSalesNestedInput = {
  connect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerProfileCreateOrConnectWithoutSalesInput>>;
  create?: InputMaybe<Array<CustomerProfileCreateWithoutSalesInput>>;
  delete?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<CustomerProfileScalarWhereInput>>;
  disconnect?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  set?: InputMaybe<Array<CustomerProfileWhereUniqueInput>>;
  update?: InputMaybe<Array<CustomerProfileUpdateWithWhereUniqueWithoutSalesInput>>;
  updateMany?: InputMaybe<Array<CustomerProfileUpdateManyWithWhereWithoutSalesInput>>;
  upsert?: InputMaybe<Array<CustomerProfileUpsertWithWhereUniqueWithoutSalesInput>>;
};

export type CustomerProfileUpdateOneWithoutReferralsNestedInput = {
  connect?: InputMaybe<CustomerProfileWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerProfileCreateOrConnectWithoutReferralsInput>;
  create?: InputMaybe<CustomerProfileCreateWithoutReferralsInput>;
  delete?: InputMaybe<CustomerProfileWhereInput>;
  disconnect?: InputMaybe<CustomerProfileWhereInput>;
  update?: InputMaybe<CustomerProfileUpdateToOneWithWhereWithoutReferralsInput>;
  upsert?: InputMaybe<CustomerProfileUpsertWithoutReferralsInput>;
};

export type CustomerProfileUpdateOneWithoutUserNestedInput = {
  connect?: InputMaybe<CustomerProfileWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerProfileCreateOrConnectWithoutUserInput>;
  create?: InputMaybe<CustomerProfileCreateWithoutUserInput>;
  delete?: InputMaybe<CustomerProfileWhereInput>;
  disconnect?: InputMaybe<CustomerProfileWhereInput>;
  update?: InputMaybe<CustomerProfileUpdateToOneWithWhereWithoutUserInput>;
  upsert?: InputMaybe<CustomerProfileUpsertWithoutUserInput>;
};

export type CustomerProfileUpdateToOneWithWhereWithoutReferralsInput = {
  data: CustomerProfileUpdateWithoutReferralsInput;
  where?: InputMaybe<CustomerProfileWhereInput>;
};

export type CustomerProfileUpdateToOneWithWhereWithoutUserInput = {
  data: CustomerProfileUpdateWithoutUserInput;
  where?: InputMaybe<CustomerProfileWhereInput>;
};

export type CustomerProfileUpdateWithWhereUniqueWithoutPreferencesInput = {
  data: CustomerProfileUpdateWithoutPreferencesInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileUpdateWithWhereUniqueWithoutPreferredStoreInput = {
  data: CustomerProfileUpdateWithoutPreferredStoreInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileUpdateWithWhereUniqueWithoutReferredByInput = {
  data: CustomerProfileUpdateWithoutReferredByInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileUpdateWithWhereUniqueWithoutSalesInput = {
  data: CustomerProfileUpdateWithoutSalesInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileUpdateWithoutPreferencesInput = {
  activatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  birthday?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  gender?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  isPhoneVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCodeExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  preferredStore?: InputMaybe<StoreUpdateOneWithoutCustomerProfileNestedInput>;
  profileStatus?: InputMaybe<EnumProfileStatusFieldUpdateOperationsInput>;
  referrals?: InputMaybe<CustomerProfileUpdateManyWithoutReferredByNestedInput>;
  referredBy?: InputMaybe<CustomerProfileUpdateOneWithoutReferralsNestedInput>;
  requestedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  sales?: InputMaybe<ConsumerSaleUpdateManyWithoutCustomerProfileNestedInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutCustomerProfileNestedInput>;
};

export type CustomerProfileUpdateWithoutPreferredStoreInput = {
  activatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  birthday?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  gender?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  isPhoneVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCodeExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  preferences?: InputMaybe<CustomerPreferenceProfileUpdateOneWithoutCustomerProfileNestedInput>;
  profileStatus?: InputMaybe<EnumProfileStatusFieldUpdateOperationsInput>;
  referrals?: InputMaybe<CustomerProfileUpdateManyWithoutReferredByNestedInput>;
  referredBy?: InputMaybe<CustomerProfileUpdateOneWithoutReferralsNestedInput>;
  requestedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  sales?: InputMaybe<ConsumerSaleUpdateManyWithoutCustomerProfileNestedInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutCustomerProfileNestedInput>;
};

export type CustomerProfileUpdateWithoutReferralsInput = {
  activatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  birthday?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  gender?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  isPhoneVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCodeExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  preferences?: InputMaybe<CustomerPreferenceProfileUpdateOneWithoutCustomerProfileNestedInput>;
  preferredStore?: InputMaybe<StoreUpdateOneWithoutCustomerProfileNestedInput>;
  profileStatus?: InputMaybe<EnumProfileStatusFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<CustomerProfileUpdateOneWithoutReferralsNestedInput>;
  requestedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  sales?: InputMaybe<ConsumerSaleUpdateManyWithoutCustomerProfileNestedInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutCustomerProfileNestedInput>;
};

export type CustomerProfileUpdateWithoutReferredByInput = {
  activatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  birthday?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  gender?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  isPhoneVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCodeExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  preferences?: InputMaybe<CustomerPreferenceProfileUpdateOneWithoutCustomerProfileNestedInput>;
  preferredStore?: InputMaybe<StoreUpdateOneWithoutCustomerProfileNestedInput>;
  profileStatus?: InputMaybe<EnumProfileStatusFieldUpdateOperationsInput>;
  referrals?: InputMaybe<CustomerProfileUpdateManyWithoutReferredByNestedInput>;
  requestedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  sales?: InputMaybe<ConsumerSaleUpdateManyWithoutCustomerProfileNestedInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutCustomerProfileNestedInput>;
};

export type CustomerProfileUpdateWithoutSalesInput = {
  activatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  birthday?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  gender?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  isPhoneVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCodeExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  preferences?: InputMaybe<CustomerPreferenceProfileUpdateOneWithoutCustomerProfileNestedInput>;
  preferredStore?: InputMaybe<StoreUpdateOneWithoutCustomerProfileNestedInput>;
  profileStatus?: InputMaybe<EnumProfileStatusFieldUpdateOperationsInput>;
  referrals?: InputMaybe<CustomerProfileUpdateManyWithoutReferredByNestedInput>;
  referredBy?: InputMaybe<CustomerProfileUpdateOneWithoutReferralsNestedInput>;
  requestedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutCustomerProfileNestedInput>;
};

export type CustomerProfileUpdateWithoutUserInput = {
  activatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  birthday?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  gender?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  isPhoneVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  phoneVerificationCodeExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  preferences?: InputMaybe<CustomerPreferenceProfileUpdateOneWithoutCustomerProfileNestedInput>;
  preferredStore?: InputMaybe<StoreUpdateOneWithoutCustomerProfileNestedInput>;
  profileStatus?: InputMaybe<EnumProfileStatusFieldUpdateOperationsInput>;
  referrals?: InputMaybe<CustomerProfileUpdateManyWithoutReferredByNestedInput>;
  referredBy?: InputMaybe<CustomerProfileUpdateOneWithoutReferralsNestedInput>;
  requestedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  sales?: InputMaybe<ConsumerSaleUpdateManyWithoutCustomerProfileNestedInput>;
};

export type CustomerProfileUpsertWithWhereUniqueWithoutPreferencesInput = {
  create: CustomerProfileCreateWithoutPreferencesInput;
  update: CustomerProfileUpdateWithoutPreferencesInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileUpsertWithWhereUniqueWithoutPreferredStoreInput = {
  create: CustomerProfileCreateWithoutPreferredStoreInput;
  update: CustomerProfileUpdateWithoutPreferredStoreInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileUpsertWithWhereUniqueWithoutReferredByInput = {
  create: CustomerProfileCreateWithoutReferredByInput;
  update: CustomerProfileUpdateWithoutReferredByInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileUpsertWithWhereUniqueWithoutSalesInput = {
  create: CustomerProfileCreateWithoutSalesInput;
  update: CustomerProfileUpdateWithoutSalesInput;
  where: CustomerProfileWhereUniqueInput;
};

export type CustomerProfileUpsertWithoutReferralsInput = {
  create: CustomerProfileCreateWithoutReferralsInput;
  update: CustomerProfileUpdateWithoutReferralsInput;
  where?: InputMaybe<CustomerProfileWhereInput>;
};

export type CustomerProfileUpsertWithoutUserInput = {
  create: CustomerProfileCreateWithoutUserInput;
  update: CustomerProfileUpdateWithoutUserInput;
  where?: InputMaybe<CustomerProfileWhereInput>;
};

export type CustomerProfileWhereInput = {
  AND?: InputMaybe<Array<CustomerProfileWhereInput>>;
  NOT?: InputMaybe<Array<CustomerProfileWhereInput>>;
  OR?: InputMaybe<Array<CustomerProfileWhereInput>>;
  activatedAt?: InputMaybe<DateTimeNullableFilter>;
  birthday?: InputMaybe<DateTimeNullableFilter>;
  email?: InputMaybe<StringNullableFilter>;
  fullName?: InputMaybe<StringFilter>;
  gender?: InputMaybe<StringNullableFilter>;
  isPhoneVerified?: InputMaybe<BoolFilter>;
  phone?: InputMaybe<StringNullableFilter>;
  phoneVerificationCode?: InputMaybe<StringNullableFilter>;
  phoneVerificationCodeExpiry?: InputMaybe<DateTimeNullableFilter>;
  preferences?: InputMaybe<CustomerPreferenceProfileNullableScalarRelationFilter>;
  preferencesid?: InputMaybe<StringNullableFilter>;
  preferredStore?: InputMaybe<StoreNullableScalarRelationFilter>;
  preferredStoreId?: InputMaybe<StringNullableFilter>;
  profileStatus?: InputMaybe<EnumProfileStatusFilter>;
  referrals?: InputMaybe<CustomerProfileListRelationFilter>;
  referredBy?: InputMaybe<CustomerProfileNullableScalarRelationFilter>;
  referredById?: InputMaybe<StringNullableFilter>;
  requestedAt?: InputMaybe<DateTimeFilter>;
  sales?: InputMaybe<ConsumerSaleListRelationFilter>;
  user?: InputMaybe<UserScalarRelationFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type CustomerProfileWhereUniqueInput = {
  AND?: InputMaybe<Array<CustomerProfileWhereInput>>;
  NOT?: InputMaybe<Array<CustomerProfileWhereInput>>;
  OR?: InputMaybe<Array<CustomerProfileWhereInput>>;
  activatedAt?: InputMaybe<DateTimeNullableFilter>;
  birthday?: InputMaybe<DateTimeNullableFilter>;
  email?: InputMaybe<StringNullableFilter>;
  fullName?: InputMaybe<StringFilter>;
  gender?: InputMaybe<StringNullableFilter>;
  isPhoneVerified?: InputMaybe<BoolFilter>;
  phone?: InputMaybe<StringNullableFilter>;
  phoneVerificationCode?: InputMaybe<StringNullableFilter>;
  phoneVerificationCodeExpiry?: InputMaybe<DateTimeNullableFilter>;
  preferences?: InputMaybe<CustomerPreferenceProfileNullableScalarRelationFilter>;
  preferencesid?: InputMaybe<StringNullableFilter>;
  preferredStore?: InputMaybe<StoreNullableScalarRelationFilter>;
  preferredStoreId?: InputMaybe<StringNullableFilter>;
  profileStatus?: InputMaybe<EnumProfileStatusFilter>;
  referrals?: InputMaybe<CustomerProfileListRelationFilter>;
  referredBy?: InputMaybe<CustomerProfileNullableScalarRelationFilter>;
  referredById?: InputMaybe<StringNullableFilter>;
  requestedAt?: InputMaybe<DateTimeFilter>;
  sales?: InputMaybe<ConsumerSaleListRelationFilter>;
  user?: InputMaybe<UserScalarRelationFilter>;
  userId?: InputMaybe<Scalars['String']['input']>;
};

export type CustomerScalarRelationFilter = {
  is?: InputMaybe<CustomerWhereInput>;
  isNot?: InputMaybe<CustomerWhereInput>;
};

export type CustomerScalarWhereInput = {
  AND?: InputMaybe<Array<CustomerScalarWhereInput>>;
  NOT?: InputMaybe<Array<CustomerScalarWhereInput>>;
  OR?: InputMaybe<Array<CustomerScalarWhereInput>>;
  email?: InputMaybe<StringNullableFilter>;
  fullName?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  phone?: InputMaybe<StringNullableFilter>;
  preferredStoreId?: InputMaybe<StringNullableFilter>;
};

export type CustomerUpdateManyMutationInput = {
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type CustomerUpdateManyWithWhereWithoutPreferredStoreInput = {
  data: CustomerUpdateManyMutationInput;
  where: CustomerScalarWhereInput;
};

export type CustomerUpdateManyWithoutPreferredStoreNestedInput = {
  connect?: InputMaybe<Array<CustomerWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<CustomerCreateOrConnectWithoutPreferredStoreInput>>;
  create?: InputMaybe<Array<CustomerCreateWithoutPreferredStoreInput>>;
  createMany?: InputMaybe<CustomerCreateManyPreferredStoreInputEnvelope>;
  delete?: InputMaybe<Array<CustomerWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<CustomerScalarWhereInput>>;
  disconnect?: InputMaybe<Array<CustomerWhereUniqueInput>>;
  set?: InputMaybe<Array<CustomerWhereUniqueInput>>;
  update?: InputMaybe<Array<CustomerUpdateWithWhereUniqueWithoutPreferredStoreInput>>;
  updateMany?: InputMaybe<Array<CustomerUpdateManyWithWhereWithoutPreferredStoreInput>>;
  upsert?: InputMaybe<Array<CustomerUpsertWithWhereUniqueWithoutPreferredStoreInput>>;
};

export type CustomerUpdateOneRequiredWithoutCustomerPreferenceProfileNestedInput = {
  connect?: InputMaybe<CustomerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerCreateOrConnectWithoutCustomerPreferenceProfileInput>;
  create?: InputMaybe<CustomerCreateWithoutCustomerPreferenceProfileInput>;
  update?: InputMaybe<CustomerUpdateToOneWithWhereWithoutCustomerPreferenceProfileInput>;
  upsert?: InputMaybe<CustomerUpsertWithoutCustomerPreferenceProfileInput>;
};

export type CustomerUpdateOneWithoutQuotationNestedInput = {
  connect?: InputMaybe<CustomerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerCreateOrConnectWithoutQuotationInput>;
  create?: InputMaybe<CustomerCreateWithoutQuotationInput>;
  delete?: InputMaybe<CustomerWhereInput>;
  disconnect?: InputMaybe<CustomerWhereInput>;
  update?: InputMaybe<CustomerUpdateToOneWithWhereWithoutQuotationInput>;
  upsert?: InputMaybe<CustomerUpsertWithoutQuotationInput>;
};

export type CustomerUpdateOneWithoutSalesNestedInput = {
  connect?: InputMaybe<CustomerWhereUniqueInput>;
  connectOrCreate?: InputMaybe<CustomerCreateOrConnectWithoutSalesInput>;
  create?: InputMaybe<CustomerCreateWithoutSalesInput>;
  delete?: InputMaybe<CustomerWhereInput>;
  disconnect?: InputMaybe<CustomerWhereInput>;
  update?: InputMaybe<CustomerUpdateToOneWithWhereWithoutSalesInput>;
  upsert?: InputMaybe<CustomerUpsertWithoutSalesInput>;
};

export type CustomerUpdateToOneWithWhereWithoutCustomerPreferenceProfileInput = {
  data: CustomerUpdateWithoutCustomerPreferenceProfileInput;
  where?: InputMaybe<CustomerWhereInput>;
};

export type CustomerUpdateToOneWithWhereWithoutQuotationInput = {
  data: CustomerUpdateWithoutQuotationInput;
  where?: InputMaybe<CustomerWhereInput>;
};

export type CustomerUpdateToOneWithWhereWithoutSalesInput = {
  data: CustomerUpdateWithoutSalesInput;
  where?: InputMaybe<CustomerWhereInput>;
};

export type CustomerUpdateWithWhereUniqueWithoutPreferredStoreInput = {
  data: CustomerUpdateWithoutPreferredStoreInput;
  where: CustomerWhereUniqueInput;
};

export type CustomerUpdateWithoutCustomerPreferenceProfileInput = {
  Quotation?: InputMaybe<QuotationUpdateManyWithoutConsumerNestedInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  preferredStore?: InputMaybe<StoreUpdateOneWithoutCustomerNestedInput>;
  sales?: InputMaybe<ConsumerSaleUpdateManyWithoutCustomerNestedInput>;
};

export type CustomerUpdateWithoutPreferredStoreInput = {
  CustomerPreferenceProfile?: InputMaybe<CustomerPreferenceProfileUpdateManyWithoutCustomerNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutConsumerNestedInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  sales?: InputMaybe<ConsumerSaleUpdateManyWithoutCustomerNestedInput>;
};

export type CustomerUpdateWithoutQuotationInput = {
  CustomerPreferenceProfile?: InputMaybe<CustomerPreferenceProfileUpdateManyWithoutCustomerNestedInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  preferredStore?: InputMaybe<StoreUpdateOneWithoutCustomerNestedInput>;
  sales?: InputMaybe<ConsumerSaleUpdateManyWithoutCustomerNestedInput>;
};

export type CustomerUpdateWithoutSalesInput = {
  CustomerPreferenceProfile?: InputMaybe<CustomerPreferenceProfileUpdateManyWithoutCustomerNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutConsumerNestedInput>;
  email?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  fullName?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  phone?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  preferredStore?: InputMaybe<StoreUpdateOneWithoutCustomerNestedInput>;
};

export type CustomerUpsertWithWhereUniqueWithoutPreferredStoreInput = {
  create: CustomerCreateWithoutPreferredStoreInput;
  update: CustomerUpdateWithoutPreferredStoreInput;
  where: CustomerWhereUniqueInput;
};

export type CustomerUpsertWithoutCustomerPreferenceProfileInput = {
  create: CustomerCreateWithoutCustomerPreferenceProfileInput;
  update: CustomerUpdateWithoutCustomerPreferenceProfileInput;
  where?: InputMaybe<CustomerWhereInput>;
};

export type CustomerUpsertWithoutQuotationInput = {
  create: CustomerCreateWithoutQuotationInput;
  update: CustomerUpdateWithoutQuotationInput;
  where?: InputMaybe<CustomerWhereInput>;
};

export type CustomerUpsertWithoutSalesInput = {
  create: CustomerCreateWithoutSalesInput;
  update: CustomerUpdateWithoutSalesInput;
  where?: InputMaybe<CustomerWhereInput>;
};

export type CustomerWhereInput = {
  AND?: InputMaybe<Array<CustomerWhereInput>>;
  CustomerPreferenceProfile?: InputMaybe<CustomerPreferenceProfileListRelationFilter>;
  NOT?: InputMaybe<Array<CustomerWhereInput>>;
  OR?: InputMaybe<Array<CustomerWhereInput>>;
  Quotation?: InputMaybe<QuotationListRelationFilter>;
  email?: InputMaybe<StringNullableFilter>;
  fullName?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  phone?: InputMaybe<StringNullableFilter>;
  preferredStore?: InputMaybe<StoreNullableScalarRelationFilter>;
  preferredStoreId?: InputMaybe<StringNullableFilter>;
  sales?: InputMaybe<ConsumerSaleListRelationFilter>;
};

export type CustomerWhereUniqueInput = {
  AND?: InputMaybe<Array<CustomerWhereInput>>;
  CustomerPreferenceProfile?: InputMaybe<CustomerPreferenceProfileListRelationFilter>;
  NOT?: InputMaybe<Array<CustomerWhereInput>>;
  OR?: InputMaybe<Array<CustomerWhereInput>>;
  Quotation?: InputMaybe<QuotationListRelationFilter>;
  email?: InputMaybe<StringNullableFilter>;
  fullName?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<StringNullableFilter>;
  preferredStore?: InputMaybe<StoreNullableScalarRelationFilter>;
  preferredStoreId?: InputMaybe<StringNullableFilter>;
  sales?: InputMaybe<ConsumerSaleListRelationFilter>;
};

export type DateTimeFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['DateTime']['input']>;
};

export type DateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type DateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type DateTimeNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDateTimeNullableFilter>;
  _min?: InputMaybe<NestedDateTimeNullableFilter>;
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type DateTimeWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDateTimeFilter>;
  _min?: InputMaybe<NestedDateTimeFilter>;
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type DevCounts = {
  __typename?: 'DevCounts';
  invoiceImports: Scalars['Int']['output'];
  orphanVariants: Scalars['Int']['output'];
  purchaseOrders: Scalars['Int']['output'];
};

export type DevPurgeFilter = {
  beforeDate?: InputMaybe<Scalars['String']['input']>;
  dryRun?: InputMaybe<Scalars['Boolean']['input']>;
  orphanOnly?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  storeId?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['String']['input']>;
};

export type EnumAdjustmentTypeNullableFilter = {
  equals?: InputMaybe<AdjustmentType>;
  in?: InputMaybe<Array<AdjustmentType>>;
  not?: InputMaybe<NestedEnumAdjustmentTypeNullableFilter>;
  notIn?: InputMaybe<Array<AdjustmentType>>;
};

export type EnumAssetEntityTypeFilter = {
  equals?: InputMaybe<AssetEntityType>;
  in?: InputMaybe<Array<AssetEntityType>>;
  not?: InputMaybe<NestedEnumAssetEntityTypeFilter>;
  notIn?: InputMaybe<Array<AssetEntityType>>;
};

export type EnumAssetKindFilter = {
  equals?: InputMaybe<AssetKind>;
  in?: InputMaybe<Array<AssetKind>>;
  not?: InputMaybe<NestedEnumAssetKindFilter>;
  notIn?: InputMaybe<Array<AssetKind>>;
};

export type EnumAssetKindWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedEnumAssetKindFilter>;
  _min?: InputMaybe<NestedEnumAssetKindFilter>;
  equals?: InputMaybe<AssetKind>;
  in?: InputMaybe<Array<AssetKind>>;
  not?: InputMaybe<NestedEnumAssetKindWithAggregatesFilter>;
  notIn?: InputMaybe<Array<AssetKind>>;
};

export type EnumFulfillmentStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<FulfillmentStatus>;
};

export type EnumFulfillmentStatusFilter = {
  equals?: InputMaybe<FulfillmentStatus>;
  in?: InputMaybe<Array<FulfillmentStatus>>;
  not?: InputMaybe<NestedEnumFulfillmentStatusFilter>;
  notIn?: InputMaybe<Array<FulfillmentStatus>>;
};

export type EnumFulfillmentTypeFieldUpdateOperationsInput = {
  set?: InputMaybe<FulfillmentType>;
};

export type EnumFulfillmentTypeFilter = {
  equals?: InputMaybe<FulfillmentType>;
  in?: InputMaybe<Array<FulfillmentType>>;
  not?: InputMaybe<NestedEnumFulfillmentTypeFilter>;
  notIn?: InputMaybe<Array<FulfillmentType>>;
};

export type EnumInvoiceImportStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<InvoiceImportStatus>;
};

export type EnumInvoiceImportStatusFilter = {
  equals?: InputMaybe<InvoiceImportStatus>;
  in?: InputMaybe<Array<InvoiceImportStatus>>;
  not?: InputMaybe<NestedEnumInvoiceImportStatusFilter>;
  notIn?: InputMaybe<Array<InvoiceImportStatus>>;
};

export type EnumMovementDirectionFieldUpdateOperationsInput = {
  set?: InputMaybe<MovementDirection>;
};

export type EnumMovementDirectionFilter = {
  equals?: InputMaybe<MovementDirection>;
  in?: InputMaybe<Array<MovementDirection>>;
  not?: InputMaybe<NestedEnumMovementDirectionFilter>;
  notIn?: InputMaybe<Array<MovementDirection>>;
};

export type EnumMovementTypeFieldUpdateOperationsInput = {
  set?: InputMaybe<MovementType>;
};

export type EnumMovementTypeFilter = {
  equals?: InputMaybe<MovementType>;
  in?: InputMaybe<Array<MovementType>>;
  not?: InputMaybe<NestedEnumMovementTypeFilter>;
  notIn?: InputMaybe<Array<MovementType>>;
};

export type EnumOrderPhaseFieldUpdateOperationsInput = {
  set?: InputMaybe<OrderPhase>;
};

export type EnumOrderPhaseFilter = {
  equals?: InputMaybe<OrderPhase>;
  in?: InputMaybe<Array<OrderPhase>>;
  not?: InputMaybe<NestedEnumOrderPhaseFilter>;
  notIn?: InputMaybe<Array<OrderPhase>>;
};

export type EnumPaymentMethodFieldUpdateOperationsInput = {
  set?: InputMaybe<PaymentMethod>;
};

export type EnumPaymentMethodFilter = {
  equals?: InputMaybe<PaymentMethod>;
  in?: InputMaybe<Array<PaymentMethod>>;
  not?: InputMaybe<NestedEnumPaymentMethodFilter>;
  notIn?: InputMaybe<Array<PaymentMethod>>;
};

export type EnumPaymentStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<PaymentStatus>;
};

export type EnumPaymentStatusFilter = {
  equals?: InputMaybe<PaymentStatus>;
  in?: InputMaybe<Array<PaymentStatus>>;
  not?: InputMaybe<NestedEnumPaymentStatusFilter>;
  notIn?: InputMaybe<Array<PaymentStatus>>;
};

export type EnumPaymentTypeFieldUpdateOperationsInput = {
  set?: InputMaybe<PaymentType>;
};

export type EnumPaymentTypeFilter = {
  equals?: InputMaybe<PaymentType>;
  in?: InputMaybe<Array<PaymentType>>;
  not?: InputMaybe<NestedEnumPaymentTypeFilter>;
  notIn?: InputMaybe<Array<PaymentType>>;
};

export type EnumProfileStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<ProfileStatus>;
};

export type EnumProfileStatusFilter = {
  equals?: InputMaybe<ProfileStatus>;
  in?: InputMaybe<Array<ProfileStatus>>;
  not?: InputMaybe<NestedEnumProfileStatusFilter>;
  notIn?: InputMaybe<Array<ProfileStatus>>;
};

export type EnumPurchaseOrderStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<PurchaseOrderStatus>;
};

export type EnumPurchaseOrderStatusFilter = {
  equals?: InputMaybe<PurchaseOrderStatus>;
  in?: InputMaybe<Array<PurchaseOrderStatus>>;
  not?: InputMaybe<NestedEnumPurchaseOrderStatusFilter>;
  notIn?: InputMaybe<Array<PurchaseOrderStatus>>;
};

export type EnumPurchasePhaseFieldUpdateOperationsInput = {
  set?: InputMaybe<PurchasePhase>;
};

export type EnumPurchasePhaseFilter = {
  equals?: InputMaybe<PurchasePhase>;
  in?: InputMaybe<Array<PurchasePhase>>;
  not?: InputMaybe<NestedEnumPurchasePhaseFilter>;
  notIn?: InputMaybe<Array<PurchasePhase>>;
};

export type EnumPurchaseRequisitionStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<PurchaseRequisitionStatus>;
};

export type EnumPurchaseRequisitionStatusFilter = {
  equals?: InputMaybe<PurchaseRequisitionStatus>;
  in?: InputMaybe<Array<PurchaseRequisitionStatus>>;
  not?: InputMaybe<NestedEnumPurchaseRequisitionStatusFilter>;
  notIn?: InputMaybe<Array<PurchaseRequisitionStatus>>;
};

export type EnumQuotationStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<QuotationStatus>;
};

export type EnumQuotationStatusFilter = {
  equals?: InputMaybe<QuotationStatus>;
  in?: InputMaybe<Array<QuotationStatus>>;
  not?: InputMaybe<NestedEnumQuotationStatusFilter>;
  notIn?: InputMaybe<Array<QuotationStatus>>;
};

export type EnumReturnLocationFieldUpdateOperationsInput = {
  set?: InputMaybe<ReturnLocation>;
};

export type EnumReturnLocationFilter = {
  equals?: InputMaybe<ReturnLocation>;
  in?: InputMaybe<Array<ReturnLocation>>;
  not?: InputMaybe<NestedEnumReturnLocationFilter>;
  notIn?: InputMaybe<Array<ReturnLocation>>;
};

export type EnumReturnStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<ReturnStatus>;
};

export type EnumReturnStatusFilter = {
  equals?: InputMaybe<ReturnStatus>;
  in?: InputMaybe<Array<ReturnStatus>>;
  not?: InputMaybe<NestedEnumReturnStatusFilter>;
  notIn?: InputMaybe<Array<ReturnStatus>>;
};

export type EnumSaleChannelFieldUpdateOperationsInput = {
  set?: InputMaybe<SaleChannel>;
};

export type EnumSaleChannelFilter = {
  equals?: InputMaybe<SaleChannel>;
  in?: InputMaybe<Array<SaleChannel>>;
  not?: InputMaybe<NestedEnumSaleChannelFilter>;
  notIn?: InputMaybe<Array<SaleChannel>>;
};

export type EnumSaleStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<SaleStatus>;
};

export type EnumSaleStatusFilter = {
  equals?: InputMaybe<SaleStatus>;
  in?: InputMaybe<Array<SaleStatus>>;
  not?: InputMaybe<NestedEnumSaleStatusFilter>;
  notIn?: InputMaybe<Array<SaleStatus>>;
};

export type EnumSaleTypeFieldUpdateOperationsInput = {
  set?: InputMaybe<SaleType>;
};

export type EnumSaleTypeFilter = {
  equals?: InputMaybe<SaleType>;
  in?: InputMaybe<Array<SaleType>>;
  not?: InputMaybe<NestedEnumSaleTypeFilter>;
  notIn?: InputMaybe<Array<SaleType>>;
};

export type EnumSupplierQuoteStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<SupplierQuoteStatus>;
};

export type EnumSupplierQuoteStatusFilter = {
  equals?: InputMaybe<SupplierQuoteStatus>;
  in?: InputMaybe<Array<SupplierQuoteStatus>>;
  not?: InputMaybe<NestedEnumSupplierQuoteStatusFilter>;
  notIn?: InputMaybe<Array<SupplierQuoteStatus>>;
};

export type EnumTransferStatusFieldUpdateOperationsInput = {
  set?: InputMaybe<TransferStatus>;
};

export type EnumTransferStatusFilter = {
  equals?: InputMaybe<TransferStatus>;
  in?: InputMaybe<Array<TransferStatus>>;
  not?: InputMaybe<NestedEnumTransferStatusFilter>;
  notIn?: InputMaybe<Array<TransferStatus>>;
};

export type EnumUserTierFieldUpdateOperationsInput = {
  set?: InputMaybe<UserTier>;
};

export type EnumUserTierFilter = {
  equals?: InputMaybe<UserTier>;
  in?: InputMaybe<Array<UserTier>>;
  not?: InputMaybe<NestedEnumUserTierFilter>;
  notIn?: InputMaybe<Array<UserTier>>;
};

export type EnumUserTierNullableFilter = {
  equals?: InputMaybe<UserTier>;
  in?: InputMaybe<Array<UserTier>>;
  not?: InputMaybe<NestedEnumUserTierNullableFilter>;
  notIn?: InputMaybe<Array<UserTier>>;
};

export type EnumUserTierNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedEnumUserTierNullableFilter>;
  _min?: InputMaybe<NestedEnumUserTierNullableFilter>;
  equals?: InputMaybe<UserTier>;
  in?: InputMaybe<Array<UserTier>>;
  not?: InputMaybe<NestedEnumUserTierNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<UserTier>>;
};

export type Facet = {
  __typename?: 'Facet';
  _count: FacetCount;
  code: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  isPrivate: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  products?: Maybe<Array<ProductFacetValue>>;
  updatedAt: Scalars['DateTime']['output'];
  values?: Maybe<Array<Scalars['String']['output']>>;
  variants?: Maybe<Array<VariantFacetValue>>;
};

export type FacetAssignment = {
  __typename?: 'FacetAssignment';
  facet: FacetGql;
  value: Scalars['String']['output'];
};

export type FacetCount = {
  __typename?: 'FacetCount';
  products: Scalars['Int']['output'];
  variants: Scalars['Int']['output'];
};

export type FacetCreateNestedOneWithoutProductsInput = {
  connect?: InputMaybe<FacetWhereUniqueInput>;
  connectOrCreate?: InputMaybe<FacetCreateOrConnectWithoutProductsInput>;
  create?: InputMaybe<FacetCreateWithoutProductsInput>;
};

export type FacetCreateNestedOneWithoutVariantsInput = {
  connect?: InputMaybe<FacetWhereUniqueInput>;
  connectOrCreate?: InputMaybe<FacetCreateOrConnectWithoutVariantsInput>;
  create?: InputMaybe<FacetCreateWithoutVariantsInput>;
};

export type FacetCreateOrConnectWithoutProductsInput = {
  create: FacetCreateWithoutProductsInput;
  where: FacetWhereUniqueInput;
};

export type FacetCreateOrConnectWithoutVariantsInput = {
  create: FacetCreateWithoutVariantsInput;
  where: FacetWhereUniqueInput;
};

export type FacetCreateWithoutProductsInput = {
  code: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  values?: InputMaybe<FacetCreatevaluesInput>;
  variants?: InputMaybe<VariantFacetValueCreateNestedManyWithoutFacetInput>;
};

export type FacetCreateWithoutVariantsInput = {
  code: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  products?: InputMaybe<ProductFacetValueCreateNestedManyWithoutFacetInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  values?: InputMaybe<FacetCreatevaluesInput>;
};

export type FacetCreatevaluesInput = {
  set: Array<Scalars['String']['input']>;
};

export type FacetFilterInput = {
  facetId: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type FacetGql = {
  __typename?: 'FacetGQL';
  code: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isPrivate: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  values: Array<Scalars['String']['output']>;
};

export type FacetScalarRelationFilter = {
  is?: InputMaybe<FacetWhereInput>;
  isNot?: InputMaybe<FacetWhereInput>;
};

export type FacetUpdateOneRequiredWithoutProductsNestedInput = {
  connect?: InputMaybe<FacetWhereUniqueInput>;
  connectOrCreate?: InputMaybe<FacetCreateOrConnectWithoutProductsInput>;
  create?: InputMaybe<FacetCreateWithoutProductsInput>;
  update?: InputMaybe<FacetUpdateToOneWithWhereWithoutProductsInput>;
  upsert?: InputMaybe<FacetUpsertWithoutProductsInput>;
};

export type FacetUpdateOneRequiredWithoutVariantsNestedInput = {
  connect?: InputMaybe<FacetWhereUniqueInput>;
  connectOrCreate?: InputMaybe<FacetCreateOrConnectWithoutVariantsInput>;
  create?: InputMaybe<FacetCreateWithoutVariantsInput>;
  update?: InputMaybe<FacetUpdateToOneWithWhereWithoutVariantsInput>;
  upsert?: InputMaybe<FacetUpsertWithoutVariantsInput>;
};

export type FacetUpdateToOneWithWhereWithoutProductsInput = {
  data: FacetUpdateWithoutProductsInput;
  where?: InputMaybe<FacetWhereInput>;
};

export type FacetUpdateToOneWithWhereWithoutVariantsInput = {
  data: FacetUpdateWithoutVariantsInput;
  where?: InputMaybe<FacetWhereInput>;
};

export type FacetUpdateWithoutProductsInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isPrivate?: InputMaybe<BoolFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  values?: InputMaybe<FacetUpdatevaluesInput>;
  variants?: InputMaybe<VariantFacetValueUpdateManyWithoutFacetNestedInput>;
};

export type FacetUpdateWithoutVariantsInput = {
  code?: InputMaybe<StringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isPrivate?: InputMaybe<BoolFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  products?: InputMaybe<ProductFacetValueUpdateManyWithoutFacetNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  values?: InputMaybe<FacetUpdatevaluesInput>;
};

export type FacetUpdatevaluesInput = {
  push?: InputMaybe<Array<Scalars['String']['input']>>;
  set?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type FacetUpsertWithoutProductsInput = {
  create: FacetCreateWithoutProductsInput;
  update: FacetUpdateWithoutProductsInput;
  where?: InputMaybe<FacetWhereInput>;
};

export type FacetUpsertWithoutVariantsInput = {
  create: FacetCreateWithoutVariantsInput;
  update: FacetUpdateWithoutVariantsInput;
  where?: InputMaybe<FacetWhereInput>;
};

export type FacetWhereInput = {
  AND?: InputMaybe<Array<FacetWhereInput>>;
  NOT?: InputMaybe<Array<FacetWhereInput>>;
  OR?: InputMaybe<Array<FacetWhereInput>>;
  code?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  isPrivate?: InputMaybe<BoolFilter>;
  name?: InputMaybe<StringFilter>;
  products?: InputMaybe<ProductFacetValueListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  values?: InputMaybe<StringNullableListFilter>;
  variants?: InputMaybe<VariantFacetValueListRelationFilter>;
};

export type FacetWhereUniqueInput = {
  AND?: InputMaybe<Array<FacetWhereInput>>;
  NOT?: InputMaybe<Array<FacetWhereInput>>;
  OR?: InputMaybe<Array<FacetWhereInput>>;
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  isPrivate?: InputMaybe<BoolFilter>;
  name?: InputMaybe<StringFilter>;
  products?: InputMaybe<ProductFacetValueListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  values?: InputMaybe<StringNullableListFilter>;
  variants?: InputMaybe<VariantFacetValueListRelationFilter>;
};

export type FloatFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Float']['input']>;
  divide?: InputMaybe<Scalars['Float']['input']>;
  increment?: InputMaybe<Scalars['Float']['input']>;
  multiply?: InputMaybe<Scalars['Float']['input']>;
  set?: InputMaybe<Scalars['Float']['input']>;
};

export type FloatFilter = {
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type FloatNullableFilter = {
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type FloatWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedFloatFilter>;
  _min?: InputMaybe<NestedFloatFilter>;
  _sum?: InputMaybe<NestedFloatFilter>;
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type FulfillConsumerSaleInput = {
  id: Scalars['ID']['input'];
};

export type FulfillPurchaseReturnInput = {
  id: Scalars['String']['input'];
};

export type Fulfillment = {
  __typename?: 'Fulfillment';
  confirmationPin?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  createdAt: Scalars['DateTime']['output'];
  deliveryAddress?: Maybe<Scalars['String']['output']>;
  deliveryPersonnel?: Maybe<User>;
  deliveryPersonnelId?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  saleOrder: SaleOrder;
  saleOrderId: Scalars['String']['output'];
  status: FulfillmentStatus;
  type: FulfillmentType;
  updatedAt: Scalars['DateTime']['output'];
};

export type FulfillmentAvgAggregate = {
  __typename?: 'FulfillmentAvgAggregate';
  cost?: Maybe<Scalars['Float']['output']>;
};

export type FulfillmentCountAggregate = {
  __typename?: 'FulfillmentCountAggregate';
  _all: Scalars['Int']['output'];
  confirmationPin: Scalars['Int']['output'];
  cost: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  deliveryAddress: Scalars['Int']['output'];
  deliveryPersonnelId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  saleOrderId: Scalars['Int']['output'];
  status: Scalars['Int']['output'];
  type: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
};

export type FulfillmentCreateManyDeliveryPersonnelInput = {
  confirmationPin?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Float']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deliveryAddress?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  saleOrderId: Scalars['String']['input'];
  status?: InputMaybe<FulfillmentStatus>;
  type: FulfillmentType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type FulfillmentCreateManyDeliveryPersonnelInputEnvelope = {
  data: Array<FulfillmentCreateManyDeliveryPersonnelInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput = {
  connect?: InputMaybe<Array<FulfillmentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<FulfillmentCreateOrConnectWithoutDeliveryPersonnelInput>>;
  create?: InputMaybe<Array<FulfillmentCreateWithoutDeliveryPersonnelInput>>;
  createMany?: InputMaybe<FulfillmentCreateManyDeliveryPersonnelInputEnvelope>;
};

export type FulfillmentCreateNestedOneWithoutSaleOrderInput = {
  connect?: InputMaybe<FulfillmentWhereUniqueInput>;
  connectOrCreate?: InputMaybe<FulfillmentCreateOrConnectWithoutSaleOrderInput>;
  create?: InputMaybe<FulfillmentCreateWithoutSaleOrderInput>;
};

export type FulfillmentCreateOrConnectWithoutDeliveryPersonnelInput = {
  create: FulfillmentCreateWithoutDeliveryPersonnelInput;
  where: FulfillmentWhereUniqueInput;
};

export type FulfillmentCreateOrConnectWithoutSaleOrderInput = {
  create: FulfillmentCreateWithoutSaleOrderInput;
  where: FulfillmentWhereUniqueInput;
};

export type FulfillmentCreateWithoutDeliveryPersonnelInput = {
  confirmationPin?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Float']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deliveryAddress?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  saleOrder: SaleOrderCreateNestedOneWithoutFulfillmentInput;
  status?: InputMaybe<FulfillmentStatus>;
  type: FulfillmentType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type FulfillmentCreateWithoutSaleOrderInput = {
  confirmationPin?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Float']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  deliveryAddress?: InputMaybe<Scalars['String']['input']>;
  deliveryPersonnel?: InputMaybe<UserCreateNestedOneWithoutFulfillmentInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<FulfillmentStatus>;
  type: FulfillmentType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type FulfillmentListRelationFilter = {
  every?: InputMaybe<FulfillmentWhereInput>;
  none?: InputMaybe<FulfillmentWhereInput>;
  some?: InputMaybe<FulfillmentWhereInput>;
};

export type FulfillmentMaxAggregate = {
  __typename?: 'FulfillmentMaxAggregate';
  confirmationPin?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  deliveryAddress?: Maybe<Scalars['String']['output']>;
  deliveryPersonnelId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  saleOrderId?: Maybe<Scalars['String']['output']>;
  status?: Maybe<FulfillmentStatus>;
  type?: Maybe<FulfillmentType>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type FulfillmentMinAggregate = {
  __typename?: 'FulfillmentMinAggregate';
  confirmationPin?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  deliveryAddress?: Maybe<Scalars['String']['output']>;
  deliveryPersonnelId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  saleOrderId?: Maybe<Scalars['String']['output']>;
  status?: Maybe<FulfillmentStatus>;
  type?: Maybe<FulfillmentType>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type FulfillmentNullableScalarRelationFilter = {
  is?: InputMaybe<FulfillmentWhereInput>;
  isNot?: InputMaybe<FulfillmentWhereInput>;
};

export type FulfillmentOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type FulfillmentScalarWhereInput = {
  AND?: InputMaybe<Array<FulfillmentScalarWhereInput>>;
  NOT?: InputMaybe<Array<FulfillmentScalarWhereInput>>;
  OR?: InputMaybe<Array<FulfillmentScalarWhereInput>>;
  confirmationPin?: InputMaybe<StringNullableFilter>;
  cost?: InputMaybe<FloatNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  deliveryAddress?: InputMaybe<StringNullableFilter>;
  deliveryPersonnelId?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<StringFilter>;
  saleOrderId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumFulfillmentStatusFilter>;
  type?: InputMaybe<EnumFulfillmentTypeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export enum FulfillmentStatus {
  Assigned = 'ASSIGNED',
  Cancelled = 'CANCELLED',
  Delivered = 'DELIVERED',
  InTransit = 'IN_TRANSIT',
  Pending = 'PENDING'
}

export type FulfillmentSumAggregate = {
  __typename?: 'FulfillmentSumAggregate';
  cost?: Maybe<Scalars['Float']['output']>;
};

export enum FulfillmentType {
  Delivery = 'DELIVERY',
  Pickup = 'PICKUP'
}

export type FulfillmentUpdateManyMutationInput = {
  confirmationPin?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  cost?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  deliveryAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumFulfillmentStatusFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumFulfillmentTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type FulfillmentUpdateManyWithWhereWithoutDeliveryPersonnelInput = {
  data: FulfillmentUpdateManyMutationInput;
  where: FulfillmentScalarWhereInput;
};

export type FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput = {
  connect?: InputMaybe<Array<FulfillmentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<FulfillmentCreateOrConnectWithoutDeliveryPersonnelInput>>;
  create?: InputMaybe<Array<FulfillmentCreateWithoutDeliveryPersonnelInput>>;
  createMany?: InputMaybe<FulfillmentCreateManyDeliveryPersonnelInputEnvelope>;
  delete?: InputMaybe<Array<FulfillmentWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<FulfillmentScalarWhereInput>>;
  disconnect?: InputMaybe<Array<FulfillmentWhereUniqueInput>>;
  set?: InputMaybe<Array<FulfillmentWhereUniqueInput>>;
  update?: InputMaybe<Array<FulfillmentUpdateWithWhereUniqueWithoutDeliveryPersonnelInput>>;
  updateMany?: InputMaybe<Array<FulfillmentUpdateManyWithWhereWithoutDeliveryPersonnelInput>>;
  upsert?: InputMaybe<Array<FulfillmentUpsertWithWhereUniqueWithoutDeliveryPersonnelInput>>;
};

export type FulfillmentUpdateOneWithoutSaleOrderNestedInput = {
  connect?: InputMaybe<FulfillmentWhereUniqueInput>;
  connectOrCreate?: InputMaybe<FulfillmentCreateOrConnectWithoutSaleOrderInput>;
  create?: InputMaybe<FulfillmentCreateWithoutSaleOrderInput>;
  delete?: InputMaybe<FulfillmentWhereInput>;
  disconnect?: InputMaybe<FulfillmentWhereInput>;
  update?: InputMaybe<FulfillmentUpdateToOneWithWhereWithoutSaleOrderInput>;
  upsert?: InputMaybe<FulfillmentUpsertWithoutSaleOrderInput>;
};

export type FulfillmentUpdateToOneWithWhereWithoutSaleOrderInput = {
  data: FulfillmentUpdateWithoutSaleOrderInput;
  where?: InputMaybe<FulfillmentWhereInput>;
};

export type FulfillmentUpdateWithWhereUniqueWithoutDeliveryPersonnelInput = {
  data: FulfillmentUpdateWithoutDeliveryPersonnelInput;
  where: FulfillmentWhereUniqueInput;
};

export type FulfillmentUpdateWithoutDeliveryPersonnelInput = {
  confirmationPin?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  cost?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  deliveryAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  saleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutFulfillmentNestedInput>;
  status?: InputMaybe<EnumFulfillmentStatusFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumFulfillmentTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type FulfillmentUpdateWithoutSaleOrderInput = {
  confirmationPin?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  cost?: InputMaybe<NullableFloatFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  deliveryAddress?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  deliveryPersonnel?: InputMaybe<UserUpdateOneWithoutFulfillmentNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumFulfillmentStatusFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumFulfillmentTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type FulfillmentUpsertWithWhereUniqueWithoutDeliveryPersonnelInput = {
  create: FulfillmentCreateWithoutDeliveryPersonnelInput;
  update: FulfillmentUpdateWithoutDeliveryPersonnelInput;
  where: FulfillmentWhereUniqueInput;
};

export type FulfillmentUpsertWithoutSaleOrderInput = {
  create: FulfillmentCreateWithoutSaleOrderInput;
  update: FulfillmentUpdateWithoutSaleOrderInput;
  where?: InputMaybe<FulfillmentWhereInput>;
};

export type FulfillmentWhereInput = {
  AND?: InputMaybe<Array<FulfillmentWhereInput>>;
  NOT?: InputMaybe<Array<FulfillmentWhereInput>>;
  OR?: InputMaybe<Array<FulfillmentWhereInput>>;
  confirmationPin?: InputMaybe<StringNullableFilter>;
  cost?: InputMaybe<FloatNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  deliveryAddress?: InputMaybe<StringNullableFilter>;
  deliveryPersonnel?: InputMaybe<UserNullableScalarRelationFilter>;
  deliveryPersonnelId?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<StringFilter>;
  saleOrder?: InputMaybe<SaleOrderScalarRelationFilter>;
  saleOrderId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumFulfillmentStatusFilter>;
  type?: InputMaybe<EnumFulfillmentTypeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type FulfillmentWhereUniqueInput = {
  AND?: InputMaybe<Array<FulfillmentWhereInput>>;
  NOT?: InputMaybe<Array<FulfillmentWhereInput>>;
  OR?: InputMaybe<Array<FulfillmentWhereInput>>;
  confirmationPin?: InputMaybe<StringNullableFilter>;
  cost?: InputMaybe<FloatNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  deliveryAddress?: InputMaybe<StringNullableFilter>;
  deliveryPersonnel?: InputMaybe<UserNullableScalarRelationFilter>;
  deliveryPersonnelId?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  saleOrder?: InputMaybe<SaleOrderScalarRelationFilter>;
  saleOrderId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<EnumFulfillmentStatusFilter>;
  type?: InputMaybe<EnumFulfillmentTypeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type IdInput = {
  id: Scalars['String']['input'];
};

export type IngestLineResult = {
  __typename?: 'IngestLineResult';
  description: Scalars['String']['output'];
  discountPct?: Maybe<Scalars['Float']['output']>;
  discountedUnitPrice?: Maybe<Scalars['Float']['output']>;
  lineTotal: Scalars['Float']['output'];
  qty: Scalars['Float']['output'];
  unitPrice: Scalars['Float']['output'];
  variantId?: Maybe<Scalars['String']['output']>;
};

export type IntFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Int']['input']>;
  divide?: InputMaybe<Scalars['Int']['input']>;
  increment?: InputMaybe<Scalars['Int']['input']>;
  multiply?: InputMaybe<Scalars['Int']['input']>;
  set?: InputMaybe<Scalars['Int']['input']>;
};

export type IntFilter = {
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type IntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type IntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedIntNullableFilter>;
  _min?: InputMaybe<NestedIntNullableFilter>;
  _sum?: InputMaybe<NestedIntNullableFilter>;
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type InvoiceImport = {
  __typename?: 'InvoiceImport';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  message?: Maybe<Scalars['String']['output']>;
  parsed?: Maybe<Scalars['JSON']['output']>;
  status: InvoiceImportStatus;
  store?: Maybe<Store>;
  storeId?: Maybe<Scalars['String']['output']>;
  supplierName?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['DateTime']['output'];
  url: Scalars['String']['output'];
};

export type InvoiceImportCountAggregate = {
  __typename?: 'InvoiceImportCountAggregate';
  _all: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  message: Scalars['Int']['output'];
  parsed: Scalars['Int']['output'];
  status: Scalars['Int']['output'];
  storeId: Scalars['Int']['output'];
  supplierName: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
  url: Scalars['Int']['output'];
};

export type InvoiceImportCreateManyStoreInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  parsed?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<InvoiceImportStatus>;
  supplierName?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  url: Scalars['String']['input'];
};

export type InvoiceImportCreateManyStoreInputEnvelope = {
  data: Array<InvoiceImportCreateManyStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type InvoiceImportCreateNestedManyWithoutStoreInput = {
  connect?: InputMaybe<Array<InvoiceImportWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<InvoiceImportCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<InvoiceImportCreateWithoutStoreInput>>;
  createMany?: InputMaybe<InvoiceImportCreateManyStoreInputEnvelope>;
};

export type InvoiceImportCreateOrConnectWithoutStoreInput = {
  create: InvoiceImportCreateWithoutStoreInput;
  where: InvoiceImportWhereUniqueInput;
};

export type InvoiceImportCreateWithoutStoreInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  parsed?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<InvoiceImportStatus>;
  supplierName?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  url: Scalars['String']['input'];
};

export type InvoiceImportLineInput = {
  barcode?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  discountPct?: InputMaybe<Scalars['Float']['input']>;
  discountedUnitPrice?: InputMaybe<Scalars['Float']['input']>;
  lineTotal?: InputMaybe<Scalars['Float']['input']>;
  qty: Scalars['Int']['input'];
  unitPrice?: InputMaybe<Scalars['Float']['input']>;
};

export type InvoiceImportListRelationFilter = {
  every?: InputMaybe<InvoiceImportWhereInput>;
  none?: InputMaybe<InvoiceImportWhereInput>;
  some?: InputMaybe<InvoiceImportWhereInput>;
};

export type InvoiceImportMaxAggregate = {
  __typename?: 'InvoiceImportMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  status?: Maybe<InvoiceImportStatus>;
  storeId?: Maybe<Scalars['String']['output']>;
  supplierName?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

export type InvoiceImportMinAggregate = {
  __typename?: 'InvoiceImportMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  status?: Maybe<InvoiceImportStatus>;
  storeId?: Maybe<Scalars['String']['output']>;
  supplierName?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};

export type InvoiceImportOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type InvoiceImportScalarWhereInput = {
  AND?: InputMaybe<Array<InvoiceImportScalarWhereInput>>;
  NOT?: InputMaybe<Array<InvoiceImportScalarWhereInput>>;
  OR?: InputMaybe<Array<InvoiceImportScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  message?: InputMaybe<StringNullableFilter>;
  parsed?: InputMaybe<JsonNullableFilter>;
  status?: InputMaybe<EnumInvoiceImportStatusFilter>;
  storeId?: InputMaybe<StringNullableFilter>;
  supplierName?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  url?: InputMaybe<StringFilter>;
};

export enum InvoiceImportStatus {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  NeedsReview = 'NEEDS_REVIEW',
  Pending = 'PENDING',
  Processing = 'PROCESSING',
  Ready = 'READY'
}

export type InvoiceImportUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  message?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  parsed?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<EnumInvoiceImportStatusFieldUpdateOperationsInput>;
  supplierName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  url?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type InvoiceImportUpdateManyWithWhereWithoutStoreInput = {
  data: InvoiceImportUpdateManyMutationInput;
  where: InvoiceImportScalarWhereInput;
};

export type InvoiceImportUpdateManyWithoutStoreNestedInput = {
  connect?: InputMaybe<Array<InvoiceImportWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<InvoiceImportCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<InvoiceImportCreateWithoutStoreInput>>;
  createMany?: InputMaybe<InvoiceImportCreateManyStoreInputEnvelope>;
  delete?: InputMaybe<Array<InvoiceImportWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<InvoiceImportScalarWhereInput>>;
  disconnect?: InputMaybe<Array<InvoiceImportWhereUniqueInput>>;
  set?: InputMaybe<Array<InvoiceImportWhereUniqueInput>>;
  update?: InputMaybe<Array<InvoiceImportUpdateWithWhereUniqueWithoutStoreInput>>;
  updateMany?: InputMaybe<Array<InvoiceImportUpdateManyWithWhereWithoutStoreInput>>;
  upsert?: InputMaybe<Array<InvoiceImportUpsertWithWhereUniqueWithoutStoreInput>>;
};

export type InvoiceImportUpdateWithWhereUniqueWithoutStoreInput = {
  data: InvoiceImportUpdateWithoutStoreInput;
  where: InvoiceImportWhereUniqueInput;
};

export type InvoiceImportUpdateWithoutStoreInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  message?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  parsed?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<EnumInvoiceImportStatusFieldUpdateOperationsInput>;
  supplierName?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  url?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type InvoiceImportUpsertWithWhereUniqueWithoutStoreInput = {
  create: InvoiceImportCreateWithoutStoreInput;
  update: InvoiceImportUpdateWithoutStoreInput;
  where: InvoiceImportWhereUniqueInput;
};

export type InvoiceImportWhereInput = {
  AND?: InputMaybe<Array<InvoiceImportWhereInput>>;
  NOT?: InputMaybe<Array<InvoiceImportWhereInput>>;
  OR?: InputMaybe<Array<InvoiceImportWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  message?: InputMaybe<StringNullableFilter>;
  parsed?: InputMaybe<JsonNullableFilter>;
  status?: InputMaybe<EnumInvoiceImportStatusFilter>;
  store?: InputMaybe<StoreNullableScalarRelationFilter>;
  storeId?: InputMaybe<StringNullableFilter>;
  supplierName?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  url?: InputMaybe<StringFilter>;
};

export type InvoiceImportWhereUniqueInput = {
  AND?: InputMaybe<Array<InvoiceImportWhereInput>>;
  NOT?: InputMaybe<Array<InvoiceImportWhereInput>>;
  OR?: InputMaybe<Array<InvoiceImportWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  message?: InputMaybe<StringNullableFilter>;
  parsed?: InputMaybe<JsonNullableFilter>;
  status?: InputMaybe<EnumInvoiceImportStatusFilter>;
  store?: InputMaybe<StoreNullableScalarRelationFilter>;
  storeId?: InputMaybe<StringNullableFilter>;
  supplierName?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  url?: InputMaybe<StringFilter>;
};

export type IssueRfqInput = {
  requisitionId: Scalars['String']['input'];
  supplierIds?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type JsonFilter = {
  array_contains?: InputMaybe<Scalars['JSON']['input']>;
  array_ends_with?: InputMaybe<Scalars['JSON']['input']>;
  array_starts_with?: InputMaybe<Scalars['JSON']['input']>;
  equals?: InputMaybe<Scalars['JSON']['input']>;
  gt?: InputMaybe<Scalars['JSON']['input']>;
  gte?: InputMaybe<Scalars['JSON']['input']>;
  lt?: InputMaybe<Scalars['JSON']['input']>;
  lte?: InputMaybe<Scalars['JSON']['input']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<Scalars['JSON']['input']>;
  path?: InputMaybe<Array<Scalars['String']['input']>>;
  string_contains?: InputMaybe<Scalars['String']['input']>;
  string_ends_with?: InputMaybe<Scalars['String']['input']>;
  string_starts_with?: InputMaybe<Scalars['String']['input']>;
};

export type JsonNullableFilter = {
  array_contains?: InputMaybe<Scalars['JSON']['input']>;
  array_ends_with?: InputMaybe<Scalars['JSON']['input']>;
  array_starts_with?: InputMaybe<Scalars['JSON']['input']>;
  equals?: InputMaybe<Scalars['JSON']['input']>;
  gt?: InputMaybe<Scalars['JSON']['input']>;
  gte?: InputMaybe<Scalars['JSON']['input']>;
  lt?: InputMaybe<Scalars['JSON']['input']>;
  lte?: InputMaybe<Scalars['JSON']['input']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<Scalars['JSON']['input']>;
  path?: InputMaybe<Array<Scalars['String']['input']>>;
  string_contains?: InputMaybe<Scalars['String']['input']>;
  string_ends_with?: InputMaybe<Scalars['String']['input']>;
  string_starts_with?: InputMaybe<Scalars['String']['input']>;
};

export type JsonNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedJsonNullableFilter>;
  _min?: InputMaybe<NestedJsonNullableFilter>;
  array_contains?: InputMaybe<Scalars['JSON']['input']>;
  array_ends_with?: InputMaybe<Scalars['JSON']['input']>;
  array_starts_with?: InputMaybe<Scalars['JSON']['input']>;
  equals?: InputMaybe<Scalars['JSON']['input']>;
  gt?: InputMaybe<Scalars['JSON']['input']>;
  gte?: InputMaybe<Scalars['JSON']['input']>;
  lt?: InputMaybe<Scalars['JSON']['input']>;
  lte?: InputMaybe<Scalars['JSON']['input']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<Scalars['JSON']['input']>;
  path?: InputMaybe<Array<Scalars['String']['input']>>;
  string_contains?: InputMaybe<Scalars['String']['input']>;
  string_ends_with?: InputMaybe<Scalars['String']['input']>;
  string_starts_with?: InputMaybe<Scalars['String']['input']>;
};

export type LegacyStoreMapping = {
  __typename?: 'LegacyStoreMapping';
  id: Scalars['ID']['output'];
  store: Store;
  storeCode: Scalars['String']['output'];
  storeId: Scalars['String']['output'];
};

export type LegacyStoreMappingCreateManyStoreInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  storeCode: Scalars['String']['input'];
};

export type LegacyStoreMappingCreateManyStoreInputEnvelope = {
  data: Array<LegacyStoreMappingCreateManyStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type LegacyStoreMappingCreateNestedManyWithoutStoreInput = {
  connect?: InputMaybe<Array<LegacyStoreMappingWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<LegacyStoreMappingCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<LegacyStoreMappingCreateWithoutStoreInput>>;
  createMany?: InputMaybe<LegacyStoreMappingCreateManyStoreInputEnvelope>;
};

export type LegacyStoreMappingCreateOrConnectWithoutStoreInput = {
  create: LegacyStoreMappingCreateWithoutStoreInput;
  where: LegacyStoreMappingWhereUniqueInput;
};

export type LegacyStoreMappingCreateWithoutStoreInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  storeCode: Scalars['String']['input'];
};

export type LegacyStoreMappingListRelationFilter = {
  every?: InputMaybe<LegacyStoreMappingWhereInput>;
  none?: InputMaybe<LegacyStoreMappingWhereInput>;
  some?: InputMaybe<LegacyStoreMappingWhereInput>;
};

export type LegacyStoreMappingOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type LegacyStoreMappingScalarWhereInput = {
  AND?: InputMaybe<Array<LegacyStoreMappingScalarWhereInput>>;
  NOT?: InputMaybe<Array<LegacyStoreMappingScalarWhereInput>>;
  OR?: InputMaybe<Array<LegacyStoreMappingScalarWhereInput>>;
  id?: InputMaybe<StringFilter>;
  storeCode?: InputMaybe<StringFilter>;
  storeId?: InputMaybe<StringFilter>;
};

export type LegacyStoreMappingUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  storeCode?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type LegacyStoreMappingUpdateManyWithWhereWithoutStoreInput = {
  data: LegacyStoreMappingUpdateManyMutationInput;
  where: LegacyStoreMappingScalarWhereInput;
};

export type LegacyStoreMappingUpdateManyWithoutStoreNestedInput = {
  connect?: InputMaybe<Array<LegacyStoreMappingWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<LegacyStoreMappingCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<LegacyStoreMappingCreateWithoutStoreInput>>;
  createMany?: InputMaybe<LegacyStoreMappingCreateManyStoreInputEnvelope>;
  delete?: InputMaybe<Array<LegacyStoreMappingWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<LegacyStoreMappingScalarWhereInput>>;
  disconnect?: InputMaybe<Array<LegacyStoreMappingWhereUniqueInput>>;
  set?: InputMaybe<Array<LegacyStoreMappingWhereUniqueInput>>;
  update?: InputMaybe<Array<LegacyStoreMappingUpdateWithWhereUniqueWithoutStoreInput>>;
  updateMany?: InputMaybe<Array<LegacyStoreMappingUpdateManyWithWhereWithoutStoreInput>>;
  upsert?: InputMaybe<Array<LegacyStoreMappingUpsertWithWhereUniqueWithoutStoreInput>>;
};

export type LegacyStoreMappingUpdateWithWhereUniqueWithoutStoreInput = {
  data: LegacyStoreMappingUpdateWithoutStoreInput;
  where: LegacyStoreMappingWhereUniqueInput;
};

export type LegacyStoreMappingUpdateWithoutStoreInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  storeCode?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type LegacyStoreMappingUpsertWithWhereUniqueWithoutStoreInput = {
  create: LegacyStoreMappingCreateWithoutStoreInput;
  update: LegacyStoreMappingUpdateWithoutStoreInput;
  where: LegacyStoreMappingWhereUniqueInput;
};

export type LegacyStoreMappingWhereInput = {
  AND?: InputMaybe<Array<LegacyStoreMappingWhereInput>>;
  NOT?: InputMaybe<Array<LegacyStoreMappingWhereInput>>;
  OR?: InputMaybe<Array<LegacyStoreMappingWhereInput>>;
  id?: InputMaybe<StringFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeCode?: InputMaybe<StringFilter>;
  storeId?: InputMaybe<StringFilter>;
};

export type LegacyStoreMappingWhereUniqueInput = {
  AND?: InputMaybe<Array<LegacyStoreMappingWhereInput>>;
  NOT?: InputMaybe<Array<LegacyStoreMappingWhereInput>>;
  OR?: InputMaybe<Array<LegacyStoreMappingWhereInput>>;
  id?: InputMaybe<Scalars['String']['input']>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeCode?: InputMaybe<Scalars['String']['input']>;
  storeId?: InputMaybe<StringFilter>;
};

export type LinkSupplierUserInput = {
  supplierId: Scalars['ID']['input'];
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type LinkVariantToProductInput = {
  productId: Scalars['ID']['input'];
  variantId: Scalars['ID']['input'];
};

export type LoginInput = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};

export type LooseProductVariantInput = {
  barcode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  productId?: InputMaybe<Scalars['ID']['input']>;
  resellerPrice: Scalars['Float']['input'];
};

export type LowStockCandidate = {
  __typename?: 'LowStockCandidate';
  barcode?: Maybe<Scalars['String']['output']>;
  productId?: Maybe<Scalars['String']['output']>;
  productName?: Maybe<Scalars['String']['output']>;
  productVariantId: Scalars['String']['output'];
  quantity?: Maybe<Scalars['Int']['output']>;
  reorderPoint?: Maybe<Scalars['Int']['output']>;
  reorderQty?: Maybe<Scalars['Int']['output']>;
  storeId: Scalars['String']['output'];
  storeName?: Maybe<Scalars['String']['output']>;
  supplierCount?: Maybe<Scalars['Int']['output']>;
  supplierDefaultCost?: Maybe<Scalars['Float']['output']>;
  supplierId?: Maybe<Scalars['String']['output']>;
  supplierIsPreferred?: Maybe<Scalars['Boolean']['output']>;
  supplierLeadTimeDays?: Maybe<Scalars['Int']['output']>;
  supplierName?: Maybe<Scalars['String']['output']>;
};

export type MarkPurchaseOrderReceivedInput = {
  id: Scalars['String']['input'];
};

export type MonthlySalesSummary = {
  __typename?: 'MonthlySalesSummary';
  month: Scalars['String']['output'];
  totalReturned: Scalars['Int']['output'];
  totalSold: Scalars['Int']['output'];
};

export enum MovementDirection {
  In = 'IN',
  Out = 'OUT'
}

export enum MovementType {
  Purchase = 'PURCHASE',
  ReturnPurchase = 'RETURN_PURCHASE',
  ReturnSale = 'RETURN_SALE',
  Sale = 'SALE',
  Transfer = 'TRANSFER'
}

export type Mutation = {
  __typename?: 'Mutation';
  activateReseller: ResellerProfile;
  adminApproveInvoiceImport: ApproveInvoiceResult;
  adminCreateCustomer: User;
  adminCreateInvoiceImport: InvoiceImport;
  adminProcessInvoiceUrl: ProcessInvoiceResult;
  adminReprocessInvoiceImport: InvoiceImport;
  adminRevertOrderToQuotation: SaleOrder;
  adminRevertToQuotation: SaleOrder;
  adminSendSupportMessage: SupportMessage;
  adminUpdateCustomerProfile: CustomerProfile;
  adminUpdateInvoiceImport: InvoiceImport;
  applyReseller: ResellerProfile;
  approvePurchaseRequisition: Scalars['Boolean']['output'];
  approveReseller: ResellerProfile;
  assignAsset: AssetAssignment;
  assignBiller: ResellerProfile;
  assignFacetToProduct: Scalars['String']['output'];
  assignFacetToVariant: Scalars['String']['output'];
  /** Update fulfillment status (ASSIGNED, IN_TRANSIT, DELIVERED, CANCELLED). If DELIVERED and a PIN is set, confirmationPin is required. */
  assignFulfillmentPersonnel: Fulfillment;
  assignStoreManager: Scalars['Boolean']['output'];
  /** Attach a variant to a product by setting productId */
  attachVariantToProduct: Scalars['Boolean']['output'];
  billerConvertConfirmedQuotation: Quotation;
  bulkAssignFacetToProducts: Scalars['Int']['output'];
  bulkAssignFacetToVariants: Scalars['Int']['output'];
  bulkAssignStoreManager: Scalars['Float']['output'];
  bulkRemoveFacetFromProducts: Scalars['Int']['output'];
  bulkRemoveFacetFromVariants: Scalars['Int']['output'];
  changePassword: Scalars['Boolean']['output'];
  checkoutConsumerQuotation: ConsumerSale;
  closeRFQ: Scalars['Boolean']['output'];
  completeCustomerProfile: CustomerProfile;
  confirmConsumerPayment: ConsumerPayment;
  confirmResellerPayment: ResellerPayment;
  confirmResellerQuotation: ResellerSale;
  createCollection: CollectionGql;
  createConsumerReceipt: ConsumerReceipt;
  createConsumerSale: ConsumerSale;
  createFacet: FacetGql;
  /** Assign delivery personnel to a fulfillment and set status to ASSIGNED */
  createFulfillment: Fulfillment;
  createLooseProductVariant: ProductVariant;
  createLowStockRequisitionAndIssuePreferred?: Maybe<Scalars['String']['output']>;
  createManyProduct?: Maybe<AffectedRows>;
  createManyProductVariant?: Maybe<AffectedRows>;
  createManyStore?: Maybe<AffectedRows>;
  createManyUser?: Maybe<AffectedRows>;
  createPOsFromSelection: Array<Scalars['String']['output']>;
  createProduct?: Maybe<Product>;
  createProductVariant?: Maybe<ProductVariant>;
  createPurchaseOrder: PurchaseOrder;
  createPurchaseRequisition: Scalars['String']['output'];
  createPurchaseReturn: Scalars['String']['output'];
  createQuotationDraft: Quotation;
  createRequisitionFromLowStock?: Maybe<Scalars['String']['output']>;
  createResellerSale: ResellerSale;
  createSalesReturn: Scalars['String']['output'];
  createSalesReturnForOrder: Scalars['String']['output'];
  createStaff: User;
  createStore?: Maybe<Store>;
  createSupplier: Supplier;
  createSupplierPayment: SupplierPayment;
  createUser?: Maybe<User>;
  deleteCollection: Scalars['Boolean']['output'];
  deleteFacet: Scalars['String']['output'];
  deleteManyProduct?: Maybe<AffectedRows>;
  deleteManyProductVariant?: Maybe<AffectedRows>;
  deleteManyStore?: Maybe<AffectedRows>;
  deleteManyUser?: Maybe<AffectedRows>;
  deleteProduct?: Maybe<Product>;
  deleteProductVariant?: Maybe<ProductVariant>;
  deleteStore?: Maybe<Store>;
  deleteUser?: Maybe<User>;
  devImportSnapshot: Scalars['String']['output'];
  devPurgeInvoiceImports: Scalars['Int']['output'];
  devPurgeOrphanVariants: Scalars['Int']['output'];
  devPurgeProducts: Scalars['Int']['output'];
  devPurgePurchaseOrders: Scalars['Int']['output'];
  devSeedFixtures: Scalars['String']['output'];
  fulfillConsumerSale: ConsumerSale;
  fulfillPurchaseReturn: Scalars['Boolean']['output'];
  issueRFQ: Scalars['Boolean']['output'];
  issueRFQPreferred: Scalars['Boolean']['output'];
  linkSupplierUser: Supplier;
  linkVariantToProduct: ProductVariant;
  login: AuthResponse;
  markAsRead: Notification;
  markPurchaseOrderReceived: PurchaseOrder;
  processOutbox: Scalars['Int']['output'];
  receiveStockBatch: StockReceiptBatch;
  registerConsumerPayment: ConsumerPayment;
  registerResellerPayment: ResellerPayment;
  rejectPurchaseRequisition: Scalars['Boolean']['output'];
  rejectReseller: ResellerProfile;
  rejectSupplierQuote: Scalars['Boolean']['output'];
  removeAsset: Scalars['Boolean']['output'];
  removeFacetFromProduct: Scalars['String']['output'];
  removeFacetFromVariant: Scalars['String']['output'];
  retryOutboxFailed: Scalars['Int']['output'];
  runLowStockScanNow: Scalars['Boolean']['output'];
  selectSupplierQuote: Scalars['Boolean']['output'];
  sendEmailVerification: Scalars['Boolean']['output'];
  sendPhoneVerification: Scalars['Boolean']['output'];
  sendSupportMessage: SupportMessage;
  sendUserEmailVerification: Scalars['Boolean']['output'];
  setReorderSettings: Stock;
  signupCustomer: AuthResponse;
  submitPurchaseRequisition: Scalars['Boolean']['output'];
  submitSupplierQuote: Scalars['String']['output'];
  transferStock: StockTransfer;
  unassignAsset: Scalars['Boolean']['output'];
  unlinkVariantFromProduct: ProductVariant;
  updateCollection: CollectionGql;
  updateFacet: FacetGql;
  updateFulfillmentStatus: Fulfillment;
  updateManyProduct?: Maybe<AffectedRows>;
  updateManyProductVariant?: Maybe<AffectedRows>;
  updateManyStore?: Maybe<AffectedRows>;
  updateManyUser?: Maybe<AffectedRows>;
  updateMyProfile: CustomerProfile;
  updateProduct?: Maybe<Product>;
  updateProductVariant?: Maybe<ProductVariant>;
  updatePurchaseOrderPhase: PurchaseOrder;
  updatePurchaseOrderStatus: PurchaseOrder;
  updateQuotationStatus: Quotation;
  updateSalesReturnStatus: Scalars['Boolean']['output'];
  updateStore?: Maybe<Store>;
  updateSupplier: Supplier;
  updateUser?: Maybe<User>;
  upsertSupplierCatalog: SupplierCatalogEntry;
  upsertSupplierCatalogBulk: Array<Scalars['String']['output']>;
  upsertVariantSupplierCatalog: SupplierCatalogEntry;
  upsertVariantTierPrice: Scalars['String']['output'];
  verifyEmail: Scalars['Boolean']['output'];
  verifyPhone: Scalars['Boolean']['output'];
};


export type MutationActivateResellerArgs = {
  billerId?: InputMaybe<Scalars['String']['input']>;
  resellerId: Scalars['String']['input'];
};


export type MutationAdminApproveInvoiceImportArgs = {
  input: ApproveInvoiceImportInput;
};


export type MutationAdminCreateCustomerArgs = {
  input: AdminCreateCustomerInput;
};


export type MutationAdminCreateInvoiceImportArgs = {
  input: CreateInvoiceImportInput;
};


export type MutationAdminProcessInvoiceUrlArgs = {
  input: ProcessInvoiceUrlInput;
};


export type MutationAdminReprocessInvoiceImportArgs = {
  id: Scalars['String']['input'];
};


export type MutationAdminRevertOrderToQuotationArgs = {
  saleOrderId: Scalars['String']['input'];
};


export type MutationAdminRevertToQuotationArgs = {
  saleOrderId: Scalars['String']['input'];
};


export type MutationAdminSendSupportMessageArgs = {
  input: AdminSendSupportMessageInput;
};


export type MutationAdminUpdateCustomerProfileArgs = {
  input: AdminUpdateCustomerProfileInput;
  userId: Scalars['String']['input'];
};


export type MutationAdminUpdateInvoiceImportArgs = {
  input: UpdateInvoiceImportInput;
};


export type MutationApplyResellerArgs = {
  input: ApplyResellerInput;
};


export type MutationApprovePurchaseRequisitionArgs = {
  input: IdInput;
};


export type MutationApproveResellerArgs = {
  input: ApproveResellerInput;
  resellerId: Scalars['String']['input'];
};


export type MutationAssignAssetArgs = {
  input: AssignAssetInput;
};


export type MutationAssignBillerArgs = {
  input: AssignBillerInput;
};


export type MutationAssignFacetToProductArgs = {
  facetId: Scalars['String']['input'];
  productId: Scalars['String']['input'];
  value: Scalars['String']['input'];
};


export type MutationAssignFacetToVariantArgs = {
  facetId: Scalars['String']['input'];
  productVariantId: Scalars['String']['input'];
  value: Scalars['String']['input'];
};


export type MutationAssignFulfillmentPersonnelArgs = {
  input: AssignFulfillmentPersonnelInput;
};


export type MutationAssignStoreManagerArgs = {
  managerId: Scalars['String']['input'];
  storeId: Scalars['String']['input'];
};


export type MutationAttachVariantToProductArgs = {
  productId: Scalars['String']['input'];
  variantId: Scalars['String']['input'];
};


export type MutationBillerConvertConfirmedQuotationArgs = {
  input: BillerConvertQuotationInput;
};


export type MutationBulkAssignFacetToProductsArgs = {
  facetId: Scalars['String']['input'];
  productIds: Array<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};


export type MutationBulkAssignFacetToVariantsArgs = {
  facetId: Scalars['String']['input'];
  value: Scalars['String']['input'];
  variantIds: Array<Scalars['String']['input']>;
};


export type MutationBulkAssignStoreManagerArgs = {
  managerId: Scalars['String']['input'];
  storeIds: Array<Scalars['String']['input']>;
};


export type MutationBulkRemoveFacetFromProductsArgs = {
  facetId: Scalars['String']['input'];
  productIds: Array<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};


export type MutationBulkRemoveFacetFromVariantsArgs = {
  facetId: Scalars['String']['input'];
  value: Scalars['String']['input'];
  variantIds: Array<Scalars['String']['input']>;
};


export type MutationChangePasswordArgs = {
  input: ChangePasswordInput;
};


export type MutationCheckoutConsumerQuotationArgs = {
  input: CheckoutConsumerQuotationInput;
};


export type MutationCloseRfqArgs = {
  input: CloseRfqInput;
};


export type MutationCompleteCustomerProfileArgs = {
  input: UpdateCustomerProfileInput;
};


export type MutationConfirmConsumerPaymentArgs = {
  input: ConfirmConsumerPaymentInput;
};


export type MutationConfirmResellerPaymentArgs = {
  paymentId: Scalars['String']['input'];
};


export type MutationConfirmResellerQuotationArgs = {
  input: ConfirmResellerQuotationInput;
};


export type MutationCreateCollectionArgs = {
  input: CreateCollectionInput;
};


export type MutationCreateConsumerReceiptArgs = {
  input: CreateConsumerReceiptInput;
};


export type MutationCreateConsumerSaleArgs = {
  input: CreateConsumerSaleInput;
};


export type MutationCreateFacetArgs = {
  input: CreateFacetInput;
};


export type MutationCreateFulfillmentArgs = {
  input: CreateFulfillmentInput;
};


export type MutationCreateLooseProductVariantArgs = {
  input: LooseProductVariantInput;
};


export type MutationCreateLowStockRequisitionAndIssuePreferredArgs = {
  input: CreateRequisitionFromLowStockInput;
};


export type MutationCreateManyProductArgs = {
  data: Array<ProductCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationCreateManyProductVariantArgs = {
  data: Array<ProductVariantCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationCreateManyStoreArgs = {
  data: Array<StoreCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationCreateManyUserArgs = {
  data: Array<UserCreateManyInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationCreatePOsFromSelectionArgs = {
  input: CreatePOsFromSelectionInput;
};


export type MutationCreateProductArgs = {
  data: ProductCreateInput;
};


export type MutationCreateProductVariantArgs = {
  data: ProductVariantCreateInput;
};


export type MutationCreatePurchaseOrderArgs = {
  input: CreatePurchaseOrderInput;
};


export type MutationCreatePurchaseRequisitionArgs = {
  input: CreatePurchaseRequisitionInput;
};


export type MutationCreatePurchaseReturnArgs = {
  input: CreatePurchaseReturnInput;
};


export type MutationCreateQuotationDraftArgs = {
  input: CreateQuotationDraftInput;
};


export type MutationCreateRequisitionFromLowStockArgs = {
  input: CreateRequisitionFromLowStockInput;
};


export type MutationCreateResellerSaleArgs = {
  input: CreateResellerSaleInput;
};


export type MutationCreateSalesReturnArgs = {
  input: CreateSalesReturnInput;
};


export type MutationCreateSalesReturnForOrderArgs = {
  input: CreateOrderReturnInput;
};


export type MutationCreateStaffArgs = {
  input: CreateStaffInput;
};


export type MutationCreateStoreArgs = {
  data: StoreCreateInput;
};


export type MutationCreateSupplierArgs = {
  input: CreateSupplierInput;
};


export type MutationCreateSupplierPaymentArgs = {
  input: CreateSupplierPaymentInput;
};


export type MutationCreateUserArgs = {
  data: UserCreateInput;
};


export type MutationDeleteCollectionArgs = {
  id: Scalars['String']['input'];
};


export type MutationDeleteFacetArgs = {
  id: Scalars['String']['input'];
};


export type MutationDeleteManyProductArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductWhereInput>;
};


export type MutationDeleteManyProductVariantArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductVariantWhereInput>;
};


export type MutationDeleteManyStoreArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<StoreWhereInput>;
};


export type MutationDeleteManyUserArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type MutationDeleteProductArgs = {
  where: ProductWhereUniqueInput;
};


export type MutationDeleteProductVariantArgs = {
  where: ProductVariantWhereUniqueInput;
};


export type MutationDeleteStoreArgs = {
  where: StoreWhereUniqueInput;
};


export type MutationDeleteUserArgs = {
  where: UserWhereUniqueInput;
};


export type MutationDevImportSnapshotArgs = {
  json: Scalars['String']['input'];
  preview?: InputMaybe<Scalars['Boolean']['input']>;
};


export type MutationDevPurgeInvoiceImportsArgs = {
  filter?: InputMaybe<DevPurgeFilter>;
};


export type MutationDevPurgeOrphanVariantsArgs = {
  filter?: InputMaybe<DevPurgeFilter>;
};


export type MutationDevPurgeProductsArgs = {
  filter?: InputMaybe<DevPurgeFilter>;
};


export type MutationDevPurgePurchaseOrdersArgs = {
  filter?: InputMaybe<DevPurgeFilter>;
};


export type MutationFulfillConsumerSaleArgs = {
  input: FulfillConsumerSaleInput;
};


export type MutationFulfillPurchaseReturnArgs = {
  input: FulfillPurchaseReturnInput;
};


export type MutationIssueRfqArgs = {
  input: IssueRfqInput;
};


export type MutationIssueRfqPreferredArgs = {
  requisitionId: Scalars['String']['input'];
};


export type MutationLinkSupplierUserArgs = {
  input: LinkSupplierUserInput;
};


export type MutationLinkVariantToProductArgs = {
  input: LinkVariantToProductInput;
};


export type MutationLoginArgs = {
  input: LoginInput;
};


export type MutationMarkAsReadArgs = {
  id: Scalars['String']['input'];
};


export type MutationMarkPurchaseOrderReceivedArgs = {
  input: MarkPurchaseOrderReceivedInput;
};


export type MutationProcessOutboxArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<OutboxStatus>;
  type?: InputMaybe<Scalars['String']['input']>;
};


export type MutationReceiveStockBatchArgs = {
  input: ReceiveStockBatchInput;
};


export type MutationRegisterConsumerPaymentArgs = {
  input: CreateConsumerPaymentInput;
};


export type MutationRegisterResellerPaymentArgs = {
  input: CreateResellerPaymentInput;
};


export type MutationRejectPurchaseRequisitionArgs = {
  input: RejectRequisitionInput;
};


export type MutationRejectResellerArgs = {
  reason?: InputMaybe<Scalars['String']['input']>;
  resellerId: Scalars['String']['input'];
};


export type MutationRejectSupplierQuoteArgs = {
  input: RejectSupplierQuoteInput;
};


export type MutationRemoveAssetArgs = {
  assetId: Scalars['String']['input'];
};


export type MutationRemoveFacetFromProductArgs = {
  facetId: Scalars['String']['input'];
  productId: Scalars['String']['input'];
  value: Scalars['String']['input'];
};


export type MutationRemoveFacetFromVariantArgs = {
  facetId: Scalars['String']['input'];
  productVariantId: Scalars['String']['input'];
  value: Scalars['String']['input'];
};


export type MutationRetryOutboxFailedArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};


export type MutationSelectSupplierQuoteArgs = {
  input: SelectSupplierQuoteInput;
};


export type MutationSendSupportMessageArgs = {
  input: SendSupportMessageInput;
};


export type MutationSendUserEmailVerificationArgs = {
  userId: Scalars['String']['input'];
};


export type MutationSetReorderSettingsArgs = {
  input: SetReorderSettingsInput;
};


export type MutationSignupCustomerArgs = {
  input: CreateUserInput;
};


export type MutationSubmitPurchaseRequisitionArgs = {
  input: IdInput;
};


export type MutationSubmitSupplierQuoteArgs = {
  input: SubmitSupplierQuoteInput;
};


export type MutationTransferStockArgs = {
  input: TransferStockInput;
};


export type MutationUnassignAssetArgs = {
  input: AssignAssetInput;
};


export type MutationUnlinkVariantFromProductArgs = {
  input: UnlinkVariantFromProductInput;
};


export type MutationUpdateCollectionArgs = {
  input: UpdateCollectionInput;
};


export type MutationUpdateFacetArgs = {
  input: UpdateFacetInput;
};


export type MutationUpdateFulfillmentStatusArgs = {
  input: UpdateFulfillmentStatusInput;
};


export type MutationUpdateManyProductArgs = {
  data: ProductUpdateManyMutationInput;
  limit?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductWhereInput>;
};


export type MutationUpdateManyProductVariantArgs = {
  data: ProductVariantUpdateManyMutationInput;
  limit?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductVariantWhereInput>;
};


export type MutationUpdateManyStoreArgs = {
  data: StoreUpdateManyMutationInput;
  limit?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<StoreWhereInput>;
};


export type MutationUpdateManyUserArgs = {
  data: UserUpdateManyMutationInput;
  limit?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type MutationUpdateMyProfileArgs = {
  input: UpdateCustomerProfileInput;
};


export type MutationUpdateProductArgs = {
  data: ProductUpdateInput;
  where: ProductWhereUniqueInput;
};


export type MutationUpdateProductVariantArgs = {
  data: ProductVariantUpdateInput;
  where: ProductVariantWhereUniqueInput;
};


export type MutationUpdatePurchaseOrderPhaseArgs = {
  input: UpdatePurchaseOrderPhaseInput;
};


export type MutationUpdatePurchaseOrderStatusArgs = {
  input: UpdatePurchaseOrderStatusInput;
};


export type MutationUpdateQuotationStatusArgs = {
  input: UpdateQuotationStatusInput;
};


export type MutationUpdateSalesReturnStatusArgs = {
  input: UpdateSalesReturnStatusInput;
};


export type MutationUpdateStoreArgs = {
  data: StoreUpdateInput;
  where: StoreWhereUniqueInput;
};


export type MutationUpdateSupplierArgs = {
  input: UpdateSupplierInput;
};


export type MutationUpdateUserArgs = {
  data: UserUpdateInput;
  where: UserWhereUniqueInput;
};


export type MutationUpsertSupplierCatalogArgs = {
  input: UpsertSupplierCatalogInput;
};


export type MutationUpsertSupplierCatalogBulkArgs = {
  input: UpsertSupplierCatalogBulkInput;
};


export type MutationUpsertVariantSupplierCatalogArgs = {
  input: UpsertVariantSupplierCatalogInput;
};


export type MutationUpsertVariantTierPriceArgs = {
  input: UpsertVariantTierPriceInput;
};


export type MutationVerifyEmailArgs = {
  token: Scalars['String']['input'];
};


export type MutationVerifyPhoneArgs = {
  code: Scalars['String']['input'];
};

export type NestedBoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type NestedBoolWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedBoolFilter>;
  _min?: InputMaybe<NestedBoolFilter>;
  equals?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NestedBoolWithAggregatesFilter>;
};

export type NestedDateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type NestedDateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type NestedDateTimeNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedDateTimeNullableFilter>;
  _min?: InputMaybe<NestedDateTimeNullableFilter>;
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type NestedDateTimeWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedDateTimeFilter>;
  _min?: InputMaybe<NestedDateTimeFilter>;
  equals?: InputMaybe<Scalars['DateTime']['input']>;
  gt?: InputMaybe<Scalars['DateTime']['input']>;
  gte?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<Scalars['DateTime']['input']>>;
  lt?: InputMaybe<Scalars['DateTime']['input']>;
  lte?: InputMaybe<Scalars['DateTime']['input']>;
  not?: InputMaybe<NestedDateTimeWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']['input']>>;
};

export type NestedEnumAdjustmentTypeNullableFilter = {
  equals?: InputMaybe<AdjustmentType>;
  in?: InputMaybe<Array<AdjustmentType>>;
  not?: InputMaybe<NestedEnumAdjustmentTypeNullableFilter>;
  notIn?: InputMaybe<Array<AdjustmentType>>;
};

export type NestedEnumAssetEntityTypeFilter = {
  equals?: InputMaybe<AssetEntityType>;
  in?: InputMaybe<Array<AssetEntityType>>;
  not?: InputMaybe<NestedEnumAssetEntityTypeFilter>;
  notIn?: InputMaybe<Array<AssetEntityType>>;
};

export type NestedEnumAssetKindFilter = {
  equals?: InputMaybe<AssetKind>;
  in?: InputMaybe<Array<AssetKind>>;
  not?: InputMaybe<NestedEnumAssetKindFilter>;
  notIn?: InputMaybe<Array<AssetKind>>;
};

export type NestedEnumAssetKindWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedEnumAssetKindFilter>;
  _min?: InputMaybe<NestedEnumAssetKindFilter>;
  equals?: InputMaybe<AssetKind>;
  in?: InputMaybe<Array<AssetKind>>;
  not?: InputMaybe<NestedEnumAssetKindWithAggregatesFilter>;
  notIn?: InputMaybe<Array<AssetKind>>;
};

export type NestedEnumFulfillmentStatusFilter = {
  equals?: InputMaybe<FulfillmentStatus>;
  in?: InputMaybe<Array<FulfillmentStatus>>;
  not?: InputMaybe<NestedEnumFulfillmentStatusFilter>;
  notIn?: InputMaybe<Array<FulfillmentStatus>>;
};

export type NestedEnumFulfillmentTypeFilter = {
  equals?: InputMaybe<FulfillmentType>;
  in?: InputMaybe<Array<FulfillmentType>>;
  not?: InputMaybe<NestedEnumFulfillmentTypeFilter>;
  notIn?: InputMaybe<Array<FulfillmentType>>;
};

export type NestedEnumInvoiceImportStatusFilter = {
  equals?: InputMaybe<InvoiceImportStatus>;
  in?: InputMaybe<Array<InvoiceImportStatus>>;
  not?: InputMaybe<NestedEnumInvoiceImportStatusFilter>;
  notIn?: InputMaybe<Array<InvoiceImportStatus>>;
};

export type NestedEnumMovementDirectionFilter = {
  equals?: InputMaybe<MovementDirection>;
  in?: InputMaybe<Array<MovementDirection>>;
  not?: InputMaybe<NestedEnumMovementDirectionFilter>;
  notIn?: InputMaybe<Array<MovementDirection>>;
};

export type NestedEnumMovementTypeFilter = {
  equals?: InputMaybe<MovementType>;
  in?: InputMaybe<Array<MovementType>>;
  not?: InputMaybe<NestedEnumMovementTypeFilter>;
  notIn?: InputMaybe<Array<MovementType>>;
};

export type NestedEnumOrderPhaseFilter = {
  equals?: InputMaybe<OrderPhase>;
  in?: InputMaybe<Array<OrderPhase>>;
  not?: InputMaybe<NestedEnumOrderPhaseFilter>;
  notIn?: InputMaybe<Array<OrderPhase>>;
};

export type NestedEnumPaymentMethodFilter = {
  equals?: InputMaybe<PaymentMethod>;
  in?: InputMaybe<Array<PaymentMethod>>;
  not?: InputMaybe<NestedEnumPaymentMethodFilter>;
  notIn?: InputMaybe<Array<PaymentMethod>>;
};

export type NestedEnumPaymentStatusFilter = {
  equals?: InputMaybe<PaymentStatus>;
  in?: InputMaybe<Array<PaymentStatus>>;
  not?: InputMaybe<NestedEnumPaymentStatusFilter>;
  notIn?: InputMaybe<Array<PaymentStatus>>;
};

export type NestedEnumPaymentTypeFilter = {
  equals?: InputMaybe<PaymentType>;
  in?: InputMaybe<Array<PaymentType>>;
  not?: InputMaybe<NestedEnumPaymentTypeFilter>;
  notIn?: InputMaybe<Array<PaymentType>>;
};

export type NestedEnumProfileStatusFilter = {
  equals?: InputMaybe<ProfileStatus>;
  in?: InputMaybe<Array<ProfileStatus>>;
  not?: InputMaybe<NestedEnumProfileStatusFilter>;
  notIn?: InputMaybe<Array<ProfileStatus>>;
};

export type NestedEnumPurchaseOrderStatusFilter = {
  equals?: InputMaybe<PurchaseOrderStatus>;
  in?: InputMaybe<Array<PurchaseOrderStatus>>;
  not?: InputMaybe<NestedEnumPurchaseOrderStatusFilter>;
  notIn?: InputMaybe<Array<PurchaseOrderStatus>>;
};

export type NestedEnumPurchasePhaseFilter = {
  equals?: InputMaybe<PurchasePhase>;
  in?: InputMaybe<Array<PurchasePhase>>;
  not?: InputMaybe<NestedEnumPurchasePhaseFilter>;
  notIn?: InputMaybe<Array<PurchasePhase>>;
};

export type NestedEnumPurchaseRequisitionStatusFilter = {
  equals?: InputMaybe<PurchaseRequisitionStatus>;
  in?: InputMaybe<Array<PurchaseRequisitionStatus>>;
  not?: InputMaybe<NestedEnumPurchaseRequisitionStatusFilter>;
  notIn?: InputMaybe<Array<PurchaseRequisitionStatus>>;
};

export type NestedEnumQuotationStatusFilter = {
  equals?: InputMaybe<QuotationStatus>;
  in?: InputMaybe<Array<QuotationStatus>>;
  not?: InputMaybe<NestedEnumQuotationStatusFilter>;
  notIn?: InputMaybe<Array<QuotationStatus>>;
};

export type NestedEnumReturnLocationFilter = {
  equals?: InputMaybe<ReturnLocation>;
  in?: InputMaybe<Array<ReturnLocation>>;
  not?: InputMaybe<NestedEnumReturnLocationFilter>;
  notIn?: InputMaybe<Array<ReturnLocation>>;
};

export type NestedEnumReturnStatusFilter = {
  equals?: InputMaybe<ReturnStatus>;
  in?: InputMaybe<Array<ReturnStatus>>;
  not?: InputMaybe<NestedEnumReturnStatusFilter>;
  notIn?: InputMaybe<Array<ReturnStatus>>;
};

export type NestedEnumSaleChannelFilter = {
  equals?: InputMaybe<SaleChannel>;
  in?: InputMaybe<Array<SaleChannel>>;
  not?: InputMaybe<NestedEnumSaleChannelFilter>;
  notIn?: InputMaybe<Array<SaleChannel>>;
};

export type NestedEnumSaleStatusFilter = {
  equals?: InputMaybe<SaleStatus>;
  in?: InputMaybe<Array<SaleStatus>>;
  not?: InputMaybe<NestedEnumSaleStatusFilter>;
  notIn?: InputMaybe<Array<SaleStatus>>;
};

export type NestedEnumSaleTypeFilter = {
  equals?: InputMaybe<SaleType>;
  in?: InputMaybe<Array<SaleType>>;
  not?: InputMaybe<NestedEnumSaleTypeFilter>;
  notIn?: InputMaybe<Array<SaleType>>;
};

export type NestedEnumSupplierQuoteStatusFilter = {
  equals?: InputMaybe<SupplierQuoteStatus>;
  in?: InputMaybe<Array<SupplierQuoteStatus>>;
  not?: InputMaybe<NestedEnumSupplierQuoteStatusFilter>;
  notIn?: InputMaybe<Array<SupplierQuoteStatus>>;
};

export type NestedEnumTransferStatusFilter = {
  equals?: InputMaybe<TransferStatus>;
  in?: InputMaybe<Array<TransferStatus>>;
  not?: InputMaybe<NestedEnumTransferStatusFilter>;
  notIn?: InputMaybe<Array<TransferStatus>>;
};

export type NestedEnumUserTierFilter = {
  equals?: InputMaybe<UserTier>;
  in?: InputMaybe<Array<UserTier>>;
  not?: InputMaybe<NestedEnumUserTierFilter>;
  notIn?: InputMaybe<Array<UserTier>>;
};

export type NestedEnumUserTierNullableFilter = {
  equals?: InputMaybe<UserTier>;
  in?: InputMaybe<Array<UserTier>>;
  not?: InputMaybe<NestedEnumUserTierNullableFilter>;
  notIn?: InputMaybe<Array<UserTier>>;
};

export type NestedEnumUserTierNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedEnumUserTierNullableFilter>;
  _min?: InputMaybe<NestedEnumUserTierNullableFilter>;
  equals?: InputMaybe<UserTier>;
  in?: InputMaybe<Array<UserTier>>;
  not?: InputMaybe<NestedEnumUserTierNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<UserTier>>;
};

export type NestedFloatFilter = {
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type NestedFloatNullableFilter = {
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type NestedFloatWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatFilter>;
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedFloatFilter>;
  _min?: InputMaybe<NestedFloatFilter>;
  _sum?: InputMaybe<NestedFloatFilter>;
  equals?: InputMaybe<Scalars['Float']['input']>;
  gt?: InputMaybe<Scalars['Float']['input']>;
  gte?: InputMaybe<Scalars['Float']['input']>;
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  lt?: InputMaybe<Scalars['Float']['input']>;
  lte?: InputMaybe<Scalars['Float']['input']>;
  not?: InputMaybe<NestedFloatWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type NestedIntFilter = {
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type NestedIntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type NestedIntNullableWithAggregatesFilter = {
  _avg?: InputMaybe<NestedFloatNullableFilter>;
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedIntNullableFilter>;
  _min?: InputMaybe<NestedIntNullableFilter>;
  _sum?: InputMaybe<NestedIntNullableFilter>;
  equals?: InputMaybe<Scalars['Int']['input']>;
  gt?: InputMaybe<Scalars['Int']['input']>;
  gte?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  lt?: InputMaybe<Scalars['Int']['input']>;
  lte?: InputMaybe<Scalars['Int']['input']>;
  not?: InputMaybe<NestedIntNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type NestedJsonNullableFilter = {
  array_contains?: InputMaybe<Scalars['JSON']['input']>;
  array_ends_with?: InputMaybe<Scalars['JSON']['input']>;
  array_starts_with?: InputMaybe<Scalars['JSON']['input']>;
  equals?: InputMaybe<Scalars['JSON']['input']>;
  gt?: InputMaybe<Scalars['JSON']['input']>;
  gte?: InputMaybe<Scalars['JSON']['input']>;
  lt?: InputMaybe<Scalars['JSON']['input']>;
  lte?: InputMaybe<Scalars['JSON']['input']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<Scalars['JSON']['input']>;
  path?: InputMaybe<Array<Scalars['String']['input']>>;
  string_contains?: InputMaybe<Scalars['String']['input']>;
  string_ends_with?: InputMaybe<Scalars['String']['input']>;
  string_starts_with?: InputMaybe<Scalars['String']['input']>;
};

export type NestedStringFilter = {
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type NestedStringNullableFilter = {
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type NestedStringNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedStringNullableFilter>;
  _min?: InputMaybe<NestedStringNullableFilter>;
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type NestedStringWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedStringFilter>;
  _min?: InputMaybe<NestedStringFilter>;
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  not?: InputMaybe<NestedStringWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type Notification = {
  __typename?: 'Notification';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  isRead: Scalars['Boolean']['output'];
  message: Scalars['String']['output'];
  type: Scalars['String']['output'];
  user: User;
  userId: Scalars['String']['output'];
};

export type NotificationCreateManyUserInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message: Scalars['String']['input'];
  type: Scalars['String']['input'];
};

export type NotificationCreateManyUserInputEnvelope = {
  data: Array<NotificationCreateManyUserInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type NotificationCreateNestedManyWithoutUserInput = {
  connect?: InputMaybe<Array<NotificationWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<NotificationCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<NotificationCreateWithoutUserInput>>;
  createMany?: InputMaybe<NotificationCreateManyUserInputEnvelope>;
};

export type NotificationCreateOrConnectWithoutUserInput = {
  create: NotificationCreateWithoutUserInput;
  where: NotificationWhereUniqueInput;
};

export type NotificationCreateWithoutUserInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message: Scalars['String']['input'];
  type: Scalars['String']['input'];
};

export type NotificationListRelationFilter = {
  every?: InputMaybe<NotificationWhereInput>;
  none?: InputMaybe<NotificationWhereInput>;
  some?: InputMaybe<NotificationWhereInput>;
};

export type NotificationOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type NotificationScalarWhereInput = {
  AND?: InputMaybe<Array<NotificationScalarWhereInput>>;
  NOT?: InputMaybe<Array<NotificationScalarWhereInput>>;
  OR?: InputMaybe<Array<NotificationScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  isRead?: InputMaybe<BoolFilter>;
  message?: InputMaybe<StringFilter>;
  type?: InputMaybe<StringFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type NotificationUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isRead?: InputMaybe<BoolFieldUpdateOperationsInput>;
  message?: InputMaybe<StringFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type NotificationUpdateManyWithWhereWithoutUserInput = {
  data: NotificationUpdateManyMutationInput;
  where: NotificationScalarWhereInput;
};

export type NotificationUpdateManyWithoutUserNestedInput = {
  connect?: InputMaybe<Array<NotificationWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<NotificationCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<NotificationCreateWithoutUserInput>>;
  createMany?: InputMaybe<NotificationCreateManyUserInputEnvelope>;
  delete?: InputMaybe<Array<NotificationWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<NotificationScalarWhereInput>>;
  disconnect?: InputMaybe<Array<NotificationWhereUniqueInput>>;
  set?: InputMaybe<Array<NotificationWhereUniqueInput>>;
  update?: InputMaybe<Array<NotificationUpdateWithWhereUniqueWithoutUserInput>>;
  updateMany?: InputMaybe<Array<NotificationUpdateManyWithWhereWithoutUserInput>>;
  upsert?: InputMaybe<Array<NotificationUpsertWithWhereUniqueWithoutUserInput>>;
};

export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
  data: NotificationUpdateWithoutUserInput;
  where: NotificationWhereUniqueInput;
};

export type NotificationUpdateWithoutUserInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isRead?: InputMaybe<BoolFieldUpdateOperationsInput>;
  message?: InputMaybe<StringFieldUpdateOperationsInput>;
  type?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
  create: NotificationCreateWithoutUserInput;
  update: NotificationUpdateWithoutUserInput;
  where: NotificationWhereUniqueInput;
};

export type NotificationWhereInput = {
  AND?: InputMaybe<Array<NotificationWhereInput>>;
  NOT?: InputMaybe<Array<NotificationWhereInput>>;
  OR?: InputMaybe<Array<NotificationWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  isRead?: InputMaybe<BoolFilter>;
  message?: InputMaybe<StringFilter>;
  type?: InputMaybe<StringFilter>;
  user?: InputMaybe<UserScalarRelationFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type NotificationWhereUniqueInput = {
  AND?: InputMaybe<Array<NotificationWhereInput>>;
  NOT?: InputMaybe<Array<NotificationWhereInput>>;
  OR?: InputMaybe<Array<NotificationWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  isRead?: InputMaybe<BoolFilter>;
  message?: InputMaybe<StringFilter>;
  type?: InputMaybe<StringFilter>;
  user?: InputMaybe<UserScalarRelationFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['DateTime']['input']>;
};

export type NullableEnumAdjustmentTypeFieldUpdateOperationsInput = {
  set?: InputMaybe<AdjustmentType>;
};

export type NullableEnumUserTierFieldUpdateOperationsInput = {
  set?: InputMaybe<UserTier>;
};

export type NullableFloatFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Float']['input']>;
  divide?: InputMaybe<Scalars['Float']['input']>;
  increment?: InputMaybe<Scalars['Float']['input']>;
  multiply?: InputMaybe<Scalars['Float']['input']>;
  set?: InputMaybe<Scalars['Float']['input']>;
};

export type NullableIntFieldUpdateOperationsInput = {
  decrement?: InputMaybe<Scalars['Int']['input']>;
  divide?: InputMaybe<Scalars['Int']['input']>;
  increment?: InputMaybe<Scalars['Int']['input']>;
  multiply?: InputMaybe<Scalars['Int']['input']>;
  set?: InputMaybe<Scalars['Int']['input']>;
};

export type NullableStringFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['String']['input']>;
};

export enum NullsOrder {
  First = 'first',
  Last = 'last'
}

export enum OrderPhase {
  Fulfillment = 'FULFILLMENT',
  Quotation = 'QUOTATION',
  Sale = 'SALE'
}

export type OrphanVariantDiagnostic = {
  __typename?: 'OrphanVariantDiagnostic';
  barcode?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  productExists: Scalars['Boolean']['output'];
  productId?: Maybe<Scalars['String']['output']>;
};

export type OutboxDayStatus = {
  __typename?: 'OutboxDayStatus';
  date: Scalars['String']['output'];
  failed: Scalars['Int']['output'];
  pending: Scalars['Int']['output'];
  published: Scalars['Int']['output'];
};

export type OutboxEvent = {
  __typename?: 'OutboxEvent';
  aggregateId?: Maybe<Scalars['String']['output']>;
  aggregateType?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  deliverAfter?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  lastError?: Maybe<Scalars['String']['output']>;
  payload: Scalars['JSON']['output'];
  retryCount: Scalars['Int']['output'];
  status: OutboxStatus;
  type: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export enum OutboxStatus {
  Failed = 'FAILED',
  Pending = 'PENDING',
  Processing = 'PROCESSING',
  Published = 'PUBLISHED'
}

export type OutboxStatusCounts = {
  __typename?: 'OutboxStatusCounts';
  failed: Scalars['Int']['output'];
  pending: Scalars['Int']['output'];
  published: Scalars['Int']['output'];
};

export type OutboxTypeCount = {
  __typename?: 'OutboxTypeCount';
  failed: Scalars['Int']['output'];
  pending: Scalars['Int']['output'];
  published: Scalars['Int']['output'];
  type: Scalars['String']['output'];
};

export type Payment = {
  __typename?: 'Payment';
  amount: Scalars['Float']['output'];
  id: Scalars['ID']['output'];
  method: PaymentMethod;
  receivedAt: Scalars['DateTime']['output'];
  receivedBy: User;
  receivedById: Scalars['String']['output'];
  referenceEntity: Scalars['String']['output'];
  referenceId: Scalars['String']['output'];
  sourceId: Scalars['String']['output'];
  type: PaymentType;
};

export type PaymentCreateManyReceivedByInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  referenceEntity: Scalars['String']['input'];
  referenceId: Scalars['String']['input'];
  sourceId: Scalars['String']['input'];
  type: PaymentType;
};

export type PaymentCreateManyReceivedByInputEnvelope = {
  data: Array<PaymentCreateManyReceivedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PaymentCreateNestedManyWithoutReceivedByInput = {
  connect?: InputMaybe<Array<PaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PaymentCreateOrConnectWithoutReceivedByInput>>;
  create?: InputMaybe<Array<PaymentCreateWithoutReceivedByInput>>;
  createMany?: InputMaybe<PaymentCreateManyReceivedByInputEnvelope>;
};

export type PaymentCreateOrConnectWithoutReceivedByInput = {
  create: PaymentCreateWithoutReceivedByInput;
  where: PaymentWhereUniqueInput;
};

export type PaymentCreateWithoutReceivedByInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  referenceEntity: Scalars['String']['input'];
  referenceId: Scalars['String']['input'];
  sourceId: Scalars['String']['input'];
  type: PaymentType;
};

export type PaymentDaySeries = {
  __typename?: 'PaymentDaySeries';
  consumerPaid: Scalars['Float']['output'];
  date: Scalars['String']['output'];
  resellerPaid: Scalars['Float']['output'];
  totalPaid: Scalars['Float']['output'];
};

export type PaymentListRelationFilter = {
  every?: InputMaybe<PaymentWhereInput>;
  none?: InputMaybe<PaymentWhereInput>;
  some?: InputMaybe<PaymentWhereInput>;
};

export enum PaymentMethod {
  Bank = 'BANK',
  Card = 'CARD',
  Cash = 'CASH',
  Mixed = 'MIXED',
  Transfer = 'TRANSFER',
  Wallet = 'WALLET'
}

export type PaymentMethodBreakdownEntry = {
  __typename?: 'PaymentMethodBreakdownEntry';
  consumerCount: Scalars['Int']['output'];
  consumerPaid: Scalars['Float']['output'];
  method: PaymentMethod;
  resellerCount: Scalars['Int']['output'];
  resellerPaid: Scalars['Float']['output'];
  totalPaid: Scalars['Float']['output'];
};

export type PaymentOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type PaymentOrderSummary = {
  __typename?: 'PaymentOrderSummary';
  consumerPaid: Scalars['Float']['output'];
  fullyPaid: Scalars['Boolean']['output'];
  orderTotal: Scalars['Float']['output'];
  outstanding: Scalars['Float']['output'];
  resellerPaid: Scalars['Float']['output'];
  saleOrderId: Scalars['String']['output'];
  totalPaid: Scalars['Float']['output'];
};

export type PaymentScalarWhereInput = {
  AND?: InputMaybe<Array<PaymentScalarWhereInput>>;
  NOT?: InputMaybe<Array<PaymentScalarWhereInput>>;
  OR?: InputMaybe<Array<PaymentScalarWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  id?: InputMaybe<StringFilter>;
  method?: InputMaybe<EnumPaymentMethodFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  receivedById?: InputMaybe<StringFilter>;
  referenceEntity?: InputMaybe<StringFilter>;
  referenceId?: InputMaybe<StringFilter>;
  sourceId?: InputMaybe<StringFilter>;
  type?: InputMaybe<EnumPaymentTypeFilter>;
};

export enum PaymentStatus {
  Confirmed = 'CONFIRMED',
  Failed = 'FAILED',
  Pending = 'PENDING'
}

export enum PaymentType {
  Consumer = 'CONSUMER',
  Reseller = 'RESELLER',
  Supplier = 'SUPPLIER'
}

export type PaymentUpdateManyMutationInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<EnumPaymentMethodFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  referenceEntity?: InputMaybe<StringFieldUpdateOperationsInput>;
  referenceId?: InputMaybe<StringFieldUpdateOperationsInput>;
  sourceId?: InputMaybe<StringFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumPaymentTypeFieldUpdateOperationsInput>;
};

export type PaymentUpdateManyWithWhereWithoutReceivedByInput = {
  data: PaymentUpdateManyMutationInput;
  where: PaymentScalarWhereInput;
};

export type PaymentUpdateManyWithoutReceivedByNestedInput = {
  connect?: InputMaybe<Array<PaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PaymentCreateOrConnectWithoutReceivedByInput>>;
  create?: InputMaybe<Array<PaymentCreateWithoutReceivedByInput>>;
  createMany?: InputMaybe<PaymentCreateManyReceivedByInputEnvelope>;
  delete?: InputMaybe<Array<PaymentWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PaymentScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PaymentWhereUniqueInput>>;
  set?: InputMaybe<Array<PaymentWhereUniqueInput>>;
  update?: InputMaybe<Array<PaymentUpdateWithWhereUniqueWithoutReceivedByInput>>;
  updateMany?: InputMaybe<Array<PaymentUpdateManyWithWhereWithoutReceivedByInput>>;
  upsert?: InputMaybe<Array<PaymentUpsertWithWhereUniqueWithoutReceivedByInput>>;
};

export type PaymentUpdateWithWhereUniqueWithoutReceivedByInput = {
  data: PaymentUpdateWithoutReceivedByInput;
  where: PaymentWhereUniqueInput;
};

export type PaymentUpdateWithoutReceivedByInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<EnumPaymentMethodFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  referenceEntity?: InputMaybe<StringFieldUpdateOperationsInput>;
  referenceId?: InputMaybe<StringFieldUpdateOperationsInput>;
  sourceId?: InputMaybe<StringFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumPaymentTypeFieldUpdateOperationsInput>;
};

export type PaymentUpsertWithWhereUniqueWithoutReceivedByInput = {
  create: PaymentCreateWithoutReceivedByInput;
  update: PaymentUpdateWithoutReceivedByInput;
  where: PaymentWhereUniqueInput;
};

export type PaymentWhereInput = {
  AND?: InputMaybe<Array<PaymentWhereInput>>;
  NOT?: InputMaybe<Array<PaymentWhereInput>>;
  OR?: InputMaybe<Array<PaymentWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  id?: InputMaybe<StringFilter>;
  method?: InputMaybe<EnumPaymentMethodFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  receivedBy?: InputMaybe<UserScalarRelationFilter>;
  receivedById?: InputMaybe<StringFilter>;
  referenceEntity?: InputMaybe<StringFilter>;
  referenceId?: InputMaybe<StringFilter>;
  sourceId?: InputMaybe<StringFilter>;
  type?: InputMaybe<EnumPaymentTypeFilter>;
};

export type PaymentWhereUniqueInput = {
  AND?: InputMaybe<Array<PaymentWhereInput>>;
  NOT?: InputMaybe<Array<PaymentWhereInput>>;
  OR?: InputMaybe<Array<PaymentWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  method?: InputMaybe<EnumPaymentMethodFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  receivedBy?: InputMaybe<UserScalarRelationFilter>;
  receivedById?: InputMaybe<StringFilter>;
  referenceEntity?: InputMaybe<StringFilter>;
  referenceId?: InputMaybe<StringFilter>;
  sourceId?: InputMaybe<StringFilter>;
  type?: InputMaybe<EnumPaymentTypeFilter>;
};

export type Permission = {
  __typename?: 'Permission';
  _count: PermissionCount;
  action: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  module: Scalars['String']['output'];
  name: Scalars['String']['output'];
  roles?: Maybe<Array<Role>>;
};

export type PermissionCount = {
  __typename?: 'PermissionCount';
  roles: Scalars['Int']['output'];
};

export type PermissionCreateNestedManyWithoutRolesInput = {
  connect?: InputMaybe<Array<PermissionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PermissionCreateOrConnectWithoutRolesInput>>;
  create?: InputMaybe<Array<PermissionCreateWithoutRolesInput>>;
};

export type PermissionCreateOrConnectWithoutRolesInput = {
  create: PermissionCreateWithoutRolesInput;
  where: PermissionWhereUniqueInput;
};

export type PermissionCreateWithoutRolesInput = {
  action: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  module: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type PermissionListRelationFilter = {
  every?: InputMaybe<PermissionWhereInput>;
  none?: InputMaybe<PermissionWhereInput>;
  some?: InputMaybe<PermissionWhereInput>;
};

export type PermissionOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type PermissionScalarWhereInput = {
  AND?: InputMaybe<Array<PermissionScalarWhereInput>>;
  NOT?: InputMaybe<Array<PermissionScalarWhereInput>>;
  OR?: InputMaybe<Array<PermissionScalarWhereInput>>;
  action?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  module?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
};

export type PermissionUpdateManyMutationInput = {
  action?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  module?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type PermissionUpdateManyWithWhereWithoutRolesInput = {
  data: PermissionUpdateManyMutationInput;
  where: PermissionScalarWhereInput;
};

export type PermissionUpdateManyWithoutRolesNestedInput = {
  connect?: InputMaybe<Array<PermissionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PermissionCreateOrConnectWithoutRolesInput>>;
  create?: InputMaybe<Array<PermissionCreateWithoutRolesInput>>;
  delete?: InputMaybe<Array<PermissionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PermissionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PermissionWhereUniqueInput>>;
  set?: InputMaybe<Array<PermissionWhereUniqueInput>>;
  update?: InputMaybe<Array<PermissionUpdateWithWhereUniqueWithoutRolesInput>>;
  updateMany?: InputMaybe<Array<PermissionUpdateManyWithWhereWithoutRolesInput>>;
  upsert?: InputMaybe<Array<PermissionUpsertWithWhereUniqueWithoutRolesInput>>;
};

export type PermissionUpdateWithWhereUniqueWithoutRolesInput = {
  data: PermissionUpdateWithoutRolesInput;
  where: PermissionWhereUniqueInput;
};

export type PermissionUpdateWithoutRolesInput = {
  action?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  module?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type PermissionUpsertWithWhereUniqueWithoutRolesInput = {
  create: PermissionCreateWithoutRolesInput;
  update: PermissionUpdateWithoutRolesInput;
  where: PermissionWhereUniqueInput;
};

export type PermissionWhereInput = {
  AND?: InputMaybe<Array<PermissionWhereInput>>;
  NOT?: InputMaybe<Array<PermissionWhereInput>>;
  OR?: InputMaybe<Array<PermissionWhereInput>>;
  action?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  module?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  roles?: InputMaybe<RoleListRelationFilter>;
};

export type PermissionWhereUniqueInput = {
  AND?: InputMaybe<Array<PermissionWhereInput>>;
  NOT?: InputMaybe<Array<PermissionWhereInput>>;
  OR?: InputMaybe<Array<PermissionWhereInput>>;
  action?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  module?: InputMaybe<StringFilter>;
  name?: InputMaybe<Scalars['String']['input']>;
  roles?: InputMaybe<RoleListRelationFilter>;
};

export type ProcessInvoiceResult = {
  __typename?: 'ProcessInvoiceResult';
  invoiceNumber?: Maybe<Scalars['String']['output']>;
  lines: Array<IngestLineResult>;
  message?: Maybe<Scalars['String']['output']>;
  purchaseOrderId?: Maybe<Scalars['String']['output']>;
  status: Scalars['String']['output'];
  supplierId?: Maybe<Scalars['String']['output']>;
  supplierName?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

export type ProcessInvoiceUrlInput = {
  confirmedById?: InputMaybe<Scalars['String']['input']>;
  createPurchaseOrder?: InputMaybe<Scalars['Boolean']['input']>;
  createSupplierPayment?: InputMaybe<Scalars['Boolean']['input']>;
  receiveStock?: InputMaybe<Scalars['Boolean']['input']>;
  receivedById?: InputMaybe<Scalars['String']['input']>;
  storeId?: InputMaybe<Scalars['String']['input']>;
  supplierName?: InputMaybe<Scalars['String']['input']>;
  url: Scalars['String']['input'];
};

export type Product = {
  __typename?: 'Product';
  _count: ProductCount;
  barcode?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  facets?: Maybe<Array<ProductFacetValue>>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  variants?: Maybe<Array<ProductVariant>>;
};

export type ProductCount = {
  __typename?: 'ProductCount';
  facets: Scalars['Int']['output'];
  variants: Scalars['Int']['output'];
};

export type ProductCountAggregate = {
  __typename?: 'ProductCountAggregate';
  _all: Scalars['Int']['output'];
  barcode: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  description: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  name: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
};

export type ProductCountAggregateInput = {
  _all?: InputMaybe<Scalars['Boolean']['input']>;
  barcode?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductCountOrderByAggregateInput = {
  barcode?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type ProductCreateInput = {
  barcode?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  facets?: InputMaybe<ProductFacetValueCreateNestedManyWithoutProductInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  variants?: InputMaybe<ProductVariantCreateNestedManyWithoutProductInput>;
};

export type ProductCreateManyInput = {
  barcode?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductCreateNestedOneWithoutFacetsInput = {
  connect?: InputMaybe<ProductWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductCreateOrConnectWithoutFacetsInput>;
  create?: InputMaybe<ProductCreateWithoutFacetsInput>;
};

export type ProductCreateNestedOneWithoutVariantsInput = {
  connect?: InputMaybe<ProductWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductCreateOrConnectWithoutVariantsInput>;
  create?: InputMaybe<ProductCreateWithoutVariantsInput>;
};

export type ProductCreateOrConnectWithoutFacetsInput = {
  create: ProductCreateWithoutFacetsInput;
  where: ProductWhereUniqueInput;
};

export type ProductCreateOrConnectWithoutVariantsInput = {
  create: ProductCreateWithoutVariantsInput;
  where: ProductWhereUniqueInput;
};

export type ProductCreateWithoutFacetsInput = {
  barcode?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  variants?: InputMaybe<ProductVariantCreateNestedManyWithoutProductInput>;
};

export type ProductCreateWithoutVariantsInput = {
  barcode?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  facets?: InputMaybe<ProductFacetValueCreateNestedManyWithoutProductInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductFacetValue = {
  __typename?: 'ProductFacetValue';
  facet: Facet;
  facetId: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  product: Product;
  productId: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type ProductFacetValueCreateManyFacetInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productId: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ProductFacetValueCreateManyFacetInputEnvelope = {
  data: Array<ProductFacetValueCreateManyFacetInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductFacetValueCreateManyProductInput = {
  facetId: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export type ProductFacetValueCreateManyProductInputEnvelope = {
  data: Array<ProductFacetValueCreateManyProductInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductFacetValueCreateNestedManyWithoutFacetInput = {
  connect?: InputMaybe<Array<ProductFacetValueWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductFacetValueCreateOrConnectWithoutFacetInput>>;
  create?: InputMaybe<Array<ProductFacetValueCreateWithoutFacetInput>>;
  createMany?: InputMaybe<ProductFacetValueCreateManyFacetInputEnvelope>;
};

export type ProductFacetValueCreateNestedManyWithoutProductInput = {
  connect?: InputMaybe<Array<ProductFacetValueWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductFacetValueCreateOrConnectWithoutProductInput>>;
  create?: InputMaybe<Array<ProductFacetValueCreateWithoutProductInput>>;
  createMany?: InputMaybe<ProductFacetValueCreateManyProductInputEnvelope>;
};

export type ProductFacetValueCreateOrConnectWithoutFacetInput = {
  create: ProductFacetValueCreateWithoutFacetInput;
  where: ProductFacetValueWhereUniqueInput;
};

export type ProductFacetValueCreateOrConnectWithoutProductInput = {
  create: ProductFacetValueCreateWithoutProductInput;
  where: ProductFacetValueWhereUniqueInput;
};

export type ProductFacetValueCreateWithoutFacetInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  product: ProductCreateNestedOneWithoutFacetsInput;
  value: Scalars['String']['input'];
};

export type ProductFacetValueCreateWithoutProductInput = {
  facet: FacetCreateNestedOneWithoutProductsInput;
  id?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export type ProductFacetValueListRelationFilter = {
  every?: InputMaybe<ProductFacetValueWhereInput>;
  none?: InputMaybe<ProductFacetValueWhereInput>;
  some?: InputMaybe<ProductFacetValueWhereInput>;
};

export type ProductFacetValueOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ProductFacetValueProduct_Facet_Value_UniqueCompoundUniqueInput = {
  facetId: Scalars['String']['input'];
  productId: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type ProductFacetValueScalarWhereInput = {
  AND?: InputMaybe<Array<ProductFacetValueScalarWhereInput>>;
  NOT?: InputMaybe<Array<ProductFacetValueScalarWhereInput>>;
  OR?: InputMaybe<Array<ProductFacetValueScalarWhereInput>>;
  facetId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  productId?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
};

export type ProductFacetValueUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ProductFacetValueUpdateManyWithWhereWithoutFacetInput = {
  data: ProductFacetValueUpdateManyMutationInput;
  where: ProductFacetValueScalarWhereInput;
};

export type ProductFacetValueUpdateManyWithWhereWithoutProductInput = {
  data: ProductFacetValueUpdateManyMutationInput;
  where: ProductFacetValueScalarWhereInput;
};

export type ProductFacetValueUpdateManyWithoutFacetNestedInput = {
  connect?: InputMaybe<Array<ProductFacetValueWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductFacetValueCreateOrConnectWithoutFacetInput>>;
  create?: InputMaybe<Array<ProductFacetValueCreateWithoutFacetInput>>;
  createMany?: InputMaybe<ProductFacetValueCreateManyFacetInputEnvelope>;
  delete?: InputMaybe<Array<ProductFacetValueWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ProductFacetValueScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ProductFacetValueWhereUniqueInput>>;
  set?: InputMaybe<Array<ProductFacetValueWhereUniqueInput>>;
  update?: InputMaybe<Array<ProductFacetValueUpdateWithWhereUniqueWithoutFacetInput>>;
  updateMany?: InputMaybe<Array<ProductFacetValueUpdateManyWithWhereWithoutFacetInput>>;
  upsert?: InputMaybe<Array<ProductFacetValueUpsertWithWhereUniqueWithoutFacetInput>>;
};

export type ProductFacetValueUpdateManyWithoutProductNestedInput = {
  connect?: InputMaybe<Array<ProductFacetValueWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductFacetValueCreateOrConnectWithoutProductInput>>;
  create?: InputMaybe<Array<ProductFacetValueCreateWithoutProductInput>>;
  createMany?: InputMaybe<ProductFacetValueCreateManyProductInputEnvelope>;
  delete?: InputMaybe<Array<ProductFacetValueWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ProductFacetValueScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ProductFacetValueWhereUniqueInput>>;
  set?: InputMaybe<Array<ProductFacetValueWhereUniqueInput>>;
  update?: InputMaybe<Array<ProductFacetValueUpdateWithWhereUniqueWithoutProductInput>>;
  updateMany?: InputMaybe<Array<ProductFacetValueUpdateManyWithWhereWithoutProductInput>>;
  upsert?: InputMaybe<Array<ProductFacetValueUpsertWithWhereUniqueWithoutProductInput>>;
};

export type ProductFacetValueUpdateWithWhereUniqueWithoutFacetInput = {
  data: ProductFacetValueUpdateWithoutFacetInput;
  where: ProductFacetValueWhereUniqueInput;
};

export type ProductFacetValueUpdateWithWhereUniqueWithoutProductInput = {
  data: ProductFacetValueUpdateWithoutProductInput;
  where: ProductFacetValueWhereUniqueInput;
};

export type ProductFacetValueUpdateWithoutFacetInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneRequiredWithoutFacetsNestedInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ProductFacetValueUpdateWithoutProductInput = {
  facet?: InputMaybe<FacetUpdateOneRequiredWithoutProductsNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type ProductFacetValueUpsertWithWhereUniqueWithoutFacetInput = {
  create: ProductFacetValueCreateWithoutFacetInput;
  update: ProductFacetValueUpdateWithoutFacetInput;
  where: ProductFacetValueWhereUniqueInput;
};

export type ProductFacetValueUpsertWithWhereUniqueWithoutProductInput = {
  create: ProductFacetValueCreateWithoutProductInput;
  update: ProductFacetValueUpdateWithoutProductInput;
  where: ProductFacetValueWhereUniqueInput;
};

export type ProductFacetValueWhereInput = {
  AND?: InputMaybe<Array<ProductFacetValueWhereInput>>;
  NOT?: InputMaybe<Array<ProductFacetValueWhereInput>>;
  OR?: InputMaybe<Array<ProductFacetValueWhereInput>>;
  facet?: InputMaybe<FacetScalarRelationFilter>;
  facetId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  product?: InputMaybe<ProductScalarRelationFilter>;
  productId?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
};

export type ProductFacetValueWhereUniqueInput = {
  AND?: InputMaybe<Array<ProductFacetValueWhereInput>>;
  NOT?: InputMaybe<Array<ProductFacetValueWhereInput>>;
  OR?: InputMaybe<Array<ProductFacetValueWhereInput>>;
  facet?: InputMaybe<FacetScalarRelationFilter>;
  facetId?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  product?: InputMaybe<ProductScalarRelationFilter>;
  productId?: InputMaybe<StringFilter>;
  product_facet_value_unique?: InputMaybe<ProductFacetValueProduct_Facet_Value_UniqueCompoundUniqueInput>;
  value?: InputMaybe<StringFilter>;
};

export type ProductGroupBy = {
  __typename?: 'ProductGroupBy';
  _count?: Maybe<ProductCountAggregate>;
  _max?: Maybe<ProductMaxAggregate>;
  _min?: Maybe<ProductMinAggregate>;
  barcode?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type ProductMaxAggregate = {
  __typename?: 'ProductMaxAggregate';
  barcode?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ProductMaxAggregateInput = {
  barcode?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductMaxOrderByAggregateInput = {
  barcode?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type ProductMinAggregate = {
  __typename?: 'ProductMinAggregate';
  barcode?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ProductMinAggregateInput = {
  barcode?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductMinOrderByAggregateInput = {
  barcode?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type ProductNullableScalarRelationFilter = {
  is?: InputMaybe<ProductWhereInput>;
  isNot?: InputMaybe<ProductWhereInput>;
};

export type ProductOrderByWithAggregationInput = {
  _count?: InputMaybe<ProductCountOrderByAggregateInput>;
  _max?: InputMaybe<ProductMaxOrderByAggregateInput>;
  _min?: InputMaybe<ProductMinOrderByAggregateInput>;
  barcode?: InputMaybe<SortOrderInput>;
  createdAt?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrderInput>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type ProductOrderByWithRelationInput = {
  barcode?: InputMaybe<SortOrderInput>;
  createdAt?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrderInput>;
  facets?: InputMaybe<ProductFacetValueOrderByRelationAggregateInput>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  variants?: InputMaybe<ProductVariantOrderByRelationAggregateInput>;
};

export type ProductSalesStats = {
  __typename?: 'ProductSalesStats';
  id: Scalars['ID']['output'];
  lastSoldAt?: Maybe<Scalars['DateTime']['output']>;
  monthlySales: Scalars['JSON']['output'];
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  totalReturned: Scalars['Int']['output'];
  totalSold: Scalars['Int']['output'];
};

export type ProductSalesStatsCreateNestedOneWithoutProductVariantInput = {
  connect?: InputMaybe<ProductSalesStatsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductSalesStatsCreateOrConnectWithoutProductVariantInput>;
  create?: InputMaybe<ProductSalesStatsCreateWithoutProductVariantInput>;
};

export type ProductSalesStatsCreateOrConnectWithoutProductVariantInput = {
  create: ProductSalesStatsCreateWithoutProductVariantInput;
  where: ProductSalesStatsWhereUniqueInput;
};

export type ProductSalesStatsCreateWithoutProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  lastSoldAt?: InputMaybe<Scalars['DateTime']['input']>;
  monthlySales: Scalars['JSON']['input'];
  totalReturned?: InputMaybe<Scalars['Int']['input']>;
  totalSold?: InputMaybe<Scalars['Int']['input']>;
};

export type ProductSalesStatsNullableScalarRelationFilter = {
  is?: InputMaybe<ProductSalesStatsWhereInput>;
  isNot?: InputMaybe<ProductSalesStatsWhereInput>;
};

export type ProductSalesStatsOrderByWithRelationInput = {
  id?: InputMaybe<SortOrder>;
  lastSoldAt?: InputMaybe<SortOrderInput>;
  monthlySales?: InputMaybe<SortOrder>;
  productVariant?: InputMaybe<ProductVariantOrderByWithRelationInput>;
  productVariantId?: InputMaybe<SortOrder>;
  totalReturned?: InputMaybe<SortOrder>;
  totalSold?: InputMaybe<SortOrder>;
};

export type ProductSalesStatsUpdateOneWithoutProductVariantNestedInput = {
  connect?: InputMaybe<ProductSalesStatsWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductSalesStatsCreateOrConnectWithoutProductVariantInput>;
  create?: InputMaybe<ProductSalesStatsCreateWithoutProductVariantInput>;
  delete?: InputMaybe<ProductSalesStatsWhereInput>;
  disconnect?: InputMaybe<ProductSalesStatsWhereInput>;
  update?: InputMaybe<ProductSalesStatsUpdateToOneWithWhereWithoutProductVariantInput>;
  upsert?: InputMaybe<ProductSalesStatsUpsertWithoutProductVariantInput>;
};

export type ProductSalesStatsUpdateToOneWithWhereWithoutProductVariantInput = {
  data: ProductSalesStatsUpdateWithoutProductVariantInput;
  where?: InputMaybe<ProductSalesStatsWhereInput>;
};

export type ProductSalesStatsUpdateWithoutProductVariantInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  lastSoldAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  monthlySales?: InputMaybe<Scalars['JSON']['input']>;
  totalReturned?: InputMaybe<IntFieldUpdateOperationsInput>;
  totalSold?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type ProductSalesStatsUpsertWithoutProductVariantInput = {
  create: ProductSalesStatsCreateWithoutProductVariantInput;
  update: ProductSalesStatsUpdateWithoutProductVariantInput;
  where?: InputMaybe<ProductSalesStatsWhereInput>;
};

export type ProductSalesStatsWhereInput = {
  AND?: InputMaybe<Array<ProductSalesStatsWhereInput>>;
  NOT?: InputMaybe<Array<ProductSalesStatsWhereInput>>;
  OR?: InputMaybe<Array<ProductSalesStatsWhereInput>>;
  id?: InputMaybe<StringFilter>;
  lastSoldAt?: InputMaybe<DateTimeNullableFilter>;
  monthlySales?: InputMaybe<JsonFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  totalReturned?: InputMaybe<IntFilter>;
  totalSold?: InputMaybe<IntFilter>;
};

export type ProductSalesStatsWhereUniqueInput = {
  AND?: InputMaybe<Array<ProductSalesStatsWhereInput>>;
  NOT?: InputMaybe<Array<ProductSalesStatsWhereInput>>;
  OR?: InputMaybe<Array<ProductSalesStatsWhereInput>>;
  id?: InputMaybe<Scalars['String']['input']>;
  lastSoldAt?: InputMaybe<DateTimeNullableFilter>;
  monthlySales?: InputMaybe<JsonFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<Scalars['String']['input']>;
  totalReturned?: InputMaybe<IntFilter>;
  totalSold?: InputMaybe<IntFilter>;
};

export enum ProductScalarFieldEnum {
  Barcode = 'barcode',
  CreatedAt = 'createdAt',
  Description = 'description',
  Id = 'id',
  Name = 'name',
  UpdatedAt = 'updatedAt'
}

export type ProductScalarRelationFilter = {
  is?: InputMaybe<ProductWhereInput>;
  isNot?: InputMaybe<ProductWhereInput>;
};

export type ProductScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ProductScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ProductScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ProductScalarWhereWithAggregatesInput>>;
  barcode?: InputMaybe<StringNullableWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  description?: InputMaybe<StringNullableWithAggregatesFilter>;
  id?: InputMaybe<StringWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type ProductUpdateInput = {
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  facets?: InputMaybe<ProductFacetValueUpdateManyWithoutProductNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  variants?: InputMaybe<ProductVariantUpdateManyWithoutProductNestedInput>;
};

export type ProductUpdateManyMutationInput = {
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductUpdateOneRequiredWithoutFacetsNestedInput = {
  connect?: InputMaybe<ProductWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductCreateOrConnectWithoutFacetsInput>;
  create?: InputMaybe<ProductCreateWithoutFacetsInput>;
  update?: InputMaybe<ProductUpdateToOneWithWhereWithoutFacetsInput>;
  upsert?: InputMaybe<ProductUpsertWithoutFacetsInput>;
};

export type ProductUpdateOneWithoutVariantsNestedInput = {
  connect?: InputMaybe<ProductWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductCreateOrConnectWithoutVariantsInput>;
  create?: InputMaybe<ProductCreateWithoutVariantsInput>;
  delete?: InputMaybe<ProductWhereInput>;
  disconnect?: InputMaybe<ProductWhereInput>;
  update?: InputMaybe<ProductUpdateToOneWithWhereWithoutVariantsInput>;
  upsert?: InputMaybe<ProductUpsertWithoutVariantsInput>;
};

export type ProductUpdateToOneWithWhereWithoutFacetsInput = {
  data: ProductUpdateWithoutFacetsInput;
  where?: InputMaybe<ProductWhereInput>;
};

export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
  data: ProductUpdateWithoutVariantsInput;
  where?: InputMaybe<ProductWhereInput>;
};

export type ProductUpdateWithoutFacetsInput = {
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  variants?: InputMaybe<ProductVariantUpdateManyWithoutProductNestedInput>;
};

export type ProductUpdateWithoutVariantsInput = {
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  facets?: InputMaybe<ProductFacetValueUpdateManyWithoutProductNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductUpsertWithoutFacetsInput = {
  create: ProductCreateWithoutFacetsInput;
  update: ProductUpdateWithoutFacetsInput;
  where?: InputMaybe<ProductWhereInput>;
};

export type ProductUpsertWithoutVariantsInput = {
  create: ProductCreateWithoutVariantsInput;
  update: ProductUpdateWithoutVariantsInput;
  where?: InputMaybe<ProductWhereInput>;
};

export type ProductVariant = {
  __typename?: 'ProductVariant';
  ProductVariantTierPrice?: Maybe<Array<ProductVariantTierPrice>>;
  PurchaseOrderItem?: Maybe<Array<PurchaseOrderItem>>;
  PurchaseRequisitionItem?: Maybe<Array<PurchaseRequisitionItem>>;
  StockMovementItem?: Maybe<Array<StockMovementItem>>;
  SupplierCatalog?: Maybe<Array<SupplierCatalog>>;
  SupplierQuoteItem?: Maybe<Array<SupplierQuoteItem>>;
  _count: ProductVariantCount;
  barcode?: Maybe<Scalars['String']['output']>;
  consumerItems?: Maybe<Array<ConsumerSaleItem>>;
  createdAt: Scalars['DateTime']['output'];
  facets?: Maybe<Array<VariantFacetValue>>;
  id: Scalars['ID']['output'];
  legacyArticleCode?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  price: Scalars['Float']['output'];
  product?: Maybe<Product>;
  productId?: Maybe<Scalars['String']['output']>;
  purchaseReturnItems?: Maybe<Array<PurchaseReturnItem>>;
  quotationItems?: Maybe<Array<QuotationItem>>;
  receiptItems?: Maybe<Array<StockReceiptBatchItem>>;
  resellerItems?: Maybe<Array<ResellerSaleItem>>;
  resellerPrice: Scalars['Float']['output'];
  returnItems?: Maybe<Array<SalesReturnItem>>;
  stats?: Maybe<ProductSalesStats>;
  stockItems?: Maybe<Array<Stock>>;
  transferItems?: Maybe<Array<StockTransferItem>>;
  updatedAt: Scalars['DateTime']['output'];
};

export type ProductVariantAvgAggregate = {
  __typename?: 'ProductVariantAvgAggregate';
  price?: Maybe<Scalars['Float']['output']>;
  resellerPrice?: Maybe<Scalars['Float']['output']>;
};

export type ProductVariantAvgAggregateInput = {
  price?: InputMaybe<Scalars['Boolean']['input']>;
  resellerPrice?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductVariantAvgOrderByAggregateInput = {
  price?: InputMaybe<SortOrder>;
  resellerPrice?: InputMaybe<SortOrder>;
};

export type ProductVariantCount = {
  __typename?: 'ProductVariantCount';
  ProductVariantTierPrice: Scalars['Int']['output'];
  PurchaseOrderItem: Scalars['Int']['output'];
  PurchaseRequisitionItem: Scalars['Int']['output'];
  StockMovementItem: Scalars['Int']['output'];
  SupplierCatalog: Scalars['Int']['output'];
  SupplierQuoteItem: Scalars['Int']['output'];
  consumerItems: Scalars['Int']['output'];
  facets: Scalars['Int']['output'];
  purchaseReturnItems: Scalars['Int']['output'];
  quotationItems: Scalars['Int']['output'];
  receiptItems: Scalars['Int']['output'];
  resellerItems: Scalars['Int']['output'];
  returnItems: Scalars['Int']['output'];
  stockItems: Scalars['Int']['output'];
  transferItems: Scalars['Int']['output'];
};

export type ProductVariantCountAggregate = {
  __typename?: 'ProductVariantCountAggregate';
  _all: Scalars['Int']['output'];
  barcode: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  legacyArticleCode: Scalars['Int']['output'];
  name: Scalars['Int']['output'];
  price: Scalars['Int']['output'];
  productId: Scalars['Int']['output'];
  resellerPrice: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
};

export type ProductVariantCountAggregateInput = {
  _all?: InputMaybe<Scalars['Boolean']['input']>;
  barcode?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['Boolean']['input']>;
  price?: InputMaybe<Scalars['Boolean']['input']>;
  productId?: InputMaybe<Scalars['Boolean']['input']>;
  resellerPrice?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductVariantCountOrderByAggregateInput = {
  barcode?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  legacyArticleCode?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  price?: InputMaybe<SortOrder>;
  productId?: InputMaybe<SortOrder>;
  resellerPrice?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type ProductVariantCreateInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateManyInput = {
  barcode?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  productId?: InputMaybe<Scalars['String']['input']>;
  resellerPrice: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateManyProductInput = {
  barcode?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  resellerPrice: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateManyProductInputEnvelope = {
  data: Array<ProductVariantCreateManyProductInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductVariantCreateNestedManyWithoutProductInput = {
  connect?: InputMaybe<Array<ProductVariantWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductVariantCreateOrConnectWithoutProductInput>>;
  create?: InputMaybe<Array<ProductVariantCreateWithoutProductInput>>;
  createMany?: InputMaybe<ProductVariantCreateManyProductInputEnvelope>;
};

export type ProductVariantCreateNestedOneWithoutConsumerItemsInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutConsumerItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutConsumerItemsInput>;
};

export type ProductVariantCreateNestedOneWithoutFacetsInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutFacetsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutFacetsInput>;
};

export type ProductVariantCreateNestedOneWithoutPurchaseOrderItemInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutPurchaseOrderItemInput>;
  create?: InputMaybe<ProductVariantCreateWithoutPurchaseOrderItemInput>;
};

export type ProductVariantCreateNestedOneWithoutPurchaseRequisitionItemInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutPurchaseRequisitionItemInput>;
  create?: InputMaybe<ProductVariantCreateWithoutPurchaseRequisitionItemInput>;
};

export type ProductVariantCreateNestedOneWithoutPurchaseReturnItemsInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutPurchaseReturnItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutPurchaseReturnItemsInput>;
};

export type ProductVariantCreateNestedOneWithoutQuotationItemsInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutQuotationItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutQuotationItemsInput>;
};

export type ProductVariantCreateNestedOneWithoutReceiptItemsInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutReceiptItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutReceiptItemsInput>;
};

export type ProductVariantCreateNestedOneWithoutResellerItemsInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutResellerItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutResellerItemsInput>;
};

export type ProductVariantCreateNestedOneWithoutReturnItemsInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutReturnItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutReturnItemsInput>;
};

export type ProductVariantCreateNestedOneWithoutStockItemsInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutStockItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutStockItemsInput>;
};

export type ProductVariantCreateNestedOneWithoutStockMovementItemInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutStockMovementItemInput>;
  create?: InputMaybe<ProductVariantCreateWithoutStockMovementItemInput>;
};

export type ProductVariantCreateNestedOneWithoutSupplierCatalogInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutSupplierCatalogInput>;
  create?: InputMaybe<ProductVariantCreateWithoutSupplierCatalogInput>;
};

export type ProductVariantCreateNestedOneWithoutSupplierQuoteItemInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutSupplierQuoteItemInput>;
  create?: InputMaybe<ProductVariantCreateWithoutSupplierQuoteItemInput>;
};

export type ProductVariantCreateNestedOneWithoutTransferItemsInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutTransferItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutTransferItemsInput>;
};

export type ProductVariantCreateOrConnectWithoutConsumerItemsInput = {
  create: ProductVariantCreateWithoutConsumerItemsInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutFacetsInput = {
  create: ProductVariantCreateWithoutFacetsInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutProductInput = {
  create: ProductVariantCreateWithoutProductInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutPurchaseOrderItemInput = {
  create: ProductVariantCreateWithoutPurchaseOrderItemInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutPurchaseRequisitionItemInput = {
  create: ProductVariantCreateWithoutPurchaseRequisitionItemInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutPurchaseReturnItemsInput = {
  create: ProductVariantCreateWithoutPurchaseReturnItemsInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutQuotationItemsInput = {
  create: ProductVariantCreateWithoutQuotationItemsInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutReceiptItemsInput = {
  create: ProductVariantCreateWithoutReceiptItemsInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutResellerItemsInput = {
  create: ProductVariantCreateWithoutResellerItemsInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutReturnItemsInput = {
  create: ProductVariantCreateWithoutReturnItemsInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutStockItemsInput = {
  create: ProductVariantCreateWithoutStockItemsInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutStockMovementItemInput = {
  create: ProductVariantCreateWithoutStockMovementItemInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutSupplierCatalogInput = {
  create: ProductVariantCreateWithoutSupplierCatalogInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutSupplierQuoteItemInput = {
  create: ProductVariantCreateWithoutSupplierQuoteItemInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateOrConnectWithoutTransferItemsInput = {
  create: ProductVariantCreateWithoutTransferItemsInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantCreateWithoutConsumerItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutFacetsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutProductInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutPurchaseOrderItemInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutPurchaseRequisitionItemInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutPurchaseReturnItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutQuotationItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutReceiptItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutResellerItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutReturnItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutStockItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutStockMovementItemInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutSupplierCatalogInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutSupplierQuoteItemInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  transferItems?: InputMaybe<StockTransferItemCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantCreateWithoutTransferItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceCreateNestedManyWithoutVariantInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutProductVariantInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput>;
  StockMovementItem?: InputMaybe<StockMovementItemCreateNestedManyWithoutProductVariantInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogCreateNestedManyWithoutProductVariantInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutProductVariantInput>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemCreateNestedManyWithoutProductVariantInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  facets?: InputMaybe<VariantFacetValueCreateNestedManyWithoutVariantInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  product?: InputMaybe<ProductCreateNestedOneWithoutVariantsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutProductVariantInput>;
  quotationItems?: InputMaybe<QuotationItemCreateNestedManyWithoutProductVariantInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput>;
  resellerItems?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutProductVariantInput>;
  resellerPrice: Scalars['Float']['input'];
  returnItems?: InputMaybe<SalesReturnItemCreateNestedManyWithoutProductVariantInput>;
  stats?: InputMaybe<ProductSalesStatsCreateNestedOneWithoutProductVariantInput>;
  stockItems?: InputMaybe<StockCreateNestedManyWithoutProductVariantInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ProductVariantGroupBy = {
  __typename?: 'ProductVariantGroupBy';
  _avg?: Maybe<ProductVariantAvgAggregate>;
  _count?: Maybe<ProductVariantCountAggregate>;
  _max?: Maybe<ProductVariantMaxAggregate>;
  _min?: Maybe<ProductVariantMinAggregate>;
  _sum?: Maybe<ProductVariantSumAggregate>;
  barcode?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['String']['output'];
  legacyArticleCode?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  price: Scalars['Float']['output'];
  productId?: Maybe<Scalars['String']['output']>;
  resellerPrice: Scalars['Float']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type ProductVariantListRelationFilter = {
  every?: InputMaybe<ProductVariantWhereInput>;
  none?: InputMaybe<ProductVariantWhereInput>;
  some?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantMaxAggregate = {
  __typename?: 'ProductVariantMaxAggregate';
  barcode?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  legacyArticleCode?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  productId?: Maybe<Scalars['String']['output']>;
  resellerPrice?: Maybe<Scalars['Float']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ProductVariantMaxAggregateInput = {
  barcode?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['Boolean']['input']>;
  price?: InputMaybe<Scalars['Boolean']['input']>;
  productId?: InputMaybe<Scalars['Boolean']['input']>;
  resellerPrice?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductVariantMaxOrderByAggregateInput = {
  barcode?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  legacyArticleCode?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  price?: InputMaybe<SortOrder>;
  productId?: InputMaybe<SortOrder>;
  resellerPrice?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type ProductVariantMinAggregate = {
  __typename?: 'ProductVariantMinAggregate';
  barcode?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  legacyArticleCode?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  price?: Maybe<Scalars['Float']['output']>;
  productId?: Maybe<Scalars['String']['output']>;
  resellerPrice?: Maybe<Scalars['Float']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ProductVariantMinAggregateInput = {
  barcode?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['Boolean']['input']>;
  price?: InputMaybe<Scalars['Boolean']['input']>;
  productId?: InputMaybe<Scalars['Boolean']['input']>;
  resellerPrice?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductVariantMinOrderByAggregateInput = {
  barcode?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  legacyArticleCode?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  price?: InputMaybe<SortOrder>;
  productId?: InputMaybe<SortOrder>;
  resellerPrice?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type ProductVariantOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ProductVariantOrderByWithAggregationInput = {
  _avg?: InputMaybe<ProductVariantAvgOrderByAggregateInput>;
  _count?: InputMaybe<ProductVariantCountOrderByAggregateInput>;
  _max?: InputMaybe<ProductVariantMaxOrderByAggregateInput>;
  _min?: InputMaybe<ProductVariantMinOrderByAggregateInput>;
  _sum?: InputMaybe<ProductVariantSumOrderByAggregateInput>;
  barcode?: InputMaybe<SortOrderInput>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  legacyArticleCode?: InputMaybe<SortOrderInput>;
  name?: InputMaybe<SortOrderInput>;
  price?: InputMaybe<SortOrder>;
  productId?: InputMaybe<SortOrderInput>;
  resellerPrice?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type ProductVariantOrderByWithRelationInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceOrderByRelationAggregateInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemOrderByRelationAggregateInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemOrderByRelationAggregateInput>;
  StockMovementItem?: InputMaybe<StockMovementItemOrderByRelationAggregateInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogOrderByRelationAggregateInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemOrderByRelationAggregateInput>;
  barcode?: InputMaybe<SortOrderInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemOrderByRelationAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  facets?: InputMaybe<VariantFacetValueOrderByRelationAggregateInput>;
  id?: InputMaybe<SortOrder>;
  legacyArticleCode?: InputMaybe<SortOrderInput>;
  name?: InputMaybe<SortOrderInput>;
  price?: InputMaybe<SortOrder>;
  product?: InputMaybe<ProductOrderByWithRelationInput>;
  productId?: InputMaybe<SortOrderInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemOrderByRelationAggregateInput>;
  quotationItems?: InputMaybe<QuotationItemOrderByRelationAggregateInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemOrderByRelationAggregateInput>;
  resellerItems?: InputMaybe<ResellerSaleItemOrderByRelationAggregateInput>;
  resellerPrice?: InputMaybe<SortOrder>;
  returnItems?: InputMaybe<SalesReturnItemOrderByRelationAggregateInput>;
  stats?: InputMaybe<ProductSalesStatsOrderByWithRelationInput>;
  stockItems?: InputMaybe<StockOrderByRelationAggregateInput>;
  transferItems?: InputMaybe<StockTransferItemOrderByRelationAggregateInput>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum ProductVariantScalarFieldEnum {
  Barcode = 'barcode',
  CreatedAt = 'createdAt',
  Id = 'id',
  LegacyArticleCode = 'legacyArticleCode',
  Name = 'name',
  Price = 'price',
  ProductId = 'productId',
  ResellerPrice = 'resellerPrice',
  UpdatedAt = 'updatedAt'
}

export type ProductVariantScalarRelationFilter = {
  is?: InputMaybe<ProductVariantWhereInput>;
  isNot?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantScalarWhereInput = {
  AND?: InputMaybe<Array<ProductVariantScalarWhereInput>>;
  NOT?: InputMaybe<Array<ProductVariantScalarWhereInput>>;
  OR?: InputMaybe<Array<ProductVariantScalarWhereInput>>;
  barcode?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  legacyArticleCode?: InputMaybe<StringNullableFilter>;
  name?: InputMaybe<StringNullableFilter>;
  price?: InputMaybe<FloatFilter>;
  productId?: InputMaybe<StringNullableFilter>;
  resellerPrice?: InputMaybe<FloatFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type ProductVariantScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<ProductVariantScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<ProductVariantScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<ProductVariantScalarWhereWithAggregatesInput>>;
  barcode?: InputMaybe<StringNullableWithAggregatesFilter>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<StringWithAggregatesFilter>;
  legacyArticleCode?: InputMaybe<StringNullableWithAggregatesFilter>;
  name?: InputMaybe<StringNullableWithAggregatesFilter>;
  price?: InputMaybe<FloatWithAggregatesFilter>;
  productId?: InputMaybe<StringNullableWithAggregatesFilter>;
  resellerPrice?: InputMaybe<FloatWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type ProductVariantSumAggregate = {
  __typename?: 'ProductVariantSumAggregate';
  price?: Maybe<Scalars['Float']['output']>;
  resellerPrice?: Maybe<Scalars['Float']['output']>;
};

export type ProductVariantSumAggregateInput = {
  price?: InputMaybe<Scalars['Boolean']['input']>;
  resellerPrice?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductVariantSumOrderByAggregateInput = {
  price?: InputMaybe<SortOrder>;
  resellerPrice?: InputMaybe<SortOrder>;
};

export type ProductVariantTierPrice = {
  __typename?: 'ProductVariantTierPrice';
  id: Scalars['ID']['output'];
  price: Scalars['Float']['output'];
  productVariantId: Scalars['String']['output'];
  tier: UserTier;
  variant: ProductVariant;
};

export type ProductVariantTierPriceCreateManyVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  tier: UserTier;
};

export type ProductVariantTierPriceCreateManyVariantInputEnvelope = {
  data: Array<ProductVariantTierPriceCreateManyVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ProductVariantTierPriceCreateNestedManyWithoutVariantInput = {
  connect?: InputMaybe<Array<ProductVariantTierPriceWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductVariantTierPriceCreateOrConnectWithoutVariantInput>>;
  create?: InputMaybe<Array<ProductVariantTierPriceCreateWithoutVariantInput>>;
  createMany?: InputMaybe<ProductVariantTierPriceCreateManyVariantInputEnvelope>;
};

export type ProductVariantTierPriceCreateOrConnectWithoutVariantInput = {
  create: ProductVariantTierPriceCreateWithoutVariantInput;
  where: ProductVariantTierPriceWhereUniqueInput;
};

export type ProductVariantTierPriceCreateWithoutVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  price: Scalars['Float']['input'];
  tier: UserTier;
};

export type ProductVariantTierPriceListRelationFilter = {
  every?: InputMaybe<ProductVariantTierPriceWhereInput>;
  none?: InputMaybe<ProductVariantTierPriceWhereInput>;
  some?: InputMaybe<ProductVariantTierPriceWhereInput>;
};

export type ProductVariantTierPriceOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ProductVariantTierPriceProductVariantIdTierCompoundUniqueInput = {
  productVariantId: Scalars['String']['input'];
  tier: UserTier;
};

export type ProductVariantTierPriceScalarWhereInput = {
  AND?: InputMaybe<Array<ProductVariantTierPriceScalarWhereInput>>;
  NOT?: InputMaybe<Array<ProductVariantTierPriceScalarWhereInput>>;
  OR?: InputMaybe<Array<ProductVariantTierPriceScalarWhereInput>>;
  id?: InputMaybe<StringFilter>;
  price?: InputMaybe<FloatFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  tier?: InputMaybe<EnumUserTierFilter>;
};

export type ProductVariantTierPriceUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  tier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
};

export type ProductVariantTierPriceUpdateManyWithWhereWithoutVariantInput = {
  data: ProductVariantTierPriceUpdateManyMutationInput;
  where: ProductVariantTierPriceScalarWhereInput;
};

export type ProductVariantTierPriceUpdateManyWithoutVariantNestedInput = {
  connect?: InputMaybe<Array<ProductVariantTierPriceWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductVariantTierPriceCreateOrConnectWithoutVariantInput>>;
  create?: InputMaybe<Array<ProductVariantTierPriceCreateWithoutVariantInput>>;
  createMany?: InputMaybe<ProductVariantTierPriceCreateManyVariantInputEnvelope>;
  delete?: InputMaybe<Array<ProductVariantTierPriceWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ProductVariantTierPriceScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ProductVariantTierPriceWhereUniqueInput>>;
  set?: InputMaybe<Array<ProductVariantTierPriceWhereUniqueInput>>;
  update?: InputMaybe<Array<ProductVariantTierPriceUpdateWithWhereUniqueWithoutVariantInput>>;
  updateMany?: InputMaybe<Array<ProductVariantTierPriceUpdateManyWithWhereWithoutVariantInput>>;
  upsert?: InputMaybe<Array<ProductVariantTierPriceUpsertWithWhereUniqueWithoutVariantInput>>;
};

export type ProductVariantTierPriceUpdateWithWhereUniqueWithoutVariantInput = {
  data: ProductVariantTierPriceUpdateWithoutVariantInput;
  where: ProductVariantTierPriceWhereUniqueInput;
};

export type ProductVariantTierPriceUpdateWithoutVariantInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  tier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
};

export type ProductVariantTierPriceUpsertWithWhereUniqueWithoutVariantInput = {
  create: ProductVariantTierPriceCreateWithoutVariantInput;
  update: ProductVariantTierPriceUpdateWithoutVariantInput;
  where: ProductVariantTierPriceWhereUniqueInput;
};

export type ProductVariantTierPriceWhereInput = {
  AND?: InputMaybe<Array<ProductVariantTierPriceWhereInput>>;
  NOT?: InputMaybe<Array<ProductVariantTierPriceWhereInput>>;
  OR?: InputMaybe<Array<ProductVariantTierPriceWhereInput>>;
  id?: InputMaybe<StringFilter>;
  price?: InputMaybe<FloatFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  tier?: InputMaybe<EnumUserTierFilter>;
  variant?: InputMaybe<ProductVariantScalarRelationFilter>;
};

export type ProductVariantTierPriceWhereUniqueInput = {
  AND?: InputMaybe<Array<ProductVariantTierPriceWhereInput>>;
  NOT?: InputMaybe<Array<ProductVariantTierPriceWhereInput>>;
  OR?: InputMaybe<Array<ProductVariantTierPriceWhereInput>>;
  id?: InputMaybe<Scalars['String']['input']>;
  price?: InputMaybe<FloatFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  productVariantId_tier?: InputMaybe<ProductVariantTierPriceProductVariantIdTierCompoundUniqueInput>;
  tier?: InputMaybe<EnumUserTierFilter>;
  variant?: InputMaybe<ProductVariantScalarRelationFilter>;
};

export type ProductVariantUpdateInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateManyMutationInput = {
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateManyWithWhereWithoutProductInput = {
  data: ProductVariantUpdateManyMutationInput;
  where: ProductVariantScalarWhereInput;
};

export type ProductVariantUpdateManyWithoutProductNestedInput = {
  connect?: InputMaybe<Array<ProductVariantWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ProductVariantCreateOrConnectWithoutProductInput>>;
  create?: InputMaybe<Array<ProductVariantCreateWithoutProductInput>>;
  createMany?: InputMaybe<ProductVariantCreateManyProductInputEnvelope>;
  delete?: InputMaybe<Array<ProductVariantWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ProductVariantScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ProductVariantWhereUniqueInput>>;
  set?: InputMaybe<Array<ProductVariantWhereUniqueInput>>;
  update?: InputMaybe<Array<ProductVariantUpdateWithWhereUniqueWithoutProductInput>>;
  updateMany?: InputMaybe<Array<ProductVariantUpdateManyWithWhereWithoutProductInput>>;
  upsert?: InputMaybe<Array<ProductVariantUpsertWithWhereUniqueWithoutProductInput>>;
};

export type ProductVariantUpdateOneRequiredWithoutConsumerItemsNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutConsumerItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutConsumerItemsInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutConsumerItemsInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutConsumerItemsInput>;
};

export type ProductVariantUpdateOneRequiredWithoutFacetsNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutFacetsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutFacetsInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutFacetsInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutFacetsInput>;
};

export type ProductVariantUpdateOneRequiredWithoutPurchaseOrderItemNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutPurchaseOrderItemInput>;
  create?: InputMaybe<ProductVariantCreateWithoutPurchaseOrderItemInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutPurchaseOrderItemInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutPurchaseOrderItemInput>;
};

export type ProductVariantUpdateOneRequiredWithoutPurchaseRequisitionItemNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutPurchaseRequisitionItemInput>;
  create?: InputMaybe<ProductVariantCreateWithoutPurchaseRequisitionItemInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutPurchaseRequisitionItemInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutPurchaseRequisitionItemInput>;
};

export type ProductVariantUpdateOneRequiredWithoutPurchaseReturnItemsNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutPurchaseReturnItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutPurchaseReturnItemsInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutPurchaseReturnItemsInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutPurchaseReturnItemsInput>;
};

export type ProductVariantUpdateOneRequiredWithoutQuotationItemsNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutQuotationItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutQuotationItemsInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutQuotationItemsInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutQuotationItemsInput>;
};

export type ProductVariantUpdateOneRequiredWithoutReceiptItemsNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutReceiptItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutReceiptItemsInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutReceiptItemsInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutReceiptItemsInput>;
};

export type ProductVariantUpdateOneRequiredWithoutResellerItemsNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutResellerItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutResellerItemsInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutResellerItemsInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutResellerItemsInput>;
};

export type ProductVariantUpdateOneRequiredWithoutReturnItemsNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutReturnItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutReturnItemsInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutReturnItemsInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutReturnItemsInput>;
};

export type ProductVariantUpdateOneRequiredWithoutStockItemsNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutStockItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutStockItemsInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutStockItemsInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutStockItemsInput>;
};

export type ProductVariantUpdateOneRequiredWithoutStockMovementItemNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutStockMovementItemInput>;
  create?: InputMaybe<ProductVariantCreateWithoutStockMovementItemInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutStockMovementItemInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutStockMovementItemInput>;
};

export type ProductVariantUpdateOneRequiredWithoutSupplierCatalogNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutSupplierCatalogInput>;
  create?: InputMaybe<ProductVariantCreateWithoutSupplierCatalogInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutSupplierCatalogInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutSupplierCatalogInput>;
};

export type ProductVariantUpdateOneRequiredWithoutSupplierQuoteItemNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutSupplierQuoteItemInput>;
  create?: InputMaybe<ProductVariantCreateWithoutSupplierQuoteItemInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutSupplierQuoteItemInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutSupplierQuoteItemInput>;
};

export type ProductVariantUpdateOneRequiredWithoutTransferItemsNestedInput = {
  connect?: InputMaybe<ProductVariantWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ProductVariantCreateOrConnectWithoutTransferItemsInput>;
  create?: InputMaybe<ProductVariantCreateWithoutTransferItemsInput>;
  update?: InputMaybe<ProductVariantUpdateToOneWithWhereWithoutTransferItemsInput>;
  upsert?: InputMaybe<ProductVariantUpsertWithoutTransferItemsInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutConsumerItemsInput = {
  data: ProductVariantUpdateWithoutConsumerItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutFacetsInput = {
  data: ProductVariantUpdateWithoutFacetsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutPurchaseOrderItemInput = {
  data: ProductVariantUpdateWithoutPurchaseOrderItemInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutPurchaseRequisitionItemInput = {
  data: ProductVariantUpdateWithoutPurchaseRequisitionItemInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutPurchaseReturnItemsInput = {
  data: ProductVariantUpdateWithoutPurchaseReturnItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutQuotationItemsInput = {
  data: ProductVariantUpdateWithoutQuotationItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutReceiptItemsInput = {
  data: ProductVariantUpdateWithoutReceiptItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutResellerItemsInput = {
  data: ProductVariantUpdateWithoutResellerItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutReturnItemsInput = {
  data: ProductVariantUpdateWithoutReturnItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutStockItemsInput = {
  data: ProductVariantUpdateWithoutStockItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutStockMovementItemInput = {
  data: ProductVariantUpdateWithoutStockMovementItemInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutSupplierCatalogInput = {
  data: ProductVariantUpdateWithoutSupplierCatalogInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutSupplierQuoteItemInput = {
  data: ProductVariantUpdateWithoutSupplierQuoteItemInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateToOneWithWhereWithoutTransferItemsInput = {
  data: ProductVariantUpdateWithoutTransferItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpdateWithWhereUniqueWithoutProductInput = {
  data: ProductVariantUpdateWithoutProductInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantUpdateWithoutConsumerItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutFacetsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutProductInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutPurchaseOrderItemInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutPurchaseRequisitionItemInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutPurchaseReturnItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutQuotationItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutReceiptItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutResellerItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutReturnItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutStockItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutStockMovementItemInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutSupplierCatalogInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutSupplierQuoteItemInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  transferItems?: InputMaybe<StockTransferItemUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpdateWithoutTransferItemsInput = {
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceUpdateManyWithoutVariantNestedInput>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput>;
  StockMovementItem?: InputMaybe<StockMovementItemUpdateManyWithoutProductVariantNestedInput>;
  SupplierCatalog?: InputMaybe<SupplierCatalogUpdateManyWithoutProductVariantNestedInput>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput>;
  barcode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  consumerItems?: InputMaybe<ConsumerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  facets?: InputMaybe<VariantFacetValueUpdateManyWithoutVariantNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  legacyArticleCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  price?: InputMaybe<FloatFieldUpdateOperationsInput>;
  product?: InputMaybe<ProductUpdateOneWithoutVariantsNestedInput>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput>;
  quotationItems?: InputMaybe<QuotationItemUpdateManyWithoutProductVariantNestedInput>;
  receiptItems?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput>;
  resellerItems?: InputMaybe<ResellerSaleItemUpdateManyWithoutProductVariantNestedInput>;
  resellerPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
  returnItems?: InputMaybe<SalesReturnItemUpdateManyWithoutProductVariantNestedInput>;
  stats?: InputMaybe<ProductSalesStatsUpdateOneWithoutProductVariantNestedInput>;
  stockItems?: InputMaybe<StockUpdateManyWithoutProductVariantNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ProductVariantUpsertWithWhereUniqueWithoutProductInput = {
  create: ProductVariantCreateWithoutProductInput;
  update: ProductVariantUpdateWithoutProductInput;
  where: ProductVariantWhereUniqueInput;
};

export type ProductVariantUpsertWithoutConsumerItemsInput = {
  create: ProductVariantCreateWithoutConsumerItemsInput;
  update: ProductVariantUpdateWithoutConsumerItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutFacetsInput = {
  create: ProductVariantCreateWithoutFacetsInput;
  update: ProductVariantUpdateWithoutFacetsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutPurchaseOrderItemInput = {
  create: ProductVariantCreateWithoutPurchaseOrderItemInput;
  update: ProductVariantUpdateWithoutPurchaseOrderItemInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutPurchaseRequisitionItemInput = {
  create: ProductVariantCreateWithoutPurchaseRequisitionItemInput;
  update: ProductVariantUpdateWithoutPurchaseRequisitionItemInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutPurchaseReturnItemsInput = {
  create: ProductVariantCreateWithoutPurchaseReturnItemsInput;
  update: ProductVariantUpdateWithoutPurchaseReturnItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutQuotationItemsInput = {
  create: ProductVariantCreateWithoutQuotationItemsInput;
  update: ProductVariantUpdateWithoutQuotationItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutReceiptItemsInput = {
  create: ProductVariantCreateWithoutReceiptItemsInput;
  update: ProductVariantUpdateWithoutReceiptItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutResellerItemsInput = {
  create: ProductVariantCreateWithoutResellerItemsInput;
  update: ProductVariantUpdateWithoutResellerItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutReturnItemsInput = {
  create: ProductVariantCreateWithoutReturnItemsInput;
  update: ProductVariantUpdateWithoutReturnItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutStockItemsInput = {
  create: ProductVariantCreateWithoutStockItemsInput;
  update: ProductVariantUpdateWithoutStockItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutStockMovementItemInput = {
  create: ProductVariantCreateWithoutStockMovementItemInput;
  update: ProductVariantUpdateWithoutStockMovementItemInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutSupplierCatalogInput = {
  create: ProductVariantCreateWithoutSupplierCatalogInput;
  update: ProductVariantUpdateWithoutSupplierCatalogInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutSupplierQuoteItemInput = {
  create: ProductVariantCreateWithoutSupplierQuoteItemInput;
  update: ProductVariantUpdateWithoutSupplierQuoteItemInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantUpsertWithoutTransferItemsInput = {
  create: ProductVariantCreateWithoutTransferItemsInput;
  update: ProductVariantUpdateWithoutTransferItemsInput;
  where?: InputMaybe<ProductVariantWhereInput>;
};

export type ProductVariantWhereInput = {
  AND?: InputMaybe<Array<ProductVariantWhereInput>>;
  NOT?: InputMaybe<Array<ProductVariantWhereInput>>;
  OR?: InputMaybe<Array<ProductVariantWhereInput>>;
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceListRelationFilter>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemListRelationFilter>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemListRelationFilter>;
  StockMovementItem?: InputMaybe<StockMovementItemListRelationFilter>;
  SupplierCatalog?: InputMaybe<SupplierCatalogListRelationFilter>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemListRelationFilter>;
  barcode?: InputMaybe<StringNullableFilter>;
  consumerItems?: InputMaybe<ConsumerSaleItemListRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  facets?: InputMaybe<VariantFacetValueListRelationFilter>;
  id?: InputMaybe<StringFilter>;
  legacyArticleCode?: InputMaybe<StringNullableFilter>;
  name?: InputMaybe<StringNullableFilter>;
  price?: InputMaybe<FloatFilter>;
  product?: InputMaybe<ProductNullableScalarRelationFilter>;
  productId?: InputMaybe<StringNullableFilter>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemListRelationFilter>;
  quotationItems?: InputMaybe<QuotationItemListRelationFilter>;
  receiptItems?: InputMaybe<StockReceiptBatchItemListRelationFilter>;
  resellerItems?: InputMaybe<ResellerSaleItemListRelationFilter>;
  resellerPrice?: InputMaybe<FloatFilter>;
  returnItems?: InputMaybe<SalesReturnItemListRelationFilter>;
  stats?: InputMaybe<ProductSalesStatsNullableScalarRelationFilter>;
  stockItems?: InputMaybe<StockListRelationFilter>;
  transferItems?: InputMaybe<StockTransferItemListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type ProductVariantWhereUniqueInput = {
  AND?: InputMaybe<Array<ProductVariantWhereInput>>;
  NOT?: InputMaybe<Array<ProductVariantWhereInput>>;
  OR?: InputMaybe<Array<ProductVariantWhereInput>>;
  ProductVariantTierPrice?: InputMaybe<ProductVariantTierPriceListRelationFilter>;
  PurchaseOrderItem?: InputMaybe<PurchaseOrderItemListRelationFilter>;
  PurchaseRequisitionItem?: InputMaybe<PurchaseRequisitionItemListRelationFilter>;
  StockMovementItem?: InputMaybe<StockMovementItemListRelationFilter>;
  SupplierCatalog?: InputMaybe<SupplierCatalogListRelationFilter>;
  SupplierQuoteItem?: InputMaybe<SupplierQuoteItemListRelationFilter>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  consumerItems?: InputMaybe<ConsumerSaleItemListRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  facets?: InputMaybe<VariantFacetValueListRelationFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  legacyArticleCode?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<StringNullableFilter>;
  price?: InputMaybe<FloatFilter>;
  product?: InputMaybe<ProductNullableScalarRelationFilter>;
  productId?: InputMaybe<StringNullableFilter>;
  purchaseReturnItems?: InputMaybe<PurchaseReturnItemListRelationFilter>;
  quotationItems?: InputMaybe<QuotationItemListRelationFilter>;
  receiptItems?: InputMaybe<StockReceiptBatchItemListRelationFilter>;
  resellerItems?: InputMaybe<ResellerSaleItemListRelationFilter>;
  resellerPrice?: InputMaybe<FloatFilter>;
  returnItems?: InputMaybe<SalesReturnItemListRelationFilter>;
  stats?: InputMaybe<ProductSalesStatsNullableScalarRelationFilter>;
  stockItems?: InputMaybe<StockListRelationFilter>;
  transferItems?: InputMaybe<StockTransferItemListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type ProductWhereInput = {
  AND?: InputMaybe<Array<ProductWhereInput>>;
  NOT?: InputMaybe<Array<ProductWhereInput>>;
  OR?: InputMaybe<Array<ProductWhereInput>>;
  barcode?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  description?: InputMaybe<StringNullableFilter>;
  facets?: InputMaybe<ProductFacetValueListRelationFilter>;
  id?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  variants?: InputMaybe<ProductVariantListRelationFilter>;
};

export type ProductWhereUniqueInput = {
  AND?: InputMaybe<Array<ProductWhereInput>>;
  NOT?: InputMaybe<Array<ProductWhereInput>>;
  OR?: InputMaybe<Array<ProductWhereInput>>;
  barcode?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<DateTimeFilter>;
  description?: InputMaybe<StringNullableFilter>;
  facets?: InputMaybe<ProductFacetValueListRelationFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  variants?: InputMaybe<ProductVariantListRelationFilter>;
};

export enum ProfileStatus {
  Active = 'ACTIVE',
  Pending = 'PENDING',
  Rejected = 'REJECTED'
}

export type PurchaseOrder = {
  __typename?: 'PurchaseOrder';
  _count: PurchaseOrderCount;
  createdAt: Scalars['DateTime']['output'];
  dueDate: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  invoiceNumber: Scalars['String']['output'];
  items?: Maybe<Array<PurchaseOrderItem>>;
  payments?: Maybe<Array<SupplierPayment>>;
  phase: PurchasePhase;
  receipts?: Maybe<Array<StockReceiptBatch>>;
  status: PurchaseOrderStatus;
  store?: Maybe<Store>;
  storeId?: Maybe<Scalars['String']['output']>;
  supplier: Supplier;
  supplierId: Scalars['String']['output'];
  totalAmount: Scalars['Float']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type PurchaseOrderAvgAggregate = {
  __typename?: 'PurchaseOrderAvgAggregate';
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

export type PurchaseOrderCount = {
  __typename?: 'PurchaseOrderCount';
  items: Scalars['Int']['output'];
  payments: Scalars['Int']['output'];
  receipts: Scalars['Int']['output'];
};

export type PurchaseOrderCountAggregate = {
  __typename?: 'PurchaseOrderCountAggregate';
  _all: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  dueDate: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  invoiceNumber: Scalars['Int']['output'];
  phase: Scalars['Int']['output'];
  status: Scalars['Int']['output'];
  storeId: Scalars['Int']['output'];
  supplierId: Scalars['Int']['output'];
  totalAmount: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
};

export type PurchaseOrderCreateManyStoreInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  dueDate: Scalars['DateTime']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  invoiceNumber: Scalars['String']['input'];
  phase?: InputMaybe<PurchasePhase>;
  status: PurchaseOrderStatus;
  supplierId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseOrderCreateManyStoreInputEnvelope = {
  data: Array<PurchaseOrderCreateManyStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseOrderCreateManySupplierInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  dueDate: Scalars['DateTime']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  invoiceNumber: Scalars['String']['input'];
  phase?: InputMaybe<PurchasePhase>;
  status: PurchaseOrderStatus;
  storeId?: InputMaybe<Scalars['String']['input']>;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseOrderCreateManySupplierInputEnvelope = {
  data: Array<PurchaseOrderCreateManySupplierInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseOrderCreateNestedManyWithoutReceiptsInput = {
  connect?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseOrderCreateOrConnectWithoutReceiptsInput>>;
  create?: InputMaybe<Array<PurchaseOrderCreateWithoutReceiptsInput>>;
};

export type PurchaseOrderCreateNestedManyWithoutStoreInput = {
  connect?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseOrderCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<PurchaseOrderCreateWithoutStoreInput>>;
  createMany?: InputMaybe<PurchaseOrderCreateManyStoreInputEnvelope>;
};

export type PurchaseOrderCreateNestedManyWithoutSupplierInput = {
  connect?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseOrderCreateOrConnectWithoutSupplierInput>>;
  create?: InputMaybe<Array<PurchaseOrderCreateWithoutSupplierInput>>;
  createMany?: InputMaybe<PurchaseOrderCreateManySupplierInputEnvelope>;
};

export type PurchaseOrderCreateNestedOneWithoutItemsInput = {
  connect?: InputMaybe<PurchaseOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PurchaseOrderCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<PurchaseOrderCreateWithoutItemsInput>;
};

export type PurchaseOrderCreateNestedOneWithoutPaymentsInput = {
  connect?: InputMaybe<PurchaseOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PurchaseOrderCreateOrConnectWithoutPaymentsInput>;
  create?: InputMaybe<PurchaseOrderCreateWithoutPaymentsInput>;
};

export type PurchaseOrderCreateOrConnectWithoutItemsInput = {
  create: PurchaseOrderCreateWithoutItemsInput;
  where: PurchaseOrderWhereUniqueInput;
};

export type PurchaseOrderCreateOrConnectWithoutPaymentsInput = {
  create: PurchaseOrderCreateWithoutPaymentsInput;
  where: PurchaseOrderWhereUniqueInput;
};

export type PurchaseOrderCreateOrConnectWithoutReceiptsInput = {
  create: PurchaseOrderCreateWithoutReceiptsInput;
  where: PurchaseOrderWhereUniqueInput;
};

export type PurchaseOrderCreateOrConnectWithoutStoreInput = {
  create: PurchaseOrderCreateWithoutStoreInput;
  where: PurchaseOrderWhereUniqueInput;
};

export type PurchaseOrderCreateOrConnectWithoutSupplierInput = {
  create: PurchaseOrderCreateWithoutSupplierInput;
  where: PurchaseOrderWhereUniqueInput;
};

export type PurchaseOrderCreateWithoutItemsInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  dueDate: Scalars['DateTime']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  invoiceNumber: Scalars['String']['input'];
  payments?: InputMaybe<SupplierPaymentCreateNestedManyWithoutPurchaseOrderInput>;
  phase?: InputMaybe<PurchasePhase>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutPurchaseOrderInput>;
  status: PurchaseOrderStatus;
  store?: InputMaybe<StoreCreateNestedOneWithoutPurchaseOrdersInput>;
  supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseOrderCreateWithoutPaymentsInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  dueDate: Scalars['DateTime']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  invoiceNumber: Scalars['String']['input'];
  items?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput>;
  phase?: InputMaybe<PurchasePhase>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutPurchaseOrderInput>;
  status: PurchaseOrderStatus;
  store?: InputMaybe<StoreCreateNestedOneWithoutPurchaseOrdersInput>;
  supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseOrderCreateWithoutReceiptsInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  dueDate: Scalars['DateTime']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  invoiceNumber: Scalars['String']['input'];
  items?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput>;
  payments?: InputMaybe<SupplierPaymentCreateNestedManyWithoutPurchaseOrderInput>;
  phase?: InputMaybe<PurchasePhase>;
  status: PurchaseOrderStatus;
  store?: InputMaybe<StoreCreateNestedOneWithoutPurchaseOrdersInput>;
  supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseOrderCreateWithoutStoreInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  dueDate: Scalars['DateTime']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  invoiceNumber: Scalars['String']['input'];
  items?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput>;
  payments?: InputMaybe<SupplierPaymentCreateNestedManyWithoutPurchaseOrderInput>;
  phase?: InputMaybe<PurchasePhase>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutPurchaseOrderInput>;
  status: PurchaseOrderStatus;
  supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseOrderCreateWithoutSupplierInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  dueDate: Scalars['DateTime']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  invoiceNumber: Scalars['String']['input'];
  items?: InputMaybe<PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput>;
  payments?: InputMaybe<SupplierPaymentCreateNestedManyWithoutPurchaseOrderInput>;
  phase?: InputMaybe<PurchasePhase>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutPurchaseOrderInput>;
  status: PurchaseOrderStatus;
  store?: InputMaybe<StoreCreateNestedOneWithoutPurchaseOrdersInput>;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseOrderItem = {
  __typename?: 'PurchaseOrderItem';
  id: Scalars['ID']['output'];
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  purchaseOrder: PurchaseOrder;
  purchaseOrderId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  unitCost: Scalars['Float']['output'];
};

export type PurchaseOrderItemCreateManyProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  purchaseOrderId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
  unitCost: Scalars['Float']['input'];
};

export type PurchaseOrderItemCreateManyProductVariantInputEnvelope = {
  data: Array<PurchaseOrderItemCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseOrderItemCreateManyPurchaseOrderInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
  unitCost: Scalars['Float']['input'];
};

export type PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope = {
  data: Array<PurchaseOrderItemCreateManyPurchaseOrderInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseOrderItemCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<PurchaseOrderItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseOrderItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<PurchaseOrderItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<PurchaseOrderItemCreateManyProductVariantInputEnvelope>;
};

export type PurchaseOrderItemCreateNestedManyWithoutPurchaseOrderInput = {
  connect?: InputMaybe<Array<PurchaseOrderItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput>>;
  create?: InputMaybe<Array<PurchaseOrderItemCreateWithoutPurchaseOrderInput>>;
  createMany?: InputMaybe<PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope>;
};

export type PurchaseOrderItemCreateOrConnectWithoutProductVariantInput = {
  create: PurchaseOrderItemCreateWithoutProductVariantInput;
  where: PurchaseOrderItemWhereUniqueInput;
};

export type PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput = {
  create: PurchaseOrderItemCreateWithoutPurchaseOrderInput;
  where: PurchaseOrderItemWhereUniqueInput;
};

export type PurchaseOrderItemCreateWithoutProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  purchaseOrder: PurchaseOrderCreateNestedOneWithoutItemsInput;
  quantity: Scalars['Int']['input'];
  unitCost: Scalars['Float']['input'];
};

export type PurchaseOrderItemCreateWithoutPurchaseOrderInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutPurchaseOrderItemInput;
  quantity: Scalars['Int']['input'];
  unitCost: Scalars['Float']['input'];
};

export type PurchaseOrderItemInput = {
  productVariantId: Scalars['ID']['input'];
  quantity: Scalars['Float']['input'];
  unitCost: Scalars['Float']['input'];
};

export type PurchaseOrderItemListRelationFilter = {
  every?: InputMaybe<PurchaseOrderItemWhereInput>;
  none?: InputMaybe<PurchaseOrderItemWhereInput>;
  some?: InputMaybe<PurchaseOrderItemWhereInput>;
};

export type PurchaseOrderItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type PurchaseOrderItemScalarWhereInput = {
  AND?: InputMaybe<Array<PurchaseOrderItemScalarWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseOrderItemScalarWhereInput>>;
  OR?: InputMaybe<Array<PurchaseOrderItemScalarWhereInput>>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  purchaseOrderId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  unitCost?: InputMaybe<FloatFilter>;
};

export type PurchaseOrderItemUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  unitCost?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type PurchaseOrderItemUpdateManyWithWhereWithoutProductVariantInput = {
  data: PurchaseOrderItemUpdateManyMutationInput;
  where: PurchaseOrderItemScalarWhereInput;
};

export type PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput = {
  data: PurchaseOrderItemUpdateManyMutationInput;
  where: PurchaseOrderItemScalarWhereInput;
};

export type PurchaseOrderItemUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<PurchaseOrderItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseOrderItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<PurchaseOrderItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<PurchaseOrderItemCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseOrderItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseOrderItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseOrderItemWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseOrderItemWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseOrderItemUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<PurchaseOrderItemUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<PurchaseOrderItemUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput = {
  connect?: InputMaybe<Array<PurchaseOrderItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseOrderItemCreateOrConnectWithoutPurchaseOrderInput>>;
  create?: InputMaybe<Array<PurchaseOrderItemCreateWithoutPurchaseOrderInput>>;
  createMany?: InputMaybe<PurchaseOrderItemCreateManyPurchaseOrderInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseOrderItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseOrderItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseOrderItemWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseOrderItemWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput>>;
  updateMany?: InputMaybe<Array<PurchaseOrderItemUpdateManyWithWhereWithoutPurchaseOrderInput>>;
  upsert?: InputMaybe<Array<PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput>>;
};

export type PurchaseOrderItemUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: PurchaseOrderItemUpdateWithoutProductVariantInput;
  where: PurchaseOrderItemWhereUniqueInput;
};

export type PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
  data: PurchaseOrderItemUpdateWithoutPurchaseOrderInput;
  where: PurchaseOrderItemWhereUniqueInput;
};

export type PurchaseOrderItemUpdateWithoutProductVariantInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrder?: InputMaybe<PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  unitCost?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type PurchaseOrderItemUpdateWithoutPurchaseOrderInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutPurchaseOrderItemNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  unitCost?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type PurchaseOrderItemUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: PurchaseOrderItemCreateWithoutProductVariantInput;
  update: PurchaseOrderItemUpdateWithoutProductVariantInput;
  where: PurchaseOrderItemWhereUniqueInput;
};

export type PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
  create: PurchaseOrderItemCreateWithoutPurchaseOrderInput;
  update: PurchaseOrderItemUpdateWithoutPurchaseOrderInput;
  where: PurchaseOrderItemWhereUniqueInput;
};

export type PurchaseOrderItemWhereInput = {
  AND?: InputMaybe<Array<PurchaseOrderItemWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseOrderItemWhereInput>>;
  OR?: InputMaybe<Array<PurchaseOrderItemWhereInput>>;
  id?: InputMaybe<StringFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  purchaseOrder?: InputMaybe<PurchaseOrderScalarRelationFilter>;
  purchaseOrderId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  unitCost?: InputMaybe<FloatFilter>;
};

export type PurchaseOrderItemWhereUniqueInput = {
  AND?: InputMaybe<Array<PurchaseOrderItemWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseOrderItemWhereInput>>;
  OR?: InputMaybe<Array<PurchaseOrderItemWhereInput>>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  purchaseOrder?: InputMaybe<PurchaseOrderScalarRelationFilter>;
  purchaseOrderId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  unitCost?: InputMaybe<FloatFilter>;
};

export type PurchaseOrderListRelationFilter = {
  every?: InputMaybe<PurchaseOrderWhereInput>;
  none?: InputMaybe<PurchaseOrderWhereInput>;
  some?: InputMaybe<PurchaseOrderWhereInput>;
};

export type PurchaseOrderMaxAggregate = {
  __typename?: 'PurchaseOrderMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  dueDate?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  invoiceNumber?: Maybe<Scalars['String']['output']>;
  phase?: Maybe<PurchasePhase>;
  status?: Maybe<PurchaseOrderStatus>;
  storeId?: Maybe<Scalars['String']['output']>;
  supplierId?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type PurchaseOrderMinAggregate = {
  __typename?: 'PurchaseOrderMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  dueDate?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  invoiceNumber?: Maybe<Scalars['String']['output']>;
  phase?: Maybe<PurchasePhase>;
  status?: Maybe<PurchaseOrderStatus>;
  storeId?: Maybe<Scalars['String']['output']>;
  supplierId?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type PurchaseOrderNullableScalarRelationFilter = {
  is?: InputMaybe<PurchaseOrderWhereInput>;
  isNot?: InputMaybe<PurchaseOrderWhereInput>;
};

export type PurchaseOrderOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type PurchaseOrderReceiptProgress = {
  __typename?: 'PurchaseOrderReceiptProgress';
  orderedQty: Scalars['Int']['output'];
  productVariantId: Scalars['String']['output'];
  receivedQty: Scalars['Int']['output'];
};

export type PurchaseOrderScalarRelationFilter = {
  is?: InputMaybe<PurchaseOrderWhereInput>;
  isNot?: InputMaybe<PurchaseOrderWhereInput>;
};

export type PurchaseOrderScalarWhereInput = {
  AND?: InputMaybe<Array<PurchaseOrderScalarWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseOrderScalarWhereInput>>;
  OR?: InputMaybe<Array<PurchaseOrderScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  dueDate?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  invoiceNumber?: InputMaybe<StringFilter>;
  phase?: InputMaybe<EnumPurchasePhaseFilter>;
  status?: InputMaybe<EnumPurchaseOrderStatusFilter>;
  storeId?: InputMaybe<StringNullableFilter>;
  supplierId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export enum PurchaseOrderStatus {
  Cancelled = 'CANCELLED',
  Paid = 'PAID',
  PartiallyPaid = 'PARTIALLY_PAID',
  Pending = 'PENDING',
  Received = 'RECEIVED'
}

export type PurchaseOrderSumAggregate = {
  __typename?: 'PurchaseOrderSumAggregate';
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

export type PurchaseOrderUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  dueDate?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  invoiceNumber?: InputMaybe<StringFieldUpdateOperationsInput>;
  phase?: InputMaybe<EnumPurchasePhaseFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumPurchaseOrderStatusFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseOrderUpdateManyWithWhereWithoutReceiptsInput = {
  data: PurchaseOrderUpdateManyMutationInput;
  where: PurchaseOrderScalarWhereInput;
};

export type PurchaseOrderUpdateManyWithWhereWithoutStoreInput = {
  data: PurchaseOrderUpdateManyMutationInput;
  where: PurchaseOrderScalarWhereInput;
};

export type PurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
  data: PurchaseOrderUpdateManyMutationInput;
  where: PurchaseOrderScalarWhereInput;
};

export type PurchaseOrderUpdateManyWithoutReceiptsNestedInput = {
  connect?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseOrderCreateOrConnectWithoutReceiptsInput>>;
  create?: InputMaybe<Array<PurchaseOrderCreateWithoutReceiptsInput>>;
  delete?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseOrderScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseOrderUpdateWithWhereUniqueWithoutReceiptsInput>>;
  updateMany?: InputMaybe<Array<PurchaseOrderUpdateManyWithWhereWithoutReceiptsInput>>;
  upsert?: InputMaybe<Array<PurchaseOrderUpsertWithWhereUniqueWithoutReceiptsInput>>;
};

export type PurchaseOrderUpdateManyWithoutStoreNestedInput = {
  connect?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseOrderCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<PurchaseOrderCreateWithoutStoreInput>>;
  createMany?: InputMaybe<PurchaseOrderCreateManyStoreInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseOrderScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseOrderUpdateWithWhereUniqueWithoutStoreInput>>;
  updateMany?: InputMaybe<Array<PurchaseOrderUpdateManyWithWhereWithoutStoreInput>>;
  upsert?: InputMaybe<Array<PurchaseOrderUpsertWithWhereUniqueWithoutStoreInput>>;
};

export type PurchaseOrderUpdateManyWithoutSupplierNestedInput = {
  connect?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseOrderCreateOrConnectWithoutSupplierInput>>;
  create?: InputMaybe<Array<PurchaseOrderCreateWithoutSupplierInput>>;
  createMany?: InputMaybe<PurchaseOrderCreateManySupplierInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseOrderScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseOrderWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput>>;
  updateMany?: InputMaybe<Array<PurchaseOrderUpdateManyWithWhereWithoutSupplierInput>>;
  upsert?: InputMaybe<Array<PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput>>;
};

export type PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput = {
  connect?: InputMaybe<PurchaseOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PurchaseOrderCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<PurchaseOrderCreateWithoutItemsInput>;
  update?: InputMaybe<PurchaseOrderUpdateToOneWithWhereWithoutItemsInput>;
  upsert?: InputMaybe<PurchaseOrderUpsertWithoutItemsInput>;
};

export type PurchaseOrderUpdateOneWithoutPaymentsNestedInput = {
  connect?: InputMaybe<PurchaseOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PurchaseOrderCreateOrConnectWithoutPaymentsInput>;
  create?: InputMaybe<PurchaseOrderCreateWithoutPaymentsInput>;
  delete?: InputMaybe<PurchaseOrderWhereInput>;
  disconnect?: InputMaybe<PurchaseOrderWhereInput>;
  update?: InputMaybe<PurchaseOrderUpdateToOneWithWhereWithoutPaymentsInput>;
  upsert?: InputMaybe<PurchaseOrderUpsertWithoutPaymentsInput>;
};

export type PurchaseOrderUpdateToOneWithWhereWithoutItemsInput = {
  data: PurchaseOrderUpdateWithoutItemsInput;
  where?: InputMaybe<PurchaseOrderWhereInput>;
};

export type PurchaseOrderUpdateToOneWithWhereWithoutPaymentsInput = {
  data: PurchaseOrderUpdateWithoutPaymentsInput;
  where?: InputMaybe<PurchaseOrderWhereInput>;
};

export type PurchaseOrderUpdateWithWhereUniqueWithoutReceiptsInput = {
  data: PurchaseOrderUpdateWithoutReceiptsInput;
  where: PurchaseOrderWhereUniqueInput;
};

export type PurchaseOrderUpdateWithWhereUniqueWithoutStoreInput = {
  data: PurchaseOrderUpdateWithoutStoreInput;
  where: PurchaseOrderWhereUniqueInput;
};

export type PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
  data: PurchaseOrderUpdateWithoutSupplierInput;
  where: PurchaseOrderWhereUniqueInput;
};

export type PurchaseOrderUpdateWithoutItemsInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  dueDate?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  invoiceNumber?: InputMaybe<StringFieldUpdateOperationsInput>;
  payments?: InputMaybe<SupplierPaymentUpdateManyWithoutPurchaseOrderNestedInput>;
  phase?: InputMaybe<EnumPurchasePhaseFieldUpdateOperationsInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutPurchaseOrderNestedInput>;
  status?: InputMaybe<EnumPurchaseOrderStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneWithoutPurchaseOrdersNestedInput>;
  supplier?: InputMaybe<SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseOrderUpdateWithoutPaymentsInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  dueDate?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  invoiceNumber?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput>;
  phase?: InputMaybe<EnumPurchasePhaseFieldUpdateOperationsInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutPurchaseOrderNestedInput>;
  status?: InputMaybe<EnumPurchaseOrderStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneWithoutPurchaseOrdersNestedInput>;
  supplier?: InputMaybe<SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseOrderUpdateWithoutReceiptsInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  dueDate?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  invoiceNumber?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput>;
  payments?: InputMaybe<SupplierPaymentUpdateManyWithoutPurchaseOrderNestedInput>;
  phase?: InputMaybe<EnumPurchasePhaseFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumPurchaseOrderStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneWithoutPurchaseOrdersNestedInput>;
  supplier?: InputMaybe<SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseOrderUpdateWithoutStoreInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  dueDate?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  invoiceNumber?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput>;
  payments?: InputMaybe<SupplierPaymentUpdateManyWithoutPurchaseOrderNestedInput>;
  phase?: InputMaybe<EnumPurchasePhaseFieldUpdateOperationsInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutPurchaseOrderNestedInput>;
  status?: InputMaybe<EnumPurchaseOrderStatusFieldUpdateOperationsInput>;
  supplier?: InputMaybe<SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseOrderUpdateWithoutSupplierInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  dueDate?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  invoiceNumber?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<PurchaseOrderItemUpdateManyWithoutPurchaseOrderNestedInput>;
  payments?: InputMaybe<SupplierPaymentUpdateManyWithoutPurchaseOrderNestedInput>;
  phase?: InputMaybe<EnumPurchasePhaseFieldUpdateOperationsInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutPurchaseOrderNestedInput>;
  status?: InputMaybe<EnumPurchaseOrderStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneWithoutPurchaseOrdersNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseOrderUpsertWithWhereUniqueWithoutReceiptsInput = {
  create: PurchaseOrderCreateWithoutReceiptsInput;
  update: PurchaseOrderUpdateWithoutReceiptsInput;
  where: PurchaseOrderWhereUniqueInput;
};

export type PurchaseOrderUpsertWithWhereUniqueWithoutStoreInput = {
  create: PurchaseOrderCreateWithoutStoreInput;
  update: PurchaseOrderUpdateWithoutStoreInput;
  where: PurchaseOrderWhereUniqueInput;
};

export type PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
  create: PurchaseOrderCreateWithoutSupplierInput;
  update: PurchaseOrderUpdateWithoutSupplierInput;
  where: PurchaseOrderWhereUniqueInput;
};

export type PurchaseOrderUpsertWithoutItemsInput = {
  create: PurchaseOrderCreateWithoutItemsInput;
  update: PurchaseOrderUpdateWithoutItemsInput;
  where?: InputMaybe<PurchaseOrderWhereInput>;
};

export type PurchaseOrderUpsertWithoutPaymentsInput = {
  create: PurchaseOrderCreateWithoutPaymentsInput;
  update: PurchaseOrderUpdateWithoutPaymentsInput;
  where?: InputMaybe<PurchaseOrderWhereInput>;
};

export type PurchaseOrderWhereInput = {
  AND?: InputMaybe<Array<PurchaseOrderWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseOrderWhereInput>>;
  OR?: InputMaybe<Array<PurchaseOrderWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  dueDate?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  invoiceNumber?: InputMaybe<StringFilter>;
  items?: InputMaybe<PurchaseOrderItemListRelationFilter>;
  payments?: InputMaybe<SupplierPaymentListRelationFilter>;
  phase?: InputMaybe<EnumPurchasePhaseFilter>;
  receipts?: InputMaybe<StockReceiptBatchListRelationFilter>;
  status?: InputMaybe<EnumPurchaseOrderStatusFilter>;
  store?: InputMaybe<StoreNullableScalarRelationFilter>;
  storeId?: InputMaybe<StringNullableFilter>;
  supplier?: InputMaybe<SupplierScalarRelationFilter>;
  supplierId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type PurchaseOrderWhereUniqueInput = {
  AND?: InputMaybe<Array<PurchaseOrderWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseOrderWhereInput>>;
  OR?: InputMaybe<Array<PurchaseOrderWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  dueDate?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  invoiceNumber?: InputMaybe<StringFilter>;
  items?: InputMaybe<PurchaseOrderItemListRelationFilter>;
  payments?: InputMaybe<SupplierPaymentListRelationFilter>;
  phase?: InputMaybe<EnumPurchasePhaseFilter>;
  receipts?: InputMaybe<StockReceiptBatchListRelationFilter>;
  status?: InputMaybe<EnumPurchaseOrderStatusFilter>;
  store?: InputMaybe<StoreNullableScalarRelationFilter>;
  storeId?: InputMaybe<StringNullableFilter>;
  supplier?: InputMaybe<SupplierScalarRelationFilter>;
  supplierId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export enum PurchasePhase {
  Approval = 'APPROVAL',
  Completed = 'COMPLETED',
  Invoicing = 'INVOICING',
  Negotiation = 'NEGOTIATION',
  Ordered = 'ORDERED',
  Receiving = 'RECEIVING',
  Requisition = 'REQUISITION',
  Rfq = 'RFQ'
}

export type PurchaseRequisition = {
  __typename?: 'PurchaseRequisition';
  _count: PurchaseRequisitionCount;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  items?: Maybe<Array<PurchaseRequisitionItem>>;
  quotes?: Maybe<Array<SupplierQuote>>;
  requestedBy: User;
  requestedById: Scalars['String']['output'];
  status: PurchaseRequisitionStatus;
  store: Store;
  storeId: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type PurchaseRequisitionCount = {
  __typename?: 'PurchaseRequisitionCount';
  items: Scalars['Int']['output'];
  quotes: Scalars['Int']['output'];
};

export type PurchaseRequisitionCreateManyRequestedByInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<PurchaseRequisitionStatus>;
  storeId: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseRequisitionCreateManyRequestedByInputEnvelope = {
  data: Array<PurchaseRequisitionCreateManyRequestedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseRequisitionCreateManyStoreInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  requestedById: Scalars['String']['input'];
  status?: InputMaybe<PurchaseRequisitionStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseRequisitionCreateManyStoreInputEnvelope = {
  data: Array<PurchaseRequisitionCreateManyStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseRequisitionCreateNestedManyWithoutRequestedByInput = {
  connect?: InputMaybe<Array<PurchaseRequisitionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseRequisitionCreateOrConnectWithoutRequestedByInput>>;
  create?: InputMaybe<Array<PurchaseRequisitionCreateWithoutRequestedByInput>>;
  createMany?: InputMaybe<PurchaseRequisitionCreateManyRequestedByInputEnvelope>;
};

export type PurchaseRequisitionCreateNestedManyWithoutStoreInput = {
  connect?: InputMaybe<Array<PurchaseRequisitionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseRequisitionCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<PurchaseRequisitionCreateWithoutStoreInput>>;
  createMany?: InputMaybe<PurchaseRequisitionCreateManyStoreInputEnvelope>;
};

export type PurchaseRequisitionCreateNestedOneWithoutItemsInput = {
  connect?: InputMaybe<PurchaseRequisitionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PurchaseRequisitionCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<PurchaseRequisitionCreateWithoutItemsInput>;
};

export type PurchaseRequisitionCreateNestedOneWithoutQuotesInput = {
  connect?: InputMaybe<PurchaseRequisitionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PurchaseRequisitionCreateOrConnectWithoutQuotesInput>;
  create?: InputMaybe<PurchaseRequisitionCreateWithoutQuotesInput>;
};

export type PurchaseRequisitionCreateOrConnectWithoutItemsInput = {
  create: PurchaseRequisitionCreateWithoutItemsInput;
  where: PurchaseRequisitionWhereUniqueInput;
};

export type PurchaseRequisitionCreateOrConnectWithoutQuotesInput = {
  create: PurchaseRequisitionCreateWithoutQuotesInput;
  where: PurchaseRequisitionWhereUniqueInput;
};

export type PurchaseRequisitionCreateOrConnectWithoutRequestedByInput = {
  create: PurchaseRequisitionCreateWithoutRequestedByInput;
  where: PurchaseRequisitionWhereUniqueInput;
};

export type PurchaseRequisitionCreateOrConnectWithoutStoreInput = {
  create: PurchaseRequisitionCreateWithoutStoreInput;
  where: PurchaseRequisitionWhereUniqueInput;
};

export type PurchaseRequisitionCreateWithoutItemsInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  quotes?: InputMaybe<SupplierQuoteCreateNestedManyWithoutRequisitionInput>;
  requestedBy: UserCreateNestedOneWithoutPurchaseRequisitionInput;
  status?: InputMaybe<PurchaseRequisitionStatus>;
  store: StoreCreateNestedOneWithoutPurchaseRequisitionInput;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseRequisitionCreateWithoutQuotesInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutRequisitionInput>;
  requestedBy: UserCreateNestedOneWithoutPurchaseRequisitionInput;
  status?: InputMaybe<PurchaseRequisitionStatus>;
  store: StoreCreateNestedOneWithoutPurchaseRequisitionInput;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseRequisitionCreateWithoutRequestedByInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutRequisitionInput>;
  quotes?: InputMaybe<SupplierQuoteCreateNestedManyWithoutRequisitionInput>;
  status?: InputMaybe<PurchaseRequisitionStatus>;
  store: StoreCreateNestedOneWithoutPurchaseRequisitionInput;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseRequisitionCreateWithoutStoreInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<PurchaseRequisitionItemCreateNestedManyWithoutRequisitionInput>;
  quotes?: InputMaybe<SupplierQuoteCreateNestedManyWithoutRequisitionInput>;
  requestedBy: UserCreateNestedOneWithoutPurchaseRequisitionInput;
  status?: InputMaybe<PurchaseRequisitionStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseRequisitionItem = {
  __typename?: 'PurchaseRequisitionItem';
  id: Scalars['ID']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  requestedQty: Scalars['Int']['output'];
  requisition: PurchaseRequisition;
  requisitionId: Scalars['String']['output'];
};

export type PurchaseRequisitionItemCreateManyProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  requestedQty: Scalars['Int']['input'];
  requisitionId: Scalars['String']['input'];
};

export type PurchaseRequisitionItemCreateManyProductVariantInputEnvelope = {
  data: Array<PurchaseRequisitionItemCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseRequisitionItemCreateManyRequisitionInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  requestedQty: Scalars['Int']['input'];
};

export type PurchaseRequisitionItemCreateManyRequisitionInputEnvelope = {
  data: Array<PurchaseRequisitionItemCreateManyRequisitionInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseRequisitionItemCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<PurchaseRequisitionItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseRequisitionItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<PurchaseRequisitionItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<PurchaseRequisitionItemCreateManyProductVariantInputEnvelope>;
};

export type PurchaseRequisitionItemCreateNestedManyWithoutRequisitionInput = {
  connect?: InputMaybe<Array<PurchaseRequisitionItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseRequisitionItemCreateOrConnectWithoutRequisitionInput>>;
  create?: InputMaybe<Array<PurchaseRequisitionItemCreateWithoutRequisitionInput>>;
  createMany?: InputMaybe<PurchaseRequisitionItemCreateManyRequisitionInputEnvelope>;
};

export type PurchaseRequisitionItemCreateOrConnectWithoutProductVariantInput = {
  create: PurchaseRequisitionItemCreateWithoutProductVariantInput;
  where: PurchaseRequisitionItemWhereUniqueInput;
};

export type PurchaseRequisitionItemCreateOrConnectWithoutRequisitionInput = {
  create: PurchaseRequisitionItemCreateWithoutRequisitionInput;
  where: PurchaseRequisitionItemWhereUniqueInput;
};

export type PurchaseRequisitionItemCreateWithoutProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  requestedQty: Scalars['Int']['input'];
  requisition: PurchaseRequisitionCreateNestedOneWithoutItemsInput;
};

export type PurchaseRequisitionItemCreateWithoutRequisitionInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutPurchaseRequisitionItemInput;
  requestedQty: Scalars['Int']['input'];
};

export type PurchaseRequisitionItemListRelationFilter = {
  every?: InputMaybe<PurchaseRequisitionItemWhereInput>;
  none?: InputMaybe<PurchaseRequisitionItemWhereInput>;
  some?: InputMaybe<PurchaseRequisitionItemWhereInput>;
};

export type PurchaseRequisitionItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type PurchaseRequisitionItemScalarWhereInput = {
  AND?: InputMaybe<Array<PurchaseRequisitionItemScalarWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseRequisitionItemScalarWhereInput>>;
  OR?: InputMaybe<Array<PurchaseRequisitionItemScalarWhereInput>>;
  id?: InputMaybe<StringFilter>;
  notes?: InputMaybe<StringNullableFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  requestedQty?: InputMaybe<IntFilter>;
  requisitionId?: InputMaybe<StringFilter>;
};

export type PurchaseRequisitionItemUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  requestedQty?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type PurchaseRequisitionItemUpdateManyWithWhereWithoutProductVariantInput = {
  data: PurchaseRequisitionItemUpdateManyMutationInput;
  where: PurchaseRequisitionItemScalarWhereInput;
};

export type PurchaseRequisitionItemUpdateManyWithWhereWithoutRequisitionInput = {
  data: PurchaseRequisitionItemUpdateManyMutationInput;
  where: PurchaseRequisitionItemScalarWhereInput;
};

export type PurchaseRequisitionItemUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<PurchaseRequisitionItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseRequisitionItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<PurchaseRequisitionItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<PurchaseRequisitionItemCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseRequisitionItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseRequisitionItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseRequisitionItemWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseRequisitionItemWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseRequisitionItemUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<PurchaseRequisitionItemUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<PurchaseRequisitionItemUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type PurchaseRequisitionItemUpdateManyWithoutRequisitionNestedInput = {
  connect?: InputMaybe<Array<PurchaseRequisitionItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseRequisitionItemCreateOrConnectWithoutRequisitionInput>>;
  create?: InputMaybe<Array<PurchaseRequisitionItemCreateWithoutRequisitionInput>>;
  createMany?: InputMaybe<PurchaseRequisitionItemCreateManyRequisitionInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseRequisitionItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseRequisitionItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseRequisitionItemWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseRequisitionItemWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseRequisitionItemUpdateWithWhereUniqueWithoutRequisitionInput>>;
  updateMany?: InputMaybe<Array<PurchaseRequisitionItemUpdateManyWithWhereWithoutRequisitionInput>>;
  upsert?: InputMaybe<Array<PurchaseRequisitionItemUpsertWithWhereUniqueWithoutRequisitionInput>>;
};

export type PurchaseRequisitionItemUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: PurchaseRequisitionItemUpdateWithoutProductVariantInput;
  where: PurchaseRequisitionItemWhereUniqueInput;
};

export type PurchaseRequisitionItemUpdateWithWhereUniqueWithoutRequisitionInput = {
  data: PurchaseRequisitionItemUpdateWithoutRequisitionInput;
  where: PurchaseRequisitionItemWhereUniqueInput;
};

export type PurchaseRequisitionItemUpdateWithoutProductVariantInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  requestedQty?: InputMaybe<IntFieldUpdateOperationsInput>;
  requisition?: InputMaybe<PurchaseRequisitionUpdateOneRequiredWithoutItemsNestedInput>;
};

export type PurchaseRequisitionItemUpdateWithoutRequisitionInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutPurchaseRequisitionItemNestedInput>;
  requestedQty?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type PurchaseRequisitionItemUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: PurchaseRequisitionItemCreateWithoutProductVariantInput;
  update: PurchaseRequisitionItemUpdateWithoutProductVariantInput;
  where: PurchaseRequisitionItemWhereUniqueInput;
};

export type PurchaseRequisitionItemUpsertWithWhereUniqueWithoutRequisitionInput = {
  create: PurchaseRequisitionItemCreateWithoutRequisitionInput;
  update: PurchaseRequisitionItemUpdateWithoutRequisitionInput;
  where: PurchaseRequisitionItemWhereUniqueInput;
};

export type PurchaseRequisitionItemWhereInput = {
  AND?: InputMaybe<Array<PurchaseRequisitionItemWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseRequisitionItemWhereInput>>;
  OR?: InputMaybe<Array<PurchaseRequisitionItemWhereInput>>;
  id?: InputMaybe<StringFilter>;
  notes?: InputMaybe<StringNullableFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  requestedQty?: InputMaybe<IntFilter>;
  requisition?: InputMaybe<PurchaseRequisitionScalarRelationFilter>;
  requisitionId?: InputMaybe<StringFilter>;
};

export type PurchaseRequisitionItemWhereUniqueInput = {
  AND?: InputMaybe<Array<PurchaseRequisitionItemWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseRequisitionItemWhereInput>>;
  OR?: InputMaybe<Array<PurchaseRequisitionItemWhereInput>>;
  id?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<StringNullableFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  requestedQty?: InputMaybe<IntFilter>;
  requisition?: InputMaybe<PurchaseRequisitionScalarRelationFilter>;
  requisitionId?: InputMaybe<StringFilter>;
};

export type PurchaseRequisitionListRelationFilter = {
  every?: InputMaybe<PurchaseRequisitionWhereInput>;
  none?: InputMaybe<PurchaseRequisitionWhereInput>;
  some?: InputMaybe<PurchaseRequisitionWhereInput>;
};

export type PurchaseRequisitionOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type PurchaseRequisitionScalarRelationFilter = {
  is?: InputMaybe<PurchaseRequisitionWhereInput>;
  isNot?: InputMaybe<PurchaseRequisitionWhereInput>;
};

export type PurchaseRequisitionScalarWhereInput = {
  AND?: InputMaybe<Array<PurchaseRequisitionScalarWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseRequisitionScalarWhereInput>>;
  OR?: InputMaybe<Array<PurchaseRequisitionScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  requestedById?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumPurchaseRequisitionStatusFilter>;
  storeId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export enum PurchaseRequisitionStatus {
  Approved = 'APPROVED',
  Draft = 'DRAFT',
  Rejected = 'REJECTED',
  Sent = 'SENT'
}

export type PurchaseRequisitionUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumPurchaseRequisitionStatusFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseRequisitionUpdateManyWithWhereWithoutRequestedByInput = {
  data: PurchaseRequisitionUpdateManyMutationInput;
  where: PurchaseRequisitionScalarWhereInput;
};

export type PurchaseRequisitionUpdateManyWithWhereWithoutStoreInput = {
  data: PurchaseRequisitionUpdateManyMutationInput;
  where: PurchaseRequisitionScalarWhereInput;
};

export type PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput = {
  connect?: InputMaybe<Array<PurchaseRequisitionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseRequisitionCreateOrConnectWithoutRequestedByInput>>;
  create?: InputMaybe<Array<PurchaseRequisitionCreateWithoutRequestedByInput>>;
  createMany?: InputMaybe<PurchaseRequisitionCreateManyRequestedByInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseRequisitionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseRequisitionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseRequisitionWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseRequisitionWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseRequisitionUpdateWithWhereUniqueWithoutRequestedByInput>>;
  updateMany?: InputMaybe<Array<PurchaseRequisitionUpdateManyWithWhereWithoutRequestedByInput>>;
  upsert?: InputMaybe<Array<PurchaseRequisitionUpsertWithWhereUniqueWithoutRequestedByInput>>;
};

export type PurchaseRequisitionUpdateManyWithoutStoreNestedInput = {
  connect?: InputMaybe<Array<PurchaseRequisitionWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseRequisitionCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<PurchaseRequisitionCreateWithoutStoreInput>>;
  createMany?: InputMaybe<PurchaseRequisitionCreateManyStoreInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseRequisitionWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseRequisitionScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseRequisitionWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseRequisitionWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseRequisitionUpdateWithWhereUniqueWithoutStoreInput>>;
  updateMany?: InputMaybe<Array<PurchaseRequisitionUpdateManyWithWhereWithoutStoreInput>>;
  upsert?: InputMaybe<Array<PurchaseRequisitionUpsertWithWhereUniqueWithoutStoreInput>>;
};

export type PurchaseRequisitionUpdateOneRequiredWithoutItemsNestedInput = {
  connect?: InputMaybe<PurchaseRequisitionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PurchaseRequisitionCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<PurchaseRequisitionCreateWithoutItemsInput>;
  update?: InputMaybe<PurchaseRequisitionUpdateToOneWithWhereWithoutItemsInput>;
  upsert?: InputMaybe<PurchaseRequisitionUpsertWithoutItemsInput>;
};

export type PurchaseRequisitionUpdateOneRequiredWithoutQuotesNestedInput = {
  connect?: InputMaybe<PurchaseRequisitionWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PurchaseRequisitionCreateOrConnectWithoutQuotesInput>;
  create?: InputMaybe<PurchaseRequisitionCreateWithoutQuotesInput>;
  update?: InputMaybe<PurchaseRequisitionUpdateToOneWithWhereWithoutQuotesInput>;
  upsert?: InputMaybe<PurchaseRequisitionUpsertWithoutQuotesInput>;
};

export type PurchaseRequisitionUpdateToOneWithWhereWithoutItemsInput = {
  data: PurchaseRequisitionUpdateWithoutItemsInput;
  where?: InputMaybe<PurchaseRequisitionWhereInput>;
};

export type PurchaseRequisitionUpdateToOneWithWhereWithoutQuotesInput = {
  data: PurchaseRequisitionUpdateWithoutQuotesInput;
  where?: InputMaybe<PurchaseRequisitionWhereInput>;
};

export type PurchaseRequisitionUpdateWithWhereUniqueWithoutRequestedByInput = {
  data: PurchaseRequisitionUpdateWithoutRequestedByInput;
  where: PurchaseRequisitionWhereUniqueInput;
};

export type PurchaseRequisitionUpdateWithWhereUniqueWithoutStoreInput = {
  data: PurchaseRequisitionUpdateWithoutStoreInput;
  where: PurchaseRequisitionWhereUniqueInput;
};

export type PurchaseRequisitionUpdateWithoutItemsInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quotes?: InputMaybe<SupplierQuoteUpdateManyWithoutRequisitionNestedInput>;
  requestedBy?: InputMaybe<UserUpdateOneRequiredWithoutPurchaseRequisitionNestedInput>;
  status?: InputMaybe<EnumPurchaseRequisitionStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutPurchaseRequisitionNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseRequisitionUpdateWithoutQuotesInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutRequisitionNestedInput>;
  requestedBy?: InputMaybe<UserUpdateOneRequiredWithoutPurchaseRequisitionNestedInput>;
  status?: InputMaybe<EnumPurchaseRequisitionStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutPurchaseRequisitionNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseRequisitionUpdateWithoutRequestedByInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutRequisitionNestedInput>;
  quotes?: InputMaybe<SupplierQuoteUpdateManyWithoutRequisitionNestedInput>;
  status?: InputMaybe<EnumPurchaseRequisitionStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutPurchaseRequisitionNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseRequisitionUpdateWithoutStoreInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<PurchaseRequisitionItemUpdateManyWithoutRequisitionNestedInput>;
  quotes?: InputMaybe<SupplierQuoteUpdateManyWithoutRequisitionNestedInput>;
  requestedBy?: InputMaybe<UserUpdateOneRequiredWithoutPurchaseRequisitionNestedInput>;
  status?: InputMaybe<EnumPurchaseRequisitionStatusFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseRequisitionUpsertWithWhereUniqueWithoutRequestedByInput = {
  create: PurchaseRequisitionCreateWithoutRequestedByInput;
  update: PurchaseRequisitionUpdateWithoutRequestedByInput;
  where: PurchaseRequisitionWhereUniqueInput;
};

export type PurchaseRequisitionUpsertWithWhereUniqueWithoutStoreInput = {
  create: PurchaseRequisitionCreateWithoutStoreInput;
  update: PurchaseRequisitionUpdateWithoutStoreInput;
  where: PurchaseRequisitionWhereUniqueInput;
};

export type PurchaseRequisitionUpsertWithoutItemsInput = {
  create: PurchaseRequisitionCreateWithoutItemsInput;
  update: PurchaseRequisitionUpdateWithoutItemsInput;
  where?: InputMaybe<PurchaseRequisitionWhereInput>;
};

export type PurchaseRequisitionUpsertWithoutQuotesInput = {
  create: PurchaseRequisitionCreateWithoutQuotesInput;
  update: PurchaseRequisitionUpdateWithoutQuotesInput;
  where?: InputMaybe<PurchaseRequisitionWhereInput>;
};

export type PurchaseRequisitionWhereInput = {
  AND?: InputMaybe<Array<PurchaseRequisitionWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseRequisitionWhereInput>>;
  OR?: InputMaybe<Array<PurchaseRequisitionWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  items?: InputMaybe<PurchaseRequisitionItemListRelationFilter>;
  quotes?: InputMaybe<SupplierQuoteListRelationFilter>;
  requestedBy?: InputMaybe<UserScalarRelationFilter>;
  requestedById?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumPurchaseRequisitionStatusFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type PurchaseRequisitionWhereUniqueInput = {
  AND?: InputMaybe<Array<PurchaseRequisitionWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseRequisitionWhereInput>>;
  OR?: InputMaybe<Array<PurchaseRequisitionWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<PurchaseRequisitionItemListRelationFilter>;
  quotes?: InputMaybe<SupplierQuoteListRelationFilter>;
  requestedBy?: InputMaybe<UserScalarRelationFilter>;
  requestedById?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumPurchaseRequisitionStatusFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type PurchaseReturn = {
  __typename?: 'PurchaseReturn';
  _count: PurchaseReturnCount;
  approvedBy: User;
  approvedById: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  initiatedBy: User;
  initiatedById: Scalars['String']['output'];
  items?: Maybe<Array<PurchaseReturnItem>>;
  reason?: Maybe<Scalars['String']['output']>;
  status: ReturnStatus;
  supplier: Supplier;
  supplierId: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type PurchaseReturnCount = {
  __typename?: 'PurchaseReturnCount';
  items: Scalars['Int']['output'];
};

export type PurchaseReturnCreateManyApprovedByInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  initiatedById: Scalars['String']['input'];
  reason?: InputMaybe<Scalars['String']['input']>;
  status: ReturnStatus;
  supplierId: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseReturnCreateManyApprovedByInputEnvelope = {
  data: Array<PurchaseReturnCreateManyApprovedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseReturnCreateManyInitiatedByInput = {
  approvedById: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  reason?: InputMaybe<Scalars['String']['input']>;
  status: ReturnStatus;
  supplierId: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseReturnCreateManyInitiatedByInputEnvelope = {
  data: Array<PurchaseReturnCreateManyInitiatedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseReturnCreateManySupplierInput = {
  approvedById: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  initiatedById: Scalars['String']['input'];
  reason?: InputMaybe<Scalars['String']['input']>;
  status: ReturnStatus;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseReturnCreateManySupplierInputEnvelope = {
  data: Array<PurchaseReturnCreateManySupplierInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseReturnCreateNestedManyWithoutApprovedByInput = {
  connect?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnCreateOrConnectWithoutApprovedByInput>>;
  create?: InputMaybe<Array<PurchaseReturnCreateWithoutApprovedByInput>>;
  createMany?: InputMaybe<PurchaseReturnCreateManyApprovedByInputEnvelope>;
};

export type PurchaseReturnCreateNestedManyWithoutInitiatedByInput = {
  connect?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnCreateOrConnectWithoutInitiatedByInput>>;
  create?: InputMaybe<Array<PurchaseReturnCreateWithoutInitiatedByInput>>;
  createMany?: InputMaybe<PurchaseReturnCreateManyInitiatedByInputEnvelope>;
};

export type PurchaseReturnCreateNestedManyWithoutSupplierInput = {
  connect?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnCreateOrConnectWithoutSupplierInput>>;
  create?: InputMaybe<Array<PurchaseReturnCreateWithoutSupplierInput>>;
  createMany?: InputMaybe<PurchaseReturnCreateManySupplierInputEnvelope>;
};

export type PurchaseReturnCreateNestedOneWithoutItemsInput = {
  connect?: InputMaybe<PurchaseReturnWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PurchaseReturnCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<PurchaseReturnCreateWithoutItemsInput>;
};

export type PurchaseReturnCreateOrConnectWithoutApprovedByInput = {
  create: PurchaseReturnCreateWithoutApprovedByInput;
  where: PurchaseReturnWhereUniqueInput;
};

export type PurchaseReturnCreateOrConnectWithoutInitiatedByInput = {
  create: PurchaseReturnCreateWithoutInitiatedByInput;
  where: PurchaseReturnWhereUniqueInput;
};

export type PurchaseReturnCreateOrConnectWithoutItemsInput = {
  create: PurchaseReturnCreateWithoutItemsInput;
  where: PurchaseReturnWhereUniqueInput;
};

export type PurchaseReturnCreateOrConnectWithoutSupplierInput = {
  create: PurchaseReturnCreateWithoutSupplierInput;
  where: PurchaseReturnWhereUniqueInput;
};

export type PurchaseReturnCreateWithoutApprovedByInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  initiatedBy: UserCreateNestedOneWithoutPurchaseReturnInitiatorsInput;
  items?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutReturnInput>;
  reason?: InputMaybe<Scalars['String']['input']>;
  status: ReturnStatus;
  supplier: SupplierCreateNestedOneWithoutReturnsInput;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseReturnCreateWithoutInitiatedByInput = {
  approvedBy: UserCreateNestedOneWithoutPurchaseReturnApproversInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutReturnInput>;
  reason?: InputMaybe<Scalars['String']['input']>;
  status: ReturnStatus;
  supplier: SupplierCreateNestedOneWithoutReturnsInput;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseReturnCreateWithoutItemsInput = {
  approvedBy: UserCreateNestedOneWithoutPurchaseReturnApproversInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  initiatedBy: UserCreateNestedOneWithoutPurchaseReturnInitiatorsInput;
  reason?: InputMaybe<Scalars['String']['input']>;
  status: ReturnStatus;
  supplier: SupplierCreateNestedOneWithoutReturnsInput;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseReturnCreateWithoutSupplierInput = {
  approvedBy: UserCreateNestedOneWithoutPurchaseReturnApproversInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  initiatedBy: UserCreateNestedOneWithoutPurchaseReturnInitiatorsInput;
  items?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutReturnInput>;
  reason?: InputMaybe<Scalars['String']['input']>;
  status: ReturnStatus;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type PurchaseReturnItem = {
  __typename?: 'PurchaseReturnItem';
  batch: StockReceiptBatch;
  batchId: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  purchaseReturnId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  return: PurchaseReturn;
};

export type PurchaseReturnItemCreateManyBatchInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  purchaseReturnId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type PurchaseReturnItemCreateManyBatchInputEnvelope = {
  data: Array<PurchaseReturnItemCreateManyBatchInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseReturnItemCreateManyProductVariantInput = {
  batchId: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  purchaseReturnId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type PurchaseReturnItemCreateManyProductVariantInputEnvelope = {
  data: Array<PurchaseReturnItemCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseReturnItemCreateManyReturnInput = {
  batchId: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type PurchaseReturnItemCreateManyReturnInputEnvelope = {
  data: Array<PurchaseReturnItemCreateManyReturnInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PurchaseReturnItemCreateNestedManyWithoutBatchInput = {
  connect?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnItemCreateOrConnectWithoutBatchInput>>;
  create?: InputMaybe<Array<PurchaseReturnItemCreateWithoutBatchInput>>;
  createMany?: InputMaybe<PurchaseReturnItemCreateManyBatchInputEnvelope>;
};

export type PurchaseReturnItemCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<PurchaseReturnItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<PurchaseReturnItemCreateManyProductVariantInputEnvelope>;
};

export type PurchaseReturnItemCreateNestedManyWithoutReturnInput = {
  connect?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnItemCreateOrConnectWithoutReturnInput>>;
  create?: InputMaybe<Array<PurchaseReturnItemCreateWithoutReturnInput>>;
  createMany?: InputMaybe<PurchaseReturnItemCreateManyReturnInputEnvelope>;
};

export type PurchaseReturnItemCreateOrConnectWithoutBatchInput = {
  create: PurchaseReturnItemCreateWithoutBatchInput;
  where: PurchaseReturnItemWhereUniqueInput;
};

export type PurchaseReturnItemCreateOrConnectWithoutProductVariantInput = {
  create: PurchaseReturnItemCreateWithoutProductVariantInput;
  where: PurchaseReturnItemWhereUniqueInput;
};

export type PurchaseReturnItemCreateOrConnectWithoutReturnInput = {
  create: PurchaseReturnItemCreateWithoutReturnInput;
  where: PurchaseReturnItemWhereUniqueInput;
};

export type PurchaseReturnItemCreateWithoutBatchInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutPurchaseReturnItemsInput;
  quantity: Scalars['Int']['input'];
  return: PurchaseReturnCreateNestedOneWithoutItemsInput;
};

export type PurchaseReturnItemCreateWithoutProductVariantInput = {
  batch: StockReceiptBatchCreateNestedOneWithoutPurchaseReturnsInput;
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  return: PurchaseReturnCreateNestedOneWithoutItemsInput;
};

export type PurchaseReturnItemCreateWithoutReturnInput = {
  batch: StockReceiptBatchCreateNestedOneWithoutPurchaseReturnsInput;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutPurchaseReturnItemsInput;
  quantity: Scalars['Int']['input'];
};

export type PurchaseReturnItemListRelationFilter = {
  every?: InputMaybe<PurchaseReturnItemWhereInput>;
  none?: InputMaybe<PurchaseReturnItemWhereInput>;
  some?: InputMaybe<PurchaseReturnItemWhereInput>;
};

export type PurchaseReturnItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type PurchaseReturnItemScalarWhereInput = {
  AND?: InputMaybe<Array<PurchaseReturnItemScalarWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseReturnItemScalarWhereInput>>;
  OR?: InputMaybe<Array<PurchaseReturnItemScalarWhereInput>>;
  batchId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  purchaseReturnId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
};

export type PurchaseReturnItemUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type PurchaseReturnItemUpdateManyWithWhereWithoutBatchInput = {
  data: PurchaseReturnItemUpdateManyMutationInput;
  where: PurchaseReturnItemScalarWhereInput;
};

export type PurchaseReturnItemUpdateManyWithWhereWithoutProductVariantInput = {
  data: PurchaseReturnItemUpdateManyMutationInput;
  where: PurchaseReturnItemScalarWhereInput;
};

export type PurchaseReturnItemUpdateManyWithWhereWithoutReturnInput = {
  data: PurchaseReturnItemUpdateManyMutationInput;
  where: PurchaseReturnItemScalarWhereInput;
};

export type PurchaseReturnItemUpdateManyWithoutBatchNestedInput = {
  connect?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnItemCreateOrConnectWithoutBatchInput>>;
  create?: InputMaybe<Array<PurchaseReturnItemCreateWithoutBatchInput>>;
  createMany?: InputMaybe<PurchaseReturnItemCreateManyBatchInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseReturnItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseReturnItemUpdateWithWhereUniqueWithoutBatchInput>>;
  updateMany?: InputMaybe<Array<PurchaseReturnItemUpdateManyWithWhereWithoutBatchInput>>;
  upsert?: InputMaybe<Array<PurchaseReturnItemUpsertWithWhereUniqueWithoutBatchInput>>;
};

export type PurchaseReturnItemUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<PurchaseReturnItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<PurchaseReturnItemCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseReturnItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseReturnItemUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<PurchaseReturnItemUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<PurchaseReturnItemUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type PurchaseReturnItemUpdateManyWithoutReturnNestedInput = {
  connect?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnItemCreateOrConnectWithoutReturnInput>>;
  create?: InputMaybe<Array<PurchaseReturnItemCreateWithoutReturnInput>>;
  createMany?: InputMaybe<PurchaseReturnItemCreateManyReturnInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseReturnItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseReturnItemWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseReturnItemUpdateWithWhereUniqueWithoutReturnInput>>;
  updateMany?: InputMaybe<Array<PurchaseReturnItemUpdateManyWithWhereWithoutReturnInput>>;
  upsert?: InputMaybe<Array<PurchaseReturnItemUpsertWithWhereUniqueWithoutReturnInput>>;
};

export type PurchaseReturnItemUpdateWithWhereUniqueWithoutBatchInput = {
  data: PurchaseReturnItemUpdateWithoutBatchInput;
  where: PurchaseReturnItemWhereUniqueInput;
};

export type PurchaseReturnItemUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: PurchaseReturnItemUpdateWithoutProductVariantInput;
  where: PurchaseReturnItemWhereUniqueInput;
};

export type PurchaseReturnItemUpdateWithWhereUniqueWithoutReturnInput = {
  data: PurchaseReturnItemUpdateWithoutReturnInput;
  where: PurchaseReturnItemWhereUniqueInput;
};

export type PurchaseReturnItemUpdateWithoutBatchInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutPurchaseReturnItemsNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  return?: InputMaybe<PurchaseReturnUpdateOneRequiredWithoutItemsNestedInput>;
};

export type PurchaseReturnItemUpdateWithoutProductVariantInput = {
  batch?: InputMaybe<StockReceiptBatchUpdateOneRequiredWithoutPurchaseReturnsNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  return?: InputMaybe<PurchaseReturnUpdateOneRequiredWithoutItemsNestedInput>;
};

export type PurchaseReturnItemUpdateWithoutReturnInput = {
  batch?: InputMaybe<StockReceiptBatchUpdateOneRequiredWithoutPurchaseReturnsNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutPurchaseReturnItemsNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type PurchaseReturnItemUpsertWithWhereUniqueWithoutBatchInput = {
  create: PurchaseReturnItemCreateWithoutBatchInput;
  update: PurchaseReturnItemUpdateWithoutBatchInput;
  where: PurchaseReturnItemWhereUniqueInput;
};

export type PurchaseReturnItemUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: PurchaseReturnItemCreateWithoutProductVariantInput;
  update: PurchaseReturnItemUpdateWithoutProductVariantInput;
  where: PurchaseReturnItemWhereUniqueInput;
};

export type PurchaseReturnItemUpsertWithWhereUniqueWithoutReturnInput = {
  create: PurchaseReturnItemCreateWithoutReturnInput;
  update: PurchaseReturnItemUpdateWithoutReturnInput;
  where: PurchaseReturnItemWhereUniqueInput;
};

export type PurchaseReturnItemWhereInput = {
  AND?: InputMaybe<Array<PurchaseReturnItemWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseReturnItemWhereInput>>;
  OR?: InputMaybe<Array<PurchaseReturnItemWhereInput>>;
  batch?: InputMaybe<StockReceiptBatchScalarRelationFilter>;
  batchId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  purchaseReturnId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  return?: InputMaybe<PurchaseReturnScalarRelationFilter>;
};

export type PurchaseReturnItemWhereUniqueInput = {
  AND?: InputMaybe<Array<PurchaseReturnItemWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseReturnItemWhereInput>>;
  OR?: InputMaybe<Array<PurchaseReturnItemWhereInput>>;
  batch?: InputMaybe<StockReceiptBatchScalarRelationFilter>;
  batchId?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  purchaseReturnId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  return?: InputMaybe<PurchaseReturnScalarRelationFilter>;
};

export type PurchaseReturnListRelationFilter = {
  every?: InputMaybe<PurchaseReturnWhereInput>;
  none?: InputMaybe<PurchaseReturnWhereInput>;
  some?: InputMaybe<PurchaseReturnWhereInput>;
};

export type PurchaseReturnOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type PurchaseReturnScalarRelationFilter = {
  is?: InputMaybe<PurchaseReturnWhereInput>;
  isNot?: InputMaybe<PurchaseReturnWhereInput>;
};

export type PurchaseReturnScalarWhereInput = {
  AND?: InputMaybe<Array<PurchaseReturnScalarWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseReturnScalarWhereInput>>;
  OR?: InputMaybe<Array<PurchaseReturnScalarWhereInput>>;
  approvedById?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  initiatedById?: InputMaybe<StringFilter>;
  reason?: InputMaybe<StringNullableFilter>;
  status?: InputMaybe<EnumReturnStatusFilter>;
  supplierId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type PurchaseReturnUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  reason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseReturnUpdateManyWithWhereWithoutApprovedByInput = {
  data: PurchaseReturnUpdateManyMutationInput;
  where: PurchaseReturnScalarWhereInput;
};

export type PurchaseReturnUpdateManyWithWhereWithoutInitiatedByInput = {
  data: PurchaseReturnUpdateManyMutationInput;
  where: PurchaseReturnScalarWhereInput;
};

export type PurchaseReturnUpdateManyWithWhereWithoutSupplierInput = {
  data: PurchaseReturnUpdateManyMutationInput;
  where: PurchaseReturnScalarWhereInput;
};

export type PurchaseReturnUpdateManyWithoutApprovedByNestedInput = {
  connect?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnCreateOrConnectWithoutApprovedByInput>>;
  create?: InputMaybe<Array<PurchaseReturnCreateWithoutApprovedByInput>>;
  createMany?: InputMaybe<PurchaseReturnCreateManyApprovedByInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseReturnScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseReturnUpdateWithWhereUniqueWithoutApprovedByInput>>;
  updateMany?: InputMaybe<Array<PurchaseReturnUpdateManyWithWhereWithoutApprovedByInput>>;
  upsert?: InputMaybe<Array<PurchaseReturnUpsertWithWhereUniqueWithoutApprovedByInput>>;
};

export type PurchaseReturnUpdateManyWithoutInitiatedByNestedInput = {
  connect?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnCreateOrConnectWithoutInitiatedByInput>>;
  create?: InputMaybe<Array<PurchaseReturnCreateWithoutInitiatedByInput>>;
  createMany?: InputMaybe<PurchaseReturnCreateManyInitiatedByInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseReturnScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseReturnUpdateWithWhereUniqueWithoutInitiatedByInput>>;
  updateMany?: InputMaybe<Array<PurchaseReturnUpdateManyWithWhereWithoutInitiatedByInput>>;
  upsert?: InputMaybe<Array<PurchaseReturnUpsertWithWhereUniqueWithoutInitiatedByInput>>;
};

export type PurchaseReturnUpdateManyWithoutSupplierNestedInput = {
  connect?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<PurchaseReturnCreateOrConnectWithoutSupplierInput>>;
  create?: InputMaybe<Array<PurchaseReturnCreateWithoutSupplierInput>>;
  createMany?: InputMaybe<PurchaseReturnCreateManySupplierInputEnvelope>;
  delete?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<PurchaseReturnScalarWhereInput>>;
  disconnect?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  set?: InputMaybe<Array<PurchaseReturnWhereUniqueInput>>;
  update?: InputMaybe<Array<PurchaseReturnUpdateWithWhereUniqueWithoutSupplierInput>>;
  updateMany?: InputMaybe<Array<PurchaseReturnUpdateManyWithWhereWithoutSupplierInput>>;
  upsert?: InputMaybe<Array<PurchaseReturnUpsertWithWhereUniqueWithoutSupplierInput>>;
};

export type PurchaseReturnUpdateOneRequiredWithoutItemsNestedInput = {
  connect?: InputMaybe<PurchaseReturnWhereUniqueInput>;
  connectOrCreate?: InputMaybe<PurchaseReturnCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<PurchaseReturnCreateWithoutItemsInput>;
  update?: InputMaybe<PurchaseReturnUpdateToOneWithWhereWithoutItemsInput>;
  upsert?: InputMaybe<PurchaseReturnUpsertWithoutItemsInput>;
};

export type PurchaseReturnUpdateToOneWithWhereWithoutItemsInput = {
  data: PurchaseReturnUpdateWithoutItemsInput;
  where?: InputMaybe<PurchaseReturnWhereInput>;
};

export type PurchaseReturnUpdateWithWhereUniqueWithoutApprovedByInput = {
  data: PurchaseReturnUpdateWithoutApprovedByInput;
  where: PurchaseReturnWhereUniqueInput;
};

export type PurchaseReturnUpdateWithWhereUniqueWithoutInitiatedByInput = {
  data: PurchaseReturnUpdateWithoutInitiatedByInput;
  where: PurchaseReturnWhereUniqueInput;
};

export type PurchaseReturnUpdateWithWhereUniqueWithoutSupplierInput = {
  data: PurchaseReturnUpdateWithoutSupplierInput;
  where: PurchaseReturnWhereUniqueInput;
};

export type PurchaseReturnUpdateWithoutApprovedByInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  initiatedBy?: InputMaybe<UserUpdateOneRequiredWithoutPurchaseReturnInitiatorsNestedInput>;
  items?: InputMaybe<PurchaseReturnItemUpdateManyWithoutReturnNestedInput>;
  reason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  supplier?: InputMaybe<SupplierUpdateOneRequiredWithoutReturnsNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseReturnUpdateWithoutInitiatedByInput = {
  approvedBy?: InputMaybe<UserUpdateOneRequiredWithoutPurchaseReturnApproversNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<PurchaseReturnItemUpdateManyWithoutReturnNestedInput>;
  reason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  supplier?: InputMaybe<SupplierUpdateOneRequiredWithoutReturnsNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseReturnUpdateWithoutItemsInput = {
  approvedBy?: InputMaybe<UserUpdateOneRequiredWithoutPurchaseReturnApproversNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  initiatedBy?: InputMaybe<UserUpdateOneRequiredWithoutPurchaseReturnInitiatorsNestedInput>;
  reason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  supplier?: InputMaybe<SupplierUpdateOneRequiredWithoutReturnsNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseReturnUpdateWithoutSupplierInput = {
  approvedBy?: InputMaybe<UserUpdateOneRequiredWithoutPurchaseReturnApproversNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  initiatedBy?: InputMaybe<UserUpdateOneRequiredWithoutPurchaseReturnInitiatorsNestedInput>;
  items?: InputMaybe<PurchaseReturnItemUpdateManyWithoutReturnNestedInput>;
  reason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type PurchaseReturnUpsertWithWhereUniqueWithoutApprovedByInput = {
  create: PurchaseReturnCreateWithoutApprovedByInput;
  update: PurchaseReturnUpdateWithoutApprovedByInput;
  where: PurchaseReturnWhereUniqueInput;
};

export type PurchaseReturnUpsertWithWhereUniqueWithoutInitiatedByInput = {
  create: PurchaseReturnCreateWithoutInitiatedByInput;
  update: PurchaseReturnUpdateWithoutInitiatedByInput;
  where: PurchaseReturnWhereUniqueInput;
};

export type PurchaseReturnUpsertWithWhereUniqueWithoutSupplierInput = {
  create: PurchaseReturnCreateWithoutSupplierInput;
  update: PurchaseReturnUpdateWithoutSupplierInput;
  where: PurchaseReturnWhereUniqueInput;
};

export type PurchaseReturnUpsertWithoutItemsInput = {
  create: PurchaseReturnCreateWithoutItemsInput;
  update: PurchaseReturnUpdateWithoutItemsInput;
  where?: InputMaybe<PurchaseReturnWhereInput>;
};

export type PurchaseReturnWhereInput = {
  AND?: InputMaybe<Array<PurchaseReturnWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseReturnWhereInput>>;
  OR?: InputMaybe<Array<PurchaseReturnWhereInput>>;
  approvedBy?: InputMaybe<UserScalarRelationFilter>;
  approvedById?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  initiatedBy?: InputMaybe<UserScalarRelationFilter>;
  initiatedById?: InputMaybe<StringFilter>;
  items?: InputMaybe<PurchaseReturnItemListRelationFilter>;
  reason?: InputMaybe<StringNullableFilter>;
  status?: InputMaybe<EnumReturnStatusFilter>;
  supplier?: InputMaybe<SupplierScalarRelationFilter>;
  supplierId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type PurchaseReturnWhereUniqueInput = {
  AND?: InputMaybe<Array<PurchaseReturnWhereInput>>;
  NOT?: InputMaybe<Array<PurchaseReturnWhereInput>>;
  OR?: InputMaybe<Array<PurchaseReturnWhereInput>>;
  approvedBy?: InputMaybe<UserScalarRelationFilter>;
  approvedById?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  initiatedBy?: InputMaybe<UserScalarRelationFilter>;
  initiatedById?: InputMaybe<StringFilter>;
  items?: InputMaybe<PurchaseReturnItemListRelationFilter>;
  reason?: InputMaybe<StringNullableFilter>;
  status?: InputMaybe<EnumReturnStatusFilter>;
  supplier?: InputMaybe<SupplierScalarRelationFilter>;
  supplierId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type PurchaseSelectionItemInput = {
  productVariantId: Scalars['String']['input'];
  quantity?: InputMaybe<Scalars['Float']['input']>;
  supplierId: Scalars['String']['input'];
  unitCost?: InputMaybe<Scalars['Float']['input']>;
};

export type Query = {
  __typename?: 'Query';
  adminProcurementDashboard: AdminProcurementDashboard;
  adminProcurementDashboardByStore: AdminProcurementDashboard;
  aggregateAsset: AggregateAsset;
  aggregateProduct: AggregateProduct;
  aggregateProductVariant: AggregateProductVariant;
  aggregateStore: AggregateStore;
  aggregateUser: AggregateUser;
  asset?: Maybe<Asset>;
  assetAssignments: Array<AssetAssignment>;
  assets: Array<Asset>;
  billerPaymentsSummary: BillerPaymentsSummary;
  billerPaymentsSummaryByStore: Array<BillerPaymentsSummary>;
  billerPaymentsSummaryRange: BillerPaymentsSummary;
  collection: CollectionGql;
  collectionMembersCount: Scalars['Int']['output'];
  collectionProducts: Array<Product>;
  collectionVariants: Array<ProductVariant>;
  collections: Array<CollectionGql>;
  consumerPaymentsByOrder: Array<ConsumerPayment>;
  consumerReceiptsByCustomer: Array<ConsumerReceipt>;
  consumerSalesByCustomer: Array<ConsumerSale>;
  customerAffinity: Array<CustomerAffinityEntry>;
  dailyPaymentsSeries: Array<PaymentDaySeries>;
  dailyPaymentsSeriesRange: Array<PaymentDaySeries>;
  devCounts: DevCounts;
  devExportSnapshot: Scalars['String']['output'];
  findFirstAsset?: Maybe<Asset>;
  findFirstProduct?: Maybe<Product>;
  findFirstProductVariant?: Maybe<ProductVariant>;
  findFirstStore: Store;
  findFirstUser: User;
  findUniqueProduct?: Maybe<Product>;
  findUniqueProductVariant?: Maybe<ProductVariant>;
  findUniqueStore: Store;
  findUniqueUser: User;
  groupByAsset: Array<AssetGroupBy>;
  groupByProduct: Array<ProductGroupBy>;
  groupByProductVariant: Array<ProductVariantGroupBy>;
  groupByStore: Array<StoreGroupBy>;
  groupByUser: Array<UserGroupBy>;
  invoiceImport?: Maybe<InvoiceImport>;
  invoiceImports: Array<InvoiceImport>;
  lastAutoRequisitionIdByStore?: Maybe<Scalars['String']['output']>;
  lastFailedOutboxEvents: Array<OutboxEvent>;
  listBillers: Array<User>;
  listFacets: Array<FacetGql>;
  listManagers: Array<User>;
  listProductVariants: Array<ProductVariant>;
  listProducts: Array<Product>;
  listStores: Array<Store>;
  listSuppliers: Array<Supplier>;
  listUsers: Array<User>;
  lowStockByStore: Array<ProductVariant>;
  lowStockCandidates: Array<LowStockCandidate>;
  me: User;
  monthlySalesSummary: MonthlySalesSummary;
  monthlySalesSummaryByStore: MonthlySalesSummary;
  mySupportMessages: Array<SupportMessage>;
  notifications: Array<Notification>;
  order: SaleOrder;
  orderPaymentSummary: PaymentOrderSummary;
  ordersQuery: Array<SaleOrder>;
  outboxStatus: OutboxStatusCounts;
  outboxStatusByType: Array<OutboxTypeCount>;
  outboxStatusSeries: Array<OutboxDayStatus>;
  paymentMethodBreakdown: Array<PaymentMethodBreakdownEntry>;
  paymentMethodBreakdownRange: Array<PaymentMethodBreakdownEntry>;
  pendingResellerApplications: Array<ResellerProfile>;
  primaryAssetAssignment?: Maybe<AssetAssignment>;
  productFacets: Array<FacetAssignment>;
  productVariantsCount: Scalars['Int']['output'];
  purchaseOrder: PurchaseOrder;
  purchaseOrderReceiptProgress: Array<PurchaseOrderReceiptProgress>;
  purchaseOrders: Array<PurchaseOrder>;
  purchaseOrdersByPhase: Array<PurchaseOrder>;
  purchaseOrdersByPhaseEnum: Array<PurchaseOrder>;
  purchaseOrdersByStatus: Array<PurchaseOrder>;
  purchaseOrdersByStatusEnum: Array<PurchaseOrder>;
  purchaseOrdersBySupplier: Array<PurchaseOrder>;
  purchaseOrdersCount: Scalars['Int']['output'];
  purchaseOrdersOverdue: Array<PurchaseOrder>;
  purchaseOrdersOverdueByStore: Array<PurchaseOrder>;
  purchaseOrdersSearch: Array<PurchaseOrder>;
  purchaseOrdersSearchCount: Scalars['Int']['output'];
  purchaseRequisitionSummary?: Maybe<RequisitionSummary>;
  purchaseReturnsBySupplier: Array<PurchaseReturn>;
  recentSupportThreads: Array<SupportMessage>;
  requisitionsByStatus: Array<RequisitionSummary>;
  requisitionsByStore: Array<RequisitionSummary>;
  requisitionsCountByStatus: Scalars['Int']['output'];
  requisitionsCountByStore: Scalars['Int']['output'];
  requisitionsWithNoSubmittedQuotes: Array<RequisitionSummary>;
  requisitionsWithNoSubmittedQuotesByStore: Array<RequisitionSummary>;
  requisitionsWithPartialSubmissions: Array<RequisitionSummary>;
  requisitionsWithPartialSubmissionsByStore: Array<RequisitionSummary>;
  resellerPaymentsByOrder: Array<ResellerPayment>;
  resellerProfile?: Maybe<ResellerProfile>;
  resellers: Array<ResellerProfile>;
  rfqCountsAll: RfqStatusCounts;
  rfqDashboard: RfqDashboard;
  rfqDashboardAll: RfqDashboard;
  rfqDashboardByStore: RfqDashboard;
  rfqPendingSuppliers: Array<SupplierQuoteSummary>;
  rfqStatusCounts: RfqStatusCounts;
  rfqStatusCountsByStore: RfqStatusCounts;
  salesReturnsByConsumerSale: Array<SalesReturn>;
  salesReturnsByResellerSale: Array<SalesReturn>;
  salesReturnsByStore: Array<SalesReturn>;
  stock: Array<Stock>;
  stockMovements: Array<StockMovement>;
  stockTotalsByProduct: Array<VariantStockTotal>;
  stockTotalsByProductStore: Array<VariantStockTotal>;
  storePaymentsSummary: StorePaymentsSummary;
  storePaymentsSummaryRange: StorePaymentsSummary;
  /** List stores whose managerId does not resolve to a User */
  storesWithInvalidManagers: Array<StoreManagerDiagnostic>;
  supplier: Supplier;
  supplierCatalogBySupplier: Array<SupplierCatalogEntry>;
  supplierCatalogByVariant: Array<SupplierCatalogEntry>;
  supplierPaymentMethodBreakdown: Array<SupplierPaymentMethodBreakdownEntry>;
  supplierPayments: Array<SupplierPayment>;
  supplierPaymentsByPO: Array<SupplierPayment>;
  supplierPaymentsBySupplier: Array<SupplierPayment>;
  supplierPaymentsSummary: SupplierPaymentsSummary;
  supplierQuotesByRequisition: Array<SupplierQuoteSummary>;
  suppliers: Array<Supplier>;
  suppliersForVariant: Array<SupplierCatalogEntry>;
  supportConversation: Array<SupportMessage>;
  tierPricesForVariant: Array<VariantTierPrice>;
  topSellingVariants: Array<VariantMonthlySales>;
  topSellingVariantsByStore: Array<VariantSalesWithDetails>;
  topSellingVariantsDetailed: Array<VariantSalesWithDetails>;
  variantFacets: Array<FacetAssignment>;
  variantsByStore: Array<ProductVariant>;
  /** List product variants whose product linkage is invalid or missing */
  variantsWithInvalidProducts: Array<OrphanVariantDiagnostic>;
};


export type QueryAdminProcurementDashboardByStoreArgs = {
  storeId: Scalars['String']['input'];
};


export type QueryAggregateAssetArgs = {
  _avg?: InputMaybe<AssetAvgAggregateInput>;
  _count?: InputMaybe<AssetCountAggregateInput>;
  _max?: InputMaybe<AssetMaxAggregateInput>;
  _min?: InputMaybe<AssetMinAggregateInput>;
  _sum?: InputMaybe<AssetSumAggregateInput>;
  cursor?: InputMaybe<AssetWhereUniqueInput>;
  orderBy?: InputMaybe<Array<AssetOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AssetWhereInput>;
};


export type QueryAggregateProductArgs = {
  _count?: InputMaybe<ProductCountAggregateInput>;
  _max?: InputMaybe<ProductMaxAggregateInput>;
  _min?: InputMaybe<ProductMinAggregateInput>;
  cursor?: InputMaybe<ProductWhereUniqueInput>;
  orderBy?: InputMaybe<Array<ProductOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductWhereInput>;
};


export type QueryAggregateProductVariantArgs = {
  _avg?: InputMaybe<ProductVariantAvgAggregateInput>;
  _count?: InputMaybe<ProductVariantCountAggregateInput>;
  _max?: InputMaybe<ProductVariantMaxAggregateInput>;
  _min?: InputMaybe<ProductVariantMinAggregateInput>;
  _sum?: InputMaybe<ProductVariantSumAggregateInput>;
  cursor?: InputMaybe<ProductVariantWhereUniqueInput>;
  orderBy?: InputMaybe<Array<ProductVariantOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductVariantWhereInput>;
};


export type QueryAggregateStoreArgs = {
  _count?: InputMaybe<StoreCountAggregateInput>;
  _max?: InputMaybe<StoreMaxAggregateInput>;
  _min?: InputMaybe<StoreMinAggregateInput>;
  cursor?: InputMaybe<StoreWhereUniqueInput>;
  orderBy?: InputMaybe<Array<StoreOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<StoreWhereInput>;
};


export type QueryAggregateUserArgs = {
  _count?: InputMaybe<UserCountAggregateInput>;
  _max?: InputMaybe<UserMaxAggregateInput>;
  _min?: InputMaybe<UserMinAggregateInput>;
  cursor?: InputMaybe<UserWhereUniqueInput>;
  orderBy?: InputMaybe<Array<UserOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryAssetArgs = {
  where: AssetWhereUniqueInput;
};


export type QueryAssetAssignmentsArgs = {
  input: AssetAssignmentsByEntityInput;
};


export type QueryAssetsArgs = {
  cursor?: InputMaybe<AssetWhereUniqueInput>;
  distinct?: InputMaybe<Array<AssetScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AssetOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AssetWhereInput>;
};


export type QueryBillerPaymentsSummaryArgs = {
  billerId: Scalars['String']['input'];
  month?: InputMaybe<Scalars['String']['input']>;
  storeId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryBillerPaymentsSummaryByStoreArgs = {
  month?: InputMaybe<Scalars['String']['input']>;
  storeId: Scalars['String']['input'];
};


export type QueryBillerPaymentsSummaryRangeArgs = {
  billerId: Scalars['String']['input'];
  end: Scalars['DateTime']['input'];
  start: Scalars['DateTime']['input'];
  storeId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryCollectionArgs = {
  id: Scalars['String']['input'];
};


export type QueryCollectionMembersCountArgs = {
  id: Scalars['String']['input'];
};


export type QueryCollectionProductsArgs = {
  id: Scalars['String']['input'];
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryCollectionVariantsArgs = {
  id: Scalars['String']['input'];
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryConsumerPaymentsByOrderArgs = {
  saleOrderId: Scalars['String']['input'];
};


export type QueryConsumerReceiptsByCustomerArgs = {
  cursorId?: InputMaybe<Scalars['String']['input']>;
  customerId: Scalars['String']['input'];
  order?: InputMaybe<Scalars['String']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryConsumerSalesByCustomerArgs = {
  cursorId?: InputMaybe<Scalars['String']['input']>;
  customerId: Scalars['String']['input'];
  order?: InputMaybe<Scalars['String']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryCustomerAffinityArgs = {
  customerId: Scalars['String']['input'];
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryDailyPaymentsSeriesArgs = {
  billerId?: InputMaybe<Scalars['String']['input']>;
  month?: InputMaybe<Scalars['String']['input']>;
  storeId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryDailyPaymentsSeriesRangeArgs = {
  billerId?: InputMaybe<Scalars['String']['input']>;
  end: Scalars['DateTime']['input'];
  start: Scalars['DateTime']['input'];
  storeId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryDevExportSnapshotArgs = {
  filter?: InputMaybe<DevPurgeFilter>;
  tables: Array<Scalars['String']['input']>;
};


export type QueryFindFirstAssetArgs = {
  cursor?: InputMaybe<AssetWhereUniqueInput>;
  distinct?: InputMaybe<Array<AssetScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<AssetOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AssetWhereInput>;
};


export type QueryFindFirstProductArgs = {
  cursor?: InputMaybe<ProductWhereUniqueInput>;
  distinct?: InputMaybe<Array<ProductScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ProductOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductWhereInput>;
};


export type QueryFindFirstProductVariantArgs = {
  cursor?: InputMaybe<ProductVariantWhereUniqueInput>;
  distinct?: InputMaybe<Array<ProductVariantScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ProductVariantOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductVariantWhereInput>;
};


export type QueryFindFirstStoreArgs = {
  cursor?: InputMaybe<StoreWhereUniqueInput>;
  distinct?: InputMaybe<Array<StoreScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StoreOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<StoreWhereInput>;
};


export type QueryFindFirstUserArgs = {
  cursor?: InputMaybe<UserWhereUniqueInput>;
  distinct?: InputMaybe<Array<UserScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<UserOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryFindUniqueProductArgs = {
  where: ProductWhereUniqueInput;
};


export type QueryFindUniqueProductVariantArgs = {
  where: ProductVariantWhereUniqueInput;
};


export type QueryFindUniqueStoreArgs = {
  where: StoreWhereUniqueInput;
};


export type QueryFindUniqueUserArgs = {
  where: UserWhereUniqueInput;
};


export type QueryGroupByAssetArgs = {
  _avg?: InputMaybe<AssetAvgAggregateInput>;
  _count?: InputMaybe<AssetCountAggregateInput>;
  _max?: InputMaybe<AssetMaxAggregateInput>;
  _min?: InputMaybe<AssetMinAggregateInput>;
  _sum?: InputMaybe<AssetSumAggregateInput>;
  by: Array<AssetScalarFieldEnum>;
  having?: InputMaybe<AssetScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<AssetOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AssetWhereInput>;
};


export type QueryGroupByProductArgs = {
  _count?: InputMaybe<ProductCountAggregateInput>;
  _max?: InputMaybe<ProductMaxAggregateInput>;
  _min?: InputMaybe<ProductMinAggregateInput>;
  by: Array<ProductScalarFieldEnum>;
  having?: InputMaybe<ProductScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<ProductOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductWhereInput>;
};


export type QueryGroupByProductVariantArgs = {
  _avg?: InputMaybe<ProductVariantAvgAggregateInput>;
  _count?: InputMaybe<ProductVariantCountAggregateInput>;
  _max?: InputMaybe<ProductVariantMaxAggregateInput>;
  _min?: InputMaybe<ProductVariantMinAggregateInput>;
  _sum?: InputMaybe<ProductVariantSumAggregateInput>;
  by: Array<ProductVariantScalarFieldEnum>;
  having?: InputMaybe<ProductVariantScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<ProductVariantOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductVariantWhereInput>;
};


export type QueryGroupByStoreArgs = {
  _count?: InputMaybe<StoreCountAggregateInput>;
  _max?: InputMaybe<StoreMaxAggregateInput>;
  _min?: InputMaybe<StoreMinAggregateInput>;
  by: Array<StoreScalarFieldEnum>;
  having?: InputMaybe<StoreScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<StoreOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<StoreWhereInput>;
};


export type QueryGroupByUserArgs = {
  _count?: InputMaybe<UserCountAggregateInput>;
  _max?: InputMaybe<UserMaxAggregateInput>;
  _min?: InputMaybe<UserMinAggregateInput>;
  by: Array<UserScalarFieldEnum>;
  having?: InputMaybe<UserScalarWhereWithAggregatesInput>;
  orderBy?: InputMaybe<Array<UserOrderByWithAggregationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryInvoiceImportArgs = {
  id: Scalars['String']['input'];
};


export type QueryLastAutoRequisitionIdByStoreArgs = {
  storeId: Scalars['String']['input'];
};


export type QueryLastFailedOutboxEventsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
};


export type QueryListProductVariantsArgs = {
  cursor?: InputMaybe<ProductVariantWhereUniqueInput>;
  distinct?: InputMaybe<Array<ProductVariantScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ProductVariantOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductVariantWhereInput>;
};


export type QueryListProductsArgs = {
  cursor?: InputMaybe<ProductWhereUniqueInput>;
  distinct?: InputMaybe<Array<ProductScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<ProductOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductWhereInput>;
};


export type QueryListStoresArgs = {
  cursor?: InputMaybe<StoreWhereUniqueInput>;
  distinct?: InputMaybe<Array<StoreScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<StoreOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<StoreWhereInput>;
};


export type QueryListSuppliersArgs = {
  cursor?: InputMaybe<SupplierWhereUniqueInput>;
  distinct?: InputMaybe<Array<SupplierScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<SupplierOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<SupplierWhereInput>;
};


export type QueryListUsersArgs = {
  cursor?: InputMaybe<UserWhereUniqueInput>;
  distinct?: InputMaybe<Array<UserScalarFieldEnum>>;
  orderBy?: InputMaybe<Array<UserOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryLowStockByStoreArgs = {
  storeId: Scalars['String']['input'];
};


export type QueryLowStockCandidatesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  storeId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryMonthlySalesSummaryArgs = {
  month?: InputMaybe<Scalars['String']['input']>;
};


export type QueryMonthlySalesSummaryByStoreArgs = {
  month?: InputMaybe<Scalars['String']['input']>;
  storeId: Scalars['String']['input'];
};


export type QueryOrderArgs = {
  id: Scalars['String']['input'];
};


export type QueryOrderPaymentSummaryArgs = {
  saleOrderId: Scalars['String']['input'];
};


export type QueryOutboxStatusByTypeArgs = {
  types?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type QueryOutboxStatusSeriesArgs = {
  end: Scalars['DateTime']['input'];
  start: Scalars['DateTime']['input'];
  type?: InputMaybe<Scalars['String']['input']>;
};


export type QueryPaymentMethodBreakdownArgs = {
  billerId?: InputMaybe<Scalars['String']['input']>;
  month?: InputMaybe<Scalars['String']['input']>;
  storeId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryPaymentMethodBreakdownRangeArgs = {
  billerId?: InputMaybe<Scalars['String']['input']>;
  end: Scalars['DateTime']['input'];
  start: Scalars['DateTime']['input'];
  storeId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryPendingResellerApplicationsArgs = {
  q?: InputMaybe<Scalars['String']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPrimaryAssetAssignmentArgs = {
  input: AssetAssignmentsByEntityInput;
};


export type QueryProductFacetsArgs = {
  productId: Scalars['String']['input'];
};


export type QueryProductVariantsCountArgs = {
  where?: InputMaybe<ProductVariantWhereInput>;
};


export type QueryPurchaseOrderArgs = {
  id: Scalars['String']['input'];
};


export type QueryPurchaseOrderReceiptProgressArgs = {
  purchaseOrderId: Scalars['String']['input'];
};


export type QueryPurchaseOrdersArgs = {
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPurchaseOrdersByPhaseArgs = {
  phase: Scalars['String']['input'];
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPurchaseOrdersByPhaseEnumArgs = {
  phase: PurchasePhase;
};


export type QueryPurchaseOrdersByStatusArgs = {
  skip?: InputMaybe<Scalars['Int']['input']>;
  status: Scalars['String']['input'];
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPurchaseOrdersByStatusEnumArgs = {
  status: PurchaseOrderStatus;
};


export type QueryPurchaseOrdersBySupplierArgs = {
  skip?: InputMaybe<Scalars['Int']['input']>;
  supplierId: Scalars['String']['input'];
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPurchaseOrdersCountArgs = {
  phase?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
};


export type QueryPurchaseOrdersOverdueByStoreArgs = {
  storeId: Scalars['String']['input'];
};


export type QueryPurchaseOrdersSearchArgs = {
  q: Scalars['String']['input'];
  skip?: InputMaybe<Scalars['Int']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPurchaseOrdersSearchCountArgs = {
  q: Scalars['String']['input'];
};


export type QueryPurchaseRequisitionSummaryArgs = {
  id: Scalars['String']['input'];
};


export type QueryPurchaseReturnsBySupplierArgs = {
  supplierId: Scalars['String']['input'];
};


export type QueryRecentSupportThreadsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryRequisitionsByStatusArgs = {
  skip?: InputMaybe<Scalars['Int']['input']>;
  status: Scalars['String']['input'];
  storeId?: InputMaybe<Scalars['String']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryRequisitionsByStoreArgs = {
  skip?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  storeId: Scalars['String']['input'];
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryRequisitionsCountByStatusArgs = {
  status: Scalars['String']['input'];
  storeId?: InputMaybe<Scalars['String']['input']>;
};


export type QueryRequisitionsCountByStoreArgs = {
  status?: InputMaybe<Scalars['String']['input']>;
  storeId: Scalars['String']['input'];
};


export type QueryRequisitionsWithNoSubmittedQuotesByStoreArgs = {
  storeId: Scalars['String']['input'];
};


export type QueryRequisitionsWithPartialSubmissionsByStoreArgs = {
  storeId: Scalars['String']['input'];
};


export type QueryResellerPaymentsByOrderArgs = {
  saleOrderId: Scalars['String']['input'];
};


export type QueryResellerProfileArgs = {
  userId: Scalars['String']['input'];
};


export type QueryResellersArgs = {
  q?: InputMaybe<Scalars['String']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<Scalars['String']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryRfqDashboardArgs = {
  requisitionId: Scalars['String']['input'];
};


export type QueryRfqDashboardByStoreArgs = {
  storeId: Scalars['String']['input'];
};


export type QueryRfqPendingSuppliersArgs = {
  requisitionId: Scalars['String']['input'];
};


export type QueryRfqStatusCountsArgs = {
  requisitionId: Scalars['String']['input'];
};


export type QueryRfqStatusCountsByStoreArgs = {
  storeId: Scalars['String']['input'];
};


export type QuerySalesReturnsByConsumerSaleArgs = {
  consumerSaleId: Scalars['String']['input'];
};


export type QuerySalesReturnsByResellerSaleArgs = {
  resellerSaleId: Scalars['String']['input'];
};


export type QuerySalesReturnsByStoreArgs = {
  storeId: Scalars['String']['input'];
};


export type QueryStockArgs = {
  input?: InputMaybe<QueryStockInput>;
};


export type QueryStockMovementsArgs = {
  storeId: Scalars['String']['input'];
};


export type QueryStockTotalsByProductArgs = {
  productId: Scalars['String']['input'];
};


export type QueryStockTotalsByProductStoreArgs = {
  productId: Scalars['String']['input'];
  storeId: Scalars['String']['input'];
};


export type QueryStorePaymentsSummaryArgs = {
  month?: InputMaybe<Scalars['String']['input']>;
  storeId: Scalars['String']['input'];
};


export type QueryStorePaymentsSummaryRangeArgs = {
  end: Scalars['DateTime']['input'];
  start: Scalars['DateTime']['input'];
  storeId: Scalars['String']['input'];
};


export type QuerySupplierArgs = {
  id: Scalars['String']['input'];
};


export type QuerySupplierCatalogBySupplierArgs = {
  supplierId: Scalars['String']['input'];
};


export type QuerySupplierCatalogByVariantArgs = {
  productVariantId: Scalars['String']['input'];
};


export type QuerySupplierPaymentMethodBreakdownArgs = {
  month?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySupplierPaymentsByPoArgs = {
  purchaseOrderId: Scalars['String']['input'];
};


export type QuerySupplierPaymentsBySupplierArgs = {
  supplierId: Scalars['String']['input'];
};


export type QuerySupplierPaymentsSummaryArgs = {
  month?: InputMaybe<Scalars['String']['input']>;
  supplierId: Scalars['String']['input'];
};


export type QuerySupplierQuotesByRequisitionArgs = {
  requisitionId: Scalars['String']['input'];
};


export type QuerySuppliersForVariantArgs = {
  productVariantId: Scalars['String']['input'];
};


export type QuerySupportConversationArgs = {
  userId: Scalars['String']['input'];
};


export type QueryTierPricesForVariantArgs = {
  productVariantId: Scalars['String']['input'];
};


export type QueryTopSellingVariantsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  month?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTopSellingVariantsByStoreArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  month?: InputMaybe<Scalars['String']['input']>;
  storeId: Scalars['String']['input'];
};


export type QueryTopSellingVariantsDetailedArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  month?: InputMaybe<Scalars['String']['input']>;
};


export type QueryVariantFacetsArgs = {
  productVariantId: Scalars['String']['input'];
};


export type QueryVariantsByStoreArgs = {
  search?: InputMaybe<Scalars['String']['input']>;
  storeId: Scalars['String']['input'];
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export type QueryStockInput = {
  productVariantId?: InputMaybe<Scalars['ID']['input']>;
  storeId?: InputMaybe<Scalars['ID']['input']>;
};

export type Quotation = {
  __typename?: 'Quotation';
  ConsumerSale?: Maybe<Array<ConsumerSale>>;
  SaleOrder?: Maybe<SaleOrder>;
  _count: QuotationCount;
  biller?: Maybe<User>;
  billerId?: Maybe<Scalars['String']['output']>;
  channel: SaleChannel;
  consumer?: Maybe<Customer>;
  consumerId?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  items?: Maybe<Array<QuotationItem>>;
  reseller?: Maybe<User>;
  resellerId?: Maybe<Scalars['String']['output']>;
  sale?: Maybe<ResellerSale>;
  saleOrderId?: Maybe<Scalars['String']['output']>;
  status: QuotationStatus;
  store: Store;
  storeId: Scalars['String']['output'];
  totalAmount: Scalars['Float']['output'];
  type: SaleType;
  updatedAt: Scalars['DateTime']['output'];
};

export type QuotationCount = {
  __typename?: 'QuotationCount';
  ConsumerSale: Scalars['Int']['output'];
  items: Scalars['Int']['output'];
};

export type QuotationCreateManyBillerInput = {
  channel: SaleChannel;
  consumerId?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  resellerId?: InputMaybe<Scalars['String']['input']>;
  saleOrderId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<QuotationStatus>;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationCreateManyBillerInputEnvelope = {
  data: Array<QuotationCreateManyBillerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuotationCreateManyConsumerInput = {
  billerId?: InputMaybe<Scalars['String']['input']>;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  resellerId?: InputMaybe<Scalars['String']['input']>;
  saleOrderId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<QuotationStatus>;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationCreateManyConsumerInputEnvelope = {
  data: Array<QuotationCreateManyConsumerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuotationCreateManyResellerInput = {
  billerId?: InputMaybe<Scalars['String']['input']>;
  channel: SaleChannel;
  consumerId?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  saleOrderId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<QuotationStatus>;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationCreateManyResellerInputEnvelope = {
  data: Array<QuotationCreateManyResellerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuotationCreateManyStoreInput = {
  billerId?: InputMaybe<Scalars['String']['input']>;
  channel: SaleChannel;
  consumerId?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  resellerId?: InputMaybe<Scalars['String']['input']>;
  saleOrderId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<QuotationStatus>;
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationCreateManyStoreInputEnvelope = {
  data: Array<QuotationCreateManyStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuotationCreateNestedManyWithoutBillerInput = {
  connect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationCreateOrConnectWithoutBillerInput>>;
  create?: InputMaybe<Array<QuotationCreateWithoutBillerInput>>;
  createMany?: InputMaybe<QuotationCreateManyBillerInputEnvelope>;
};

export type QuotationCreateNestedManyWithoutConsumerInput = {
  connect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationCreateOrConnectWithoutConsumerInput>>;
  create?: InputMaybe<Array<QuotationCreateWithoutConsumerInput>>;
  createMany?: InputMaybe<QuotationCreateManyConsumerInputEnvelope>;
};

export type QuotationCreateNestedManyWithoutResellerInput = {
  connect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationCreateOrConnectWithoutResellerInput>>;
  create?: InputMaybe<Array<QuotationCreateWithoutResellerInput>>;
  createMany?: InputMaybe<QuotationCreateManyResellerInputEnvelope>;
};

export type QuotationCreateNestedManyWithoutStoreInput = {
  connect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<QuotationCreateWithoutStoreInput>>;
  createMany?: InputMaybe<QuotationCreateManyStoreInputEnvelope>;
};

export type QuotationCreateNestedOneWithoutConsumerSaleInput = {
  connect?: InputMaybe<QuotationWhereUniqueInput>;
  connectOrCreate?: InputMaybe<QuotationCreateOrConnectWithoutConsumerSaleInput>;
  create?: InputMaybe<QuotationCreateWithoutConsumerSaleInput>;
};

export type QuotationCreateNestedOneWithoutItemsInput = {
  connect?: InputMaybe<QuotationWhereUniqueInput>;
  connectOrCreate?: InputMaybe<QuotationCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<QuotationCreateWithoutItemsInput>;
};

export type QuotationCreateNestedOneWithoutSaleInput = {
  connect?: InputMaybe<QuotationWhereUniqueInput>;
  connectOrCreate?: InputMaybe<QuotationCreateOrConnectWithoutSaleInput>;
  create?: InputMaybe<QuotationCreateWithoutSaleInput>;
};

export type QuotationCreateNestedOneWithoutSaleOrderInput = {
  connect?: InputMaybe<QuotationWhereUniqueInput>;
  connectOrCreate?: InputMaybe<QuotationCreateOrConnectWithoutSaleOrderInput>;
  create?: InputMaybe<QuotationCreateWithoutSaleOrderInput>;
};

export type QuotationCreateOrConnectWithoutBillerInput = {
  create: QuotationCreateWithoutBillerInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationCreateOrConnectWithoutConsumerInput = {
  create: QuotationCreateWithoutConsumerInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationCreateOrConnectWithoutConsumerSaleInput = {
  create: QuotationCreateWithoutConsumerSaleInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationCreateOrConnectWithoutItemsInput = {
  create: QuotationCreateWithoutItemsInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationCreateOrConnectWithoutResellerInput = {
  create: QuotationCreateWithoutResellerInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationCreateOrConnectWithoutSaleInput = {
  create: QuotationCreateWithoutSaleInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationCreateOrConnectWithoutSaleOrderInput = {
  create: QuotationCreateWithoutSaleOrderInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationCreateOrConnectWithoutStoreInput = {
  create: QuotationCreateWithoutStoreInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationCreateWithoutBillerInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutQuotationInput>;
  SaleOrder?: InputMaybe<SaleOrderCreateNestedOneWithoutQuotationInput>;
  channel: SaleChannel;
  consumer?: InputMaybe<CustomerCreateNestedOneWithoutQuotationInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<QuotationItemCreateNestedManyWithoutQuotationInput>;
  reseller?: InputMaybe<UserCreateNestedOneWithoutResellerQuotationInput>;
  sale?: InputMaybe<ResellerSaleCreateNestedOneWithoutQuotationInput>;
  status?: InputMaybe<QuotationStatus>;
  store: StoreCreateNestedOneWithoutQuotationInput;
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationCreateWithoutConsumerInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutQuotationInput>;
  SaleOrder?: InputMaybe<SaleOrderCreateNestedOneWithoutQuotationInput>;
  biller?: InputMaybe<UserCreateNestedOneWithoutBillerQuotationInput>;
  channel: SaleChannel;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<QuotationItemCreateNestedManyWithoutQuotationInput>;
  reseller?: InputMaybe<UserCreateNestedOneWithoutResellerQuotationInput>;
  sale?: InputMaybe<ResellerSaleCreateNestedOneWithoutQuotationInput>;
  status?: InputMaybe<QuotationStatus>;
  store: StoreCreateNestedOneWithoutQuotationInput;
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationCreateWithoutConsumerSaleInput = {
  SaleOrder?: InputMaybe<SaleOrderCreateNestedOneWithoutQuotationInput>;
  biller?: InputMaybe<UserCreateNestedOneWithoutBillerQuotationInput>;
  channel: SaleChannel;
  consumer?: InputMaybe<CustomerCreateNestedOneWithoutQuotationInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<QuotationItemCreateNestedManyWithoutQuotationInput>;
  reseller?: InputMaybe<UserCreateNestedOneWithoutResellerQuotationInput>;
  sale?: InputMaybe<ResellerSaleCreateNestedOneWithoutQuotationInput>;
  status?: InputMaybe<QuotationStatus>;
  store: StoreCreateNestedOneWithoutQuotationInput;
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationCreateWithoutItemsInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutQuotationInput>;
  SaleOrder?: InputMaybe<SaleOrderCreateNestedOneWithoutQuotationInput>;
  biller?: InputMaybe<UserCreateNestedOneWithoutBillerQuotationInput>;
  channel: SaleChannel;
  consumer?: InputMaybe<CustomerCreateNestedOneWithoutQuotationInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  reseller?: InputMaybe<UserCreateNestedOneWithoutResellerQuotationInput>;
  sale?: InputMaybe<ResellerSaleCreateNestedOneWithoutQuotationInput>;
  status?: InputMaybe<QuotationStatus>;
  store: StoreCreateNestedOneWithoutQuotationInput;
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationCreateWithoutResellerInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutQuotationInput>;
  SaleOrder?: InputMaybe<SaleOrderCreateNestedOneWithoutQuotationInput>;
  biller?: InputMaybe<UserCreateNestedOneWithoutBillerQuotationInput>;
  channel: SaleChannel;
  consumer?: InputMaybe<CustomerCreateNestedOneWithoutQuotationInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<QuotationItemCreateNestedManyWithoutQuotationInput>;
  sale?: InputMaybe<ResellerSaleCreateNestedOneWithoutQuotationInput>;
  status?: InputMaybe<QuotationStatus>;
  store: StoreCreateNestedOneWithoutQuotationInput;
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationCreateWithoutSaleInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutQuotationInput>;
  SaleOrder?: InputMaybe<SaleOrderCreateNestedOneWithoutQuotationInput>;
  biller?: InputMaybe<UserCreateNestedOneWithoutBillerQuotationInput>;
  channel: SaleChannel;
  consumer?: InputMaybe<CustomerCreateNestedOneWithoutQuotationInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<QuotationItemCreateNestedManyWithoutQuotationInput>;
  reseller?: InputMaybe<UserCreateNestedOneWithoutResellerQuotationInput>;
  status?: InputMaybe<QuotationStatus>;
  store: StoreCreateNestedOneWithoutQuotationInput;
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationCreateWithoutSaleOrderInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutQuotationInput>;
  biller?: InputMaybe<UserCreateNestedOneWithoutBillerQuotationInput>;
  channel: SaleChannel;
  consumer?: InputMaybe<CustomerCreateNestedOneWithoutQuotationInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<QuotationItemCreateNestedManyWithoutQuotationInput>;
  reseller?: InputMaybe<UserCreateNestedOneWithoutResellerQuotationInput>;
  sale?: InputMaybe<ResellerSaleCreateNestedOneWithoutQuotationInput>;
  status?: InputMaybe<QuotationStatus>;
  store: StoreCreateNestedOneWithoutQuotationInput;
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationCreateWithoutStoreInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutQuotationInput>;
  SaleOrder?: InputMaybe<SaleOrderCreateNestedOneWithoutQuotationInput>;
  biller?: InputMaybe<UserCreateNestedOneWithoutBillerQuotationInput>;
  channel: SaleChannel;
  consumer?: InputMaybe<CustomerCreateNestedOneWithoutQuotationInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<QuotationItemCreateNestedManyWithoutQuotationInput>;
  reseller?: InputMaybe<UserCreateNestedOneWithoutResellerQuotationInput>;
  sale?: InputMaybe<ResellerSaleCreateNestedOneWithoutQuotationInput>;
  status?: InputMaybe<QuotationStatus>;
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type QuotationItem = {
  __typename?: 'QuotationItem';
  id: Scalars['ID']['output'];
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  quotation: Quotation;
  quotationId: Scalars['String']['output'];
  unitPrice: Scalars['Float']['output'];
};

export type QuotationItemCreateManyProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  quotationId: Scalars['String']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type QuotationItemCreateManyProductVariantInputEnvelope = {
  data: Array<QuotationItemCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuotationItemCreateManyQuotationInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type QuotationItemCreateManyQuotationInputEnvelope = {
  data: Array<QuotationItemCreateManyQuotationInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type QuotationItemCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<QuotationItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<QuotationItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<QuotationItemCreateManyProductVariantInputEnvelope>;
};

export type QuotationItemCreateNestedManyWithoutQuotationInput = {
  connect?: InputMaybe<Array<QuotationItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationItemCreateOrConnectWithoutQuotationInput>>;
  create?: InputMaybe<Array<QuotationItemCreateWithoutQuotationInput>>;
  createMany?: InputMaybe<QuotationItemCreateManyQuotationInputEnvelope>;
};

export type QuotationItemCreateOrConnectWithoutProductVariantInput = {
  create: QuotationItemCreateWithoutProductVariantInput;
  where: QuotationItemWhereUniqueInput;
};

export type QuotationItemCreateOrConnectWithoutQuotationInput = {
  create: QuotationItemCreateWithoutQuotationInput;
  where: QuotationItemWhereUniqueInput;
};

export type QuotationItemCreateWithoutProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  quotation: QuotationCreateNestedOneWithoutItemsInput;
  unitPrice: Scalars['Float']['input'];
};

export type QuotationItemCreateWithoutQuotationInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutQuotationItemsInput;
  quantity: Scalars['Int']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type QuotationItemListRelationFilter = {
  every?: InputMaybe<QuotationItemWhereInput>;
  none?: InputMaybe<QuotationItemWhereInput>;
  some?: InputMaybe<QuotationItemWhereInput>;
};

export type QuotationItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type QuotationItemScalarWhereInput = {
  AND?: InputMaybe<Array<QuotationItemScalarWhereInput>>;
  NOT?: InputMaybe<Array<QuotationItemScalarWhereInput>>;
  OR?: InputMaybe<Array<QuotationItemScalarWhereInput>>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  quotationId?: InputMaybe<StringFilter>;
  unitPrice?: InputMaybe<FloatFilter>;
};

export type QuotationItemUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  unitPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type QuotationItemUpdateManyWithWhereWithoutProductVariantInput = {
  data: QuotationItemUpdateManyMutationInput;
  where: QuotationItemScalarWhereInput;
};

export type QuotationItemUpdateManyWithWhereWithoutQuotationInput = {
  data: QuotationItemUpdateManyMutationInput;
  where: QuotationItemScalarWhereInput;
};

export type QuotationItemUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<QuotationItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<QuotationItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<QuotationItemCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<QuotationItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<QuotationItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<QuotationItemWhereUniqueInput>>;
  set?: InputMaybe<Array<QuotationItemWhereUniqueInput>>;
  update?: InputMaybe<Array<QuotationItemUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<QuotationItemUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<QuotationItemUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type QuotationItemUpdateManyWithoutQuotationNestedInput = {
  connect?: InputMaybe<Array<QuotationItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationItemCreateOrConnectWithoutQuotationInput>>;
  create?: InputMaybe<Array<QuotationItemCreateWithoutQuotationInput>>;
  createMany?: InputMaybe<QuotationItemCreateManyQuotationInputEnvelope>;
  delete?: InputMaybe<Array<QuotationItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<QuotationItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<QuotationItemWhereUniqueInput>>;
  set?: InputMaybe<Array<QuotationItemWhereUniqueInput>>;
  update?: InputMaybe<Array<QuotationItemUpdateWithWhereUniqueWithoutQuotationInput>>;
  updateMany?: InputMaybe<Array<QuotationItemUpdateManyWithWhereWithoutQuotationInput>>;
  upsert?: InputMaybe<Array<QuotationItemUpsertWithWhereUniqueWithoutQuotationInput>>;
};

export type QuotationItemUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: QuotationItemUpdateWithoutProductVariantInput;
  where: QuotationItemWhereUniqueInput;
};

export type QuotationItemUpdateWithWhereUniqueWithoutQuotationInput = {
  data: QuotationItemUpdateWithoutQuotationInput;
  where: QuotationItemWhereUniqueInput;
};

export type QuotationItemUpdateWithoutProductVariantInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  quotation?: InputMaybe<QuotationUpdateOneRequiredWithoutItemsNestedInput>;
  unitPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type QuotationItemUpdateWithoutQuotationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutQuotationItemsNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  unitPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type QuotationItemUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: QuotationItemCreateWithoutProductVariantInput;
  update: QuotationItemUpdateWithoutProductVariantInput;
  where: QuotationItemWhereUniqueInput;
};

export type QuotationItemUpsertWithWhereUniqueWithoutQuotationInput = {
  create: QuotationItemCreateWithoutQuotationInput;
  update: QuotationItemUpdateWithoutQuotationInput;
  where: QuotationItemWhereUniqueInput;
};

export type QuotationItemWhereInput = {
  AND?: InputMaybe<Array<QuotationItemWhereInput>>;
  NOT?: InputMaybe<Array<QuotationItemWhereInput>>;
  OR?: InputMaybe<Array<QuotationItemWhereInput>>;
  id?: InputMaybe<StringFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  quotation?: InputMaybe<QuotationScalarRelationFilter>;
  quotationId?: InputMaybe<StringFilter>;
  unitPrice?: InputMaybe<FloatFilter>;
};

export type QuotationItemWhereUniqueInput = {
  AND?: InputMaybe<Array<QuotationItemWhereInput>>;
  NOT?: InputMaybe<Array<QuotationItemWhereInput>>;
  OR?: InputMaybe<Array<QuotationItemWhereInput>>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  quotation?: InputMaybe<QuotationScalarRelationFilter>;
  quotationId?: InputMaybe<StringFilter>;
  unitPrice?: InputMaybe<FloatFilter>;
};

export type QuotationListRelationFilter = {
  every?: InputMaybe<QuotationWhereInput>;
  none?: InputMaybe<QuotationWhereInput>;
  some?: InputMaybe<QuotationWhereInput>;
};

export type QuotationNullableScalarRelationFilter = {
  is?: InputMaybe<QuotationWhereInput>;
  isNot?: InputMaybe<QuotationWhereInput>;
};

export type QuotationOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type QuotationScalarRelationFilter = {
  is?: InputMaybe<QuotationWhereInput>;
  isNot?: InputMaybe<QuotationWhereInput>;
};

export type QuotationScalarWhereInput = {
  AND?: InputMaybe<Array<QuotationScalarWhereInput>>;
  NOT?: InputMaybe<Array<QuotationScalarWhereInput>>;
  OR?: InputMaybe<Array<QuotationScalarWhereInput>>;
  billerId?: InputMaybe<StringNullableFilter>;
  channel?: InputMaybe<EnumSaleChannelFilter>;
  consumerId?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  resellerId?: InputMaybe<StringNullableFilter>;
  saleOrderId?: InputMaybe<StringNullableFilter>;
  status?: InputMaybe<EnumQuotationStatusFilter>;
  storeId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  type?: InputMaybe<EnumSaleTypeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export enum QuotationStatus {
  Approved = 'APPROVED',
  Confirmed = 'CONFIRMED',
  Draft = 'DRAFT',
  Rejected = 'REJECTED',
  Sent = 'SENT'
}

export type QuotationUpdateManyMutationInput = {
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumQuotationStatusFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type QuotationUpdateManyWithWhereWithoutBillerInput = {
  data: QuotationUpdateManyMutationInput;
  where: QuotationScalarWhereInput;
};

export type QuotationUpdateManyWithWhereWithoutConsumerInput = {
  data: QuotationUpdateManyMutationInput;
  where: QuotationScalarWhereInput;
};

export type QuotationUpdateManyWithWhereWithoutResellerInput = {
  data: QuotationUpdateManyMutationInput;
  where: QuotationScalarWhereInput;
};

export type QuotationUpdateManyWithWhereWithoutStoreInput = {
  data: QuotationUpdateManyMutationInput;
  where: QuotationScalarWhereInput;
};

export type QuotationUpdateManyWithoutBillerNestedInput = {
  connect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationCreateOrConnectWithoutBillerInput>>;
  create?: InputMaybe<Array<QuotationCreateWithoutBillerInput>>;
  createMany?: InputMaybe<QuotationCreateManyBillerInputEnvelope>;
  delete?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<QuotationScalarWhereInput>>;
  disconnect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  set?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  update?: InputMaybe<Array<QuotationUpdateWithWhereUniqueWithoutBillerInput>>;
  updateMany?: InputMaybe<Array<QuotationUpdateManyWithWhereWithoutBillerInput>>;
  upsert?: InputMaybe<Array<QuotationUpsertWithWhereUniqueWithoutBillerInput>>;
};

export type QuotationUpdateManyWithoutConsumerNestedInput = {
  connect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationCreateOrConnectWithoutConsumerInput>>;
  create?: InputMaybe<Array<QuotationCreateWithoutConsumerInput>>;
  createMany?: InputMaybe<QuotationCreateManyConsumerInputEnvelope>;
  delete?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<QuotationScalarWhereInput>>;
  disconnect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  set?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  update?: InputMaybe<Array<QuotationUpdateWithWhereUniqueWithoutConsumerInput>>;
  updateMany?: InputMaybe<Array<QuotationUpdateManyWithWhereWithoutConsumerInput>>;
  upsert?: InputMaybe<Array<QuotationUpsertWithWhereUniqueWithoutConsumerInput>>;
};

export type QuotationUpdateManyWithoutResellerNestedInput = {
  connect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationCreateOrConnectWithoutResellerInput>>;
  create?: InputMaybe<Array<QuotationCreateWithoutResellerInput>>;
  createMany?: InputMaybe<QuotationCreateManyResellerInputEnvelope>;
  delete?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<QuotationScalarWhereInput>>;
  disconnect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  set?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  update?: InputMaybe<Array<QuotationUpdateWithWhereUniqueWithoutResellerInput>>;
  updateMany?: InputMaybe<Array<QuotationUpdateManyWithWhereWithoutResellerInput>>;
  upsert?: InputMaybe<Array<QuotationUpsertWithWhereUniqueWithoutResellerInput>>;
};

export type QuotationUpdateManyWithoutStoreNestedInput = {
  connect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<QuotationCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<QuotationCreateWithoutStoreInput>>;
  createMany?: InputMaybe<QuotationCreateManyStoreInputEnvelope>;
  delete?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<QuotationScalarWhereInput>>;
  disconnect?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  set?: InputMaybe<Array<QuotationWhereUniqueInput>>;
  update?: InputMaybe<Array<QuotationUpdateWithWhereUniqueWithoutStoreInput>>;
  updateMany?: InputMaybe<Array<QuotationUpdateManyWithWhereWithoutStoreInput>>;
  upsert?: InputMaybe<Array<QuotationUpsertWithWhereUniqueWithoutStoreInput>>;
};

export type QuotationUpdateOneRequiredWithoutItemsNestedInput = {
  connect?: InputMaybe<QuotationWhereUniqueInput>;
  connectOrCreate?: InputMaybe<QuotationCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<QuotationCreateWithoutItemsInput>;
  update?: InputMaybe<QuotationUpdateToOneWithWhereWithoutItemsInput>;
  upsert?: InputMaybe<QuotationUpsertWithoutItemsInput>;
};

export type QuotationUpdateOneWithoutConsumerSaleNestedInput = {
  connect?: InputMaybe<QuotationWhereUniqueInput>;
  connectOrCreate?: InputMaybe<QuotationCreateOrConnectWithoutConsumerSaleInput>;
  create?: InputMaybe<QuotationCreateWithoutConsumerSaleInput>;
  delete?: InputMaybe<QuotationWhereInput>;
  disconnect?: InputMaybe<QuotationWhereInput>;
  update?: InputMaybe<QuotationUpdateToOneWithWhereWithoutConsumerSaleInput>;
  upsert?: InputMaybe<QuotationUpsertWithoutConsumerSaleInput>;
};

export type QuotationUpdateOneWithoutSaleNestedInput = {
  connect?: InputMaybe<QuotationWhereUniqueInput>;
  connectOrCreate?: InputMaybe<QuotationCreateOrConnectWithoutSaleInput>;
  create?: InputMaybe<QuotationCreateWithoutSaleInput>;
  delete?: InputMaybe<QuotationWhereInput>;
  disconnect?: InputMaybe<QuotationWhereInput>;
  update?: InputMaybe<QuotationUpdateToOneWithWhereWithoutSaleInput>;
  upsert?: InputMaybe<QuotationUpsertWithoutSaleInput>;
};

export type QuotationUpdateOneWithoutSaleOrderNestedInput = {
  connect?: InputMaybe<QuotationWhereUniqueInput>;
  connectOrCreate?: InputMaybe<QuotationCreateOrConnectWithoutSaleOrderInput>;
  create?: InputMaybe<QuotationCreateWithoutSaleOrderInput>;
  delete?: InputMaybe<QuotationWhereInput>;
  disconnect?: InputMaybe<QuotationWhereInput>;
  update?: InputMaybe<QuotationUpdateToOneWithWhereWithoutSaleOrderInput>;
  upsert?: InputMaybe<QuotationUpsertWithoutSaleOrderInput>;
};

export type QuotationUpdateToOneWithWhereWithoutConsumerSaleInput = {
  data: QuotationUpdateWithoutConsumerSaleInput;
  where?: InputMaybe<QuotationWhereInput>;
};

export type QuotationUpdateToOneWithWhereWithoutItemsInput = {
  data: QuotationUpdateWithoutItemsInput;
  where?: InputMaybe<QuotationWhereInput>;
};

export type QuotationUpdateToOneWithWhereWithoutSaleInput = {
  data: QuotationUpdateWithoutSaleInput;
  where?: InputMaybe<QuotationWhereInput>;
};

export type QuotationUpdateToOneWithWhereWithoutSaleOrderInput = {
  data: QuotationUpdateWithoutSaleOrderInput;
  where?: InputMaybe<QuotationWhereInput>;
};

export type QuotationUpdateWithWhereUniqueWithoutBillerInput = {
  data: QuotationUpdateWithoutBillerInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationUpdateWithWhereUniqueWithoutConsumerInput = {
  data: QuotationUpdateWithoutConsumerInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationUpdateWithWhereUniqueWithoutResellerInput = {
  data: QuotationUpdateWithoutResellerInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationUpdateWithWhereUniqueWithoutStoreInput = {
  data: QuotationUpdateWithoutStoreInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationUpdateWithoutBillerInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutQuotationNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneWithoutQuotationNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  consumer?: InputMaybe<CustomerUpdateOneWithoutQuotationNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<QuotationItemUpdateManyWithoutQuotationNestedInput>;
  reseller?: InputMaybe<UserUpdateOneWithoutResellerQuotationNestedInput>;
  sale?: InputMaybe<ResellerSaleUpdateOneWithoutQuotationNestedInput>;
  status?: InputMaybe<EnumQuotationStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutQuotationNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type QuotationUpdateWithoutConsumerInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutQuotationNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneWithoutQuotationNestedInput>;
  biller?: InputMaybe<UserUpdateOneWithoutBillerQuotationNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<QuotationItemUpdateManyWithoutQuotationNestedInput>;
  reseller?: InputMaybe<UserUpdateOneWithoutResellerQuotationNestedInput>;
  sale?: InputMaybe<ResellerSaleUpdateOneWithoutQuotationNestedInput>;
  status?: InputMaybe<EnumQuotationStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutQuotationNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type QuotationUpdateWithoutConsumerSaleInput = {
  SaleOrder?: InputMaybe<SaleOrderUpdateOneWithoutQuotationNestedInput>;
  biller?: InputMaybe<UserUpdateOneWithoutBillerQuotationNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  consumer?: InputMaybe<CustomerUpdateOneWithoutQuotationNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<QuotationItemUpdateManyWithoutQuotationNestedInput>;
  reseller?: InputMaybe<UserUpdateOneWithoutResellerQuotationNestedInput>;
  sale?: InputMaybe<ResellerSaleUpdateOneWithoutQuotationNestedInput>;
  status?: InputMaybe<EnumQuotationStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutQuotationNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type QuotationUpdateWithoutItemsInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutQuotationNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneWithoutQuotationNestedInput>;
  biller?: InputMaybe<UserUpdateOneWithoutBillerQuotationNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  consumer?: InputMaybe<CustomerUpdateOneWithoutQuotationNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  reseller?: InputMaybe<UserUpdateOneWithoutResellerQuotationNestedInput>;
  sale?: InputMaybe<ResellerSaleUpdateOneWithoutQuotationNestedInput>;
  status?: InputMaybe<EnumQuotationStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutQuotationNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type QuotationUpdateWithoutResellerInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutQuotationNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneWithoutQuotationNestedInput>;
  biller?: InputMaybe<UserUpdateOneWithoutBillerQuotationNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  consumer?: InputMaybe<CustomerUpdateOneWithoutQuotationNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<QuotationItemUpdateManyWithoutQuotationNestedInput>;
  sale?: InputMaybe<ResellerSaleUpdateOneWithoutQuotationNestedInput>;
  status?: InputMaybe<EnumQuotationStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutQuotationNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type QuotationUpdateWithoutSaleInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutQuotationNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneWithoutQuotationNestedInput>;
  biller?: InputMaybe<UserUpdateOneWithoutBillerQuotationNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  consumer?: InputMaybe<CustomerUpdateOneWithoutQuotationNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<QuotationItemUpdateManyWithoutQuotationNestedInput>;
  reseller?: InputMaybe<UserUpdateOneWithoutResellerQuotationNestedInput>;
  status?: InputMaybe<EnumQuotationStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutQuotationNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type QuotationUpdateWithoutSaleOrderInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutQuotationNestedInput>;
  biller?: InputMaybe<UserUpdateOneWithoutBillerQuotationNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  consumer?: InputMaybe<CustomerUpdateOneWithoutQuotationNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<QuotationItemUpdateManyWithoutQuotationNestedInput>;
  reseller?: InputMaybe<UserUpdateOneWithoutResellerQuotationNestedInput>;
  sale?: InputMaybe<ResellerSaleUpdateOneWithoutQuotationNestedInput>;
  status?: InputMaybe<EnumQuotationStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutQuotationNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type QuotationUpdateWithoutStoreInput = {
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutQuotationNestedInput>;
  SaleOrder?: InputMaybe<SaleOrderUpdateOneWithoutQuotationNestedInput>;
  biller?: InputMaybe<UserUpdateOneWithoutBillerQuotationNestedInput>;
  channel?: InputMaybe<EnumSaleChannelFieldUpdateOperationsInput>;
  consumer?: InputMaybe<CustomerUpdateOneWithoutQuotationNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<QuotationItemUpdateManyWithoutQuotationNestedInput>;
  reseller?: InputMaybe<UserUpdateOneWithoutResellerQuotationNestedInput>;
  sale?: InputMaybe<ResellerSaleUpdateOneWithoutQuotationNestedInput>;
  status?: InputMaybe<EnumQuotationStatusFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type QuotationUpsertWithWhereUniqueWithoutBillerInput = {
  create: QuotationCreateWithoutBillerInput;
  update: QuotationUpdateWithoutBillerInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationUpsertWithWhereUniqueWithoutConsumerInput = {
  create: QuotationCreateWithoutConsumerInput;
  update: QuotationUpdateWithoutConsumerInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationUpsertWithWhereUniqueWithoutResellerInput = {
  create: QuotationCreateWithoutResellerInput;
  update: QuotationUpdateWithoutResellerInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationUpsertWithWhereUniqueWithoutStoreInput = {
  create: QuotationCreateWithoutStoreInput;
  update: QuotationUpdateWithoutStoreInput;
  where: QuotationWhereUniqueInput;
};

export type QuotationUpsertWithoutConsumerSaleInput = {
  create: QuotationCreateWithoutConsumerSaleInput;
  update: QuotationUpdateWithoutConsumerSaleInput;
  where?: InputMaybe<QuotationWhereInput>;
};

export type QuotationUpsertWithoutItemsInput = {
  create: QuotationCreateWithoutItemsInput;
  update: QuotationUpdateWithoutItemsInput;
  where?: InputMaybe<QuotationWhereInput>;
};

export type QuotationUpsertWithoutSaleInput = {
  create: QuotationCreateWithoutSaleInput;
  update: QuotationUpdateWithoutSaleInput;
  where?: InputMaybe<QuotationWhereInput>;
};

export type QuotationUpsertWithoutSaleOrderInput = {
  create: QuotationCreateWithoutSaleOrderInput;
  update: QuotationUpdateWithoutSaleOrderInput;
  where?: InputMaybe<QuotationWhereInput>;
};

export type QuotationWhereInput = {
  AND?: InputMaybe<Array<QuotationWhereInput>>;
  ConsumerSale?: InputMaybe<ConsumerSaleListRelationFilter>;
  NOT?: InputMaybe<Array<QuotationWhereInput>>;
  OR?: InputMaybe<Array<QuotationWhereInput>>;
  SaleOrder?: InputMaybe<SaleOrderNullableScalarRelationFilter>;
  biller?: InputMaybe<UserNullableScalarRelationFilter>;
  billerId?: InputMaybe<StringNullableFilter>;
  channel?: InputMaybe<EnumSaleChannelFilter>;
  consumer?: InputMaybe<CustomerNullableScalarRelationFilter>;
  consumerId?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  items?: InputMaybe<QuotationItemListRelationFilter>;
  reseller?: InputMaybe<UserNullableScalarRelationFilter>;
  resellerId?: InputMaybe<StringNullableFilter>;
  sale?: InputMaybe<ResellerSaleNullableScalarRelationFilter>;
  saleOrderId?: InputMaybe<StringNullableFilter>;
  status?: InputMaybe<EnumQuotationStatusFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  type?: InputMaybe<EnumSaleTypeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type QuotationWhereUniqueInput = {
  AND?: InputMaybe<Array<QuotationWhereInput>>;
  ConsumerSale?: InputMaybe<ConsumerSaleListRelationFilter>;
  NOT?: InputMaybe<Array<QuotationWhereInput>>;
  OR?: InputMaybe<Array<QuotationWhereInput>>;
  SaleOrder?: InputMaybe<SaleOrderNullableScalarRelationFilter>;
  biller?: InputMaybe<UserNullableScalarRelationFilter>;
  billerId?: InputMaybe<StringNullableFilter>;
  channel?: InputMaybe<EnumSaleChannelFilter>;
  consumer?: InputMaybe<CustomerNullableScalarRelationFilter>;
  consumerId?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<QuotationItemListRelationFilter>;
  reseller?: InputMaybe<UserNullableScalarRelationFilter>;
  resellerId?: InputMaybe<StringNullableFilter>;
  sale?: InputMaybe<ResellerSaleNullableScalarRelationFilter>;
  saleOrderId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<EnumQuotationStatusFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  type?: InputMaybe<EnumSaleTypeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type ReceiveStockBatchInput = {
  confirmedById: Scalars['ID']['input'];
  items: Array<ReceiveStockBatchItemInput>;
  purchaseOrderId: Scalars['ID']['input'];
  receivedById: Scalars['ID']['input'];
  storeId: Scalars['ID']['input'];
  waybillUrl?: InputMaybe<Scalars['String']['input']>;
};

export type ReceiveStockBatchItemInput = {
  productVariantId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
};

export type RejectRequisitionInput = {
  id: Scalars['String']['input'];
  reason?: InputMaybe<Scalars['String']['input']>;
};

export type RejectSupplierQuoteInput = {
  quoteId: Scalars['String']['input'];
  reason?: InputMaybe<Scalars['String']['input']>;
};

export type RequisitionSummary = {
  __typename?: 'RequisitionSummary';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  requestedById: Scalars['String']['output'];
  status: Scalars['String']['output'];
  storeId: Scalars['String']['output'];
};

export type ResellerPayment = {
  __typename?: 'ResellerPayment';
  amount: Scalars['Float']['output'];
  id: Scalars['ID']['output'];
  method: PaymentMethod;
  receivedAt: Scalars['DateTime']['output'];
  receivedBy: User;
  receivedById: Scalars['String']['output'];
  reference?: Maybe<Scalars['String']['output']>;
  reseller: User;
  resellerId: Scalars['String']['output'];
  resellerSaleId?: Maybe<Scalars['String']['output']>;
  sale?: Maybe<ResellerSale>;
  saleOrder: SaleOrder;
  saleOrderId: Scalars['String']['output'];
  status: PaymentStatus;
};

export type ResellerPaymentAvgAggregate = {
  __typename?: 'ResellerPaymentAvgAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
};

export type ResellerPaymentCountAggregate = {
  __typename?: 'ResellerPaymentCountAggregate';
  _all: Scalars['Int']['output'];
  amount: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  method: Scalars['Int']['output'];
  receivedAt: Scalars['Int']['output'];
  receivedById: Scalars['Int']['output'];
  reference: Scalars['Int']['output'];
  resellerId: Scalars['Int']['output'];
  resellerSaleId: Scalars['Int']['output'];
  saleOrderId: Scalars['Int']['output'];
  status: Scalars['Int']['output'];
};

export type ResellerPaymentCreateManyReceivedByInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  resellerId: Scalars['String']['input'];
  resellerSaleId?: InputMaybe<Scalars['String']['input']>;
  saleOrderId: Scalars['String']['input'];
  status?: InputMaybe<PaymentStatus>;
};

export type ResellerPaymentCreateManyReceivedByInputEnvelope = {
  data: Array<ResellerPaymentCreateManyReceivedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerPaymentCreateManyResellerInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedById: Scalars['String']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  resellerSaleId?: InputMaybe<Scalars['String']['input']>;
  saleOrderId: Scalars['String']['input'];
  status?: InputMaybe<PaymentStatus>;
};

export type ResellerPaymentCreateManyResellerInputEnvelope = {
  data: Array<ResellerPaymentCreateManyResellerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerPaymentCreateManySaleInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedById: Scalars['String']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  resellerId: Scalars['String']['input'];
  saleOrderId: Scalars['String']['input'];
  status?: InputMaybe<PaymentStatus>;
};

export type ResellerPaymentCreateManySaleInputEnvelope = {
  data: Array<ResellerPaymentCreateManySaleInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerPaymentCreateManySaleOrderInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedById: Scalars['String']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  resellerId: Scalars['String']['input'];
  resellerSaleId?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<PaymentStatus>;
};

export type ResellerPaymentCreateManySaleOrderInputEnvelope = {
  data: Array<ResellerPaymentCreateManySaleOrderInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerPaymentCreateNestedManyWithoutReceivedByInput = {
  connect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerPaymentCreateOrConnectWithoutReceivedByInput>>;
  create?: InputMaybe<Array<ResellerPaymentCreateWithoutReceivedByInput>>;
  createMany?: InputMaybe<ResellerPaymentCreateManyReceivedByInputEnvelope>;
};

export type ResellerPaymentCreateNestedManyWithoutResellerInput = {
  connect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerPaymentCreateOrConnectWithoutResellerInput>>;
  create?: InputMaybe<Array<ResellerPaymentCreateWithoutResellerInput>>;
  createMany?: InputMaybe<ResellerPaymentCreateManyResellerInputEnvelope>;
};

export type ResellerPaymentCreateNestedManyWithoutSaleInput = {
  connect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerPaymentCreateOrConnectWithoutSaleInput>>;
  create?: InputMaybe<Array<ResellerPaymentCreateWithoutSaleInput>>;
  createMany?: InputMaybe<ResellerPaymentCreateManySaleInputEnvelope>;
};

export type ResellerPaymentCreateNestedManyWithoutSaleOrderInput = {
  connect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerPaymentCreateOrConnectWithoutSaleOrderInput>>;
  create?: InputMaybe<Array<ResellerPaymentCreateWithoutSaleOrderInput>>;
  createMany?: InputMaybe<ResellerPaymentCreateManySaleOrderInputEnvelope>;
};

export type ResellerPaymentCreateOrConnectWithoutReceivedByInput = {
  create: ResellerPaymentCreateWithoutReceivedByInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentCreateOrConnectWithoutResellerInput = {
  create: ResellerPaymentCreateWithoutResellerInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentCreateOrConnectWithoutSaleInput = {
  create: ResellerPaymentCreateWithoutSaleInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentCreateOrConnectWithoutSaleOrderInput = {
  create: ResellerPaymentCreateWithoutSaleOrderInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentCreateWithoutReceivedByInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  reseller: UserCreateNestedOneWithoutResellerPaymentsMadeInput;
  sale?: InputMaybe<ResellerSaleCreateNestedOneWithoutPaymentsInput>;
  saleOrder: SaleOrderCreateNestedOneWithoutResellerPaymentInput;
  status?: InputMaybe<PaymentStatus>;
};

export type ResellerPaymentCreateWithoutResellerInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedBy: UserCreateNestedOneWithoutResellerPaymentsReceivedInput;
  reference?: InputMaybe<Scalars['String']['input']>;
  sale?: InputMaybe<ResellerSaleCreateNestedOneWithoutPaymentsInput>;
  saleOrder: SaleOrderCreateNestedOneWithoutResellerPaymentInput;
  status?: InputMaybe<PaymentStatus>;
};

export type ResellerPaymentCreateWithoutSaleInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedBy: UserCreateNestedOneWithoutResellerPaymentsReceivedInput;
  reference?: InputMaybe<Scalars['String']['input']>;
  reseller: UserCreateNestedOneWithoutResellerPaymentsMadeInput;
  saleOrder: SaleOrderCreateNestedOneWithoutResellerPaymentInput;
  status?: InputMaybe<PaymentStatus>;
};

export type ResellerPaymentCreateWithoutSaleOrderInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: PaymentMethod;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedBy: UserCreateNestedOneWithoutResellerPaymentsReceivedInput;
  reference?: InputMaybe<Scalars['String']['input']>;
  reseller: UserCreateNestedOneWithoutResellerPaymentsMadeInput;
  sale?: InputMaybe<ResellerSaleCreateNestedOneWithoutPaymentsInput>;
  status?: InputMaybe<PaymentStatus>;
};

export type ResellerPaymentListRelationFilter = {
  every?: InputMaybe<ResellerPaymentWhereInput>;
  none?: InputMaybe<ResellerPaymentWhereInput>;
  some?: InputMaybe<ResellerPaymentWhereInput>;
};

export type ResellerPaymentMaxAggregate = {
  __typename?: 'ResellerPaymentMaxAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  method?: Maybe<PaymentMethod>;
  receivedAt?: Maybe<Scalars['DateTime']['output']>;
  receivedById?: Maybe<Scalars['String']['output']>;
  reference?: Maybe<Scalars['String']['output']>;
  resellerId?: Maybe<Scalars['String']['output']>;
  resellerSaleId?: Maybe<Scalars['String']['output']>;
  saleOrderId?: Maybe<Scalars['String']['output']>;
  status?: Maybe<PaymentStatus>;
};

export type ResellerPaymentMinAggregate = {
  __typename?: 'ResellerPaymentMinAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  method?: Maybe<PaymentMethod>;
  receivedAt?: Maybe<Scalars['DateTime']['output']>;
  receivedById?: Maybe<Scalars['String']['output']>;
  reference?: Maybe<Scalars['String']['output']>;
  resellerId?: Maybe<Scalars['String']['output']>;
  resellerSaleId?: Maybe<Scalars['String']['output']>;
  saleOrderId?: Maybe<Scalars['String']['output']>;
  status?: Maybe<PaymentStatus>;
};

export type ResellerPaymentOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ResellerPaymentScalarWhereInput = {
  AND?: InputMaybe<Array<ResellerPaymentScalarWhereInput>>;
  NOT?: InputMaybe<Array<ResellerPaymentScalarWhereInput>>;
  OR?: InputMaybe<Array<ResellerPaymentScalarWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  id?: InputMaybe<StringFilter>;
  method?: InputMaybe<EnumPaymentMethodFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  receivedById?: InputMaybe<StringFilter>;
  reference?: InputMaybe<StringNullableFilter>;
  resellerId?: InputMaybe<StringFilter>;
  resellerSaleId?: InputMaybe<StringNullableFilter>;
  saleOrderId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumPaymentStatusFilter>;
};

export type ResellerPaymentSumAggregate = {
  __typename?: 'ResellerPaymentSumAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
};

export type ResellerPaymentUpdateManyMutationInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<EnumPaymentMethodFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  reference?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumPaymentStatusFieldUpdateOperationsInput>;
};

export type ResellerPaymentUpdateManyWithWhereWithoutReceivedByInput = {
  data: ResellerPaymentUpdateManyMutationInput;
  where: ResellerPaymentScalarWhereInput;
};

export type ResellerPaymentUpdateManyWithWhereWithoutResellerInput = {
  data: ResellerPaymentUpdateManyMutationInput;
  where: ResellerPaymentScalarWhereInput;
};

export type ResellerPaymentUpdateManyWithWhereWithoutSaleInput = {
  data: ResellerPaymentUpdateManyMutationInput;
  where: ResellerPaymentScalarWhereInput;
};

export type ResellerPaymentUpdateManyWithWhereWithoutSaleOrderInput = {
  data: ResellerPaymentUpdateManyMutationInput;
  where: ResellerPaymentScalarWhereInput;
};

export type ResellerPaymentUpdateManyWithoutReceivedByNestedInput = {
  connect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerPaymentCreateOrConnectWithoutReceivedByInput>>;
  create?: InputMaybe<Array<ResellerPaymentCreateWithoutReceivedByInput>>;
  createMany?: InputMaybe<ResellerPaymentCreateManyReceivedByInputEnvelope>;
  delete?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerPaymentScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerPaymentUpdateWithWhereUniqueWithoutReceivedByInput>>;
  updateMany?: InputMaybe<Array<ResellerPaymentUpdateManyWithWhereWithoutReceivedByInput>>;
  upsert?: InputMaybe<Array<ResellerPaymentUpsertWithWhereUniqueWithoutReceivedByInput>>;
};

export type ResellerPaymentUpdateManyWithoutResellerNestedInput = {
  connect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerPaymentCreateOrConnectWithoutResellerInput>>;
  create?: InputMaybe<Array<ResellerPaymentCreateWithoutResellerInput>>;
  createMany?: InputMaybe<ResellerPaymentCreateManyResellerInputEnvelope>;
  delete?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerPaymentScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerPaymentUpdateWithWhereUniqueWithoutResellerInput>>;
  updateMany?: InputMaybe<Array<ResellerPaymentUpdateManyWithWhereWithoutResellerInput>>;
  upsert?: InputMaybe<Array<ResellerPaymentUpsertWithWhereUniqueWithoutResellerInput>>;
};

export type ResellerPaymentUpdateManyWithoutSaleNestedInput = {
  connect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerPaymentCreateOrConnectWithoutSaleInput>>;
  create?: InputMaybe<Array<ResellerPaymentCreateWithoutSaleInput>>;
  createMany?: InputMaybe<ResellerPaymentCreateManySaleInputEnvelope>;
  delete?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerPaymentScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerPaymentUpdateWithWhereUniqueWithoutSaleInput>>;
  updateMany?: InputMaybe<Array<ResellerPaymentUpdateManyWithWhereWithoutSaleInput>>;
  upsert?: InputMaybe<Array<ResellerPaymentUpsertWithWhereUniqueWithoutSaleInput>>;
};

export type ResellerPaymentUpdateManyWithoutSaleOrderNestedInput = {
  connect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerPaymentCreateOrConnectWithoutSaleOrderInput>>;
  create?: InputMaybe<Array<ResellerPaymentCreateWithoutSaleOrderInput>>;
  createMany?: InputMaybe<ResellerPaymentCreateManySaleOrderInputEnvelope>;
  delete?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerPaymentScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerPaymentWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerPaymentUpdateWithWhereUniqueWithoutSaleOrderInput>>;
  updateMany?: InputMaybe<Array<ResellerPaymentUpdateManyWithWhereWithoutSaleOrderInput>>;
  upsert?: InputMaybe<Array<ResellerPaymentUpsertWithWhereUniqueWithoutSaleOrderInput>>;
};

export type ResellerPaymentUpdateWithWhereUniqueWithoutReceivedByInput = {
  data: ResellerPaymentUpdateWithoutReceivedByInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentUpdateWithWhereUniqueWithoutResellerInput = {
  data: ResellerPaymentUpdateWithoutResellerInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentUpdateWithWhereUniqueWithoutSaleInput = {
  data: ResellerPaymentUpdateWithoutSaleInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentUpdateWithWhereUniqueWithoutSaleOrderInput = {
  data: ResellerPaymentUpdateWithoutSaleOrderInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentUpdateWithoutReceivedByInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<EnumPaymentMethodFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  reference?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  reseller?: InputMaybe<UserUpdateOneRequiredWithoutResellerPaymentsMadeNestedInput>;
  sale?: InputMaybe<ResellerSaleUpdateOneWithoutPaymentsNestedInput>;
  saleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutResellerPaymentNestedInput>;
  status?: InputMaybe<EnumPaymentStatusFieldUpdateOperationsInput>;
};

export type ResellerPaymentUpdateWithoutResellerInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<EnumPaymentMethodFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutResellerPaymentsReceivedNestedInput>;
  reference?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  sale?: InputMaybe<ResellerSaleUpdateOneWithoutPaymentsNestedInput>;
  saleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutResellerPaymentNestedInput>;
  status?: InputMaybe<EnumPaymentStatusFieldUpdateOperationsInput>;
};

export type ResellerPaymentUpdateWithoutSaleInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<EnumPaymentMethodFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutResellerPaymentsReceivedNestedInput>;
  reference?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  reseller?: InputMaybe<UserUpdateOneRequiredWithoutResellerPaymentsMadeNestedInput>;
  saleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutResellerPaymentNestedInput>;
  status?: InputMaybe<EnumPaymentStatusFieldUpdateOperationsInput>;
};

export type ResellerPaymentUpdateWithoutSaleOrderInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<EnumPaymentMethodFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutResellerPaymentsReceivedNestedInput>;
  reference?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  reseller?: InputMaybe<UserUpdateOneRequiredWithoutResellerPaymentsMadeNestedInput>;
  sale?: InputMaybe<ResellerSaleUpdateOneWithoutPaymentsNestedInput>;
  status?: InputMaybe<EnumPaymentStatusFieldUpdateOperationsInput>;
};

export type ResellerPaymentUpsertWithWhereUniqueWithoutReceivedByInput = {
  create: ResellerPaymentCreateWithoutReceivedByInput;
  update: ResellerPaymentUpdateWithoutReceivedByInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentUpsertWithWhereUniqueWithoutResellerInput = {
  create: ResellerPaymentCreateWithoutResellerInput;
  update: ResellerPaymentUpdateWithoutResellerInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentUpsertWithWhereUniqueWithoutSaleInput = {
  create: ResellerPaymentCreateWithoutSaleInput;
  update: ResellerPaymentUpdateWithoutSaleInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentUpsertWithWhereUniqueWithoutSaleOrderInput = {
  create: ResellerPaymentCreateWithoutSaleOrderInput;
  update: ResellerPaymentUpdateWithoutSaleOrderInput;
  where: ResellerPaymentWhereUniqueInput;
};

export type ResellerPaymentWhereInput = {
  AND?: InputMaybe<Array<ResellerPaymentWhereInput>>;
  NOT?: InputMaybe<Array<ResellerPaymentWhereInput>>;
  OR?: InputMaybe<Array<ResellerPaymentWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  id?: InputMaybe<StringFilter>;
  method?: InputMaybe<EnumPaymentMethodFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  receivedBy?: InputMaybe<UserScalarRelationFilter>;
  receivedById?: InputMaybe<StringFilter>;
  reference?: InputMaybe<StringNullableFilter>;
  reseller?: InputMaybe<UserScalarRelationFilter>;
  resellerId?: InputMaybe<StringFilter>;
  resellerSaleId?: InputMaybe<StringNullableFilter>;
  sale?: InputMaybe<ResellerSaleNullableScalarRelationFilter>;
  saleOrder?: InputMaybe<SaleOrderScalarRelationFilter>;
  saleOrderId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumPaymentStatusFilter>;
};

export type ResellerPaymentWhereUniqueInput = {
  AND?: InputMaybe<Array<ResellerPaymentWhereInput>>;
  NOT?: InputMaybe<Array<ResellerPaymentWhereInput>>;
  OR?: InputMaybe<Array<ResellerPaymentWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  method?: InputMaybe<EnumPaymentMethodFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  receivedBy?: InputMaybe<UserScalarRelationFilter>;
  receivedById?: InputMaybe<StringFilter>;
  reference?: InputMaybe<StringNullableFilter>;
  reseller?: InputMaybe<UserScalarRelationFilter>;
  resellerId?: InputMaybe<StringFilter>;
  resellerSaleId?: InputMaybe<StringNullableFilter>;
  sale?: InputMaybe<ResellerSaleNullableScalarRelationFilter>;
  saleOrder?: InputMaybe<SaleOrderScalarRelationFilter>;
  saleOrderId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumPaymentStatusFilter>;
};

export type ResellerProfile = {
  __typename?: 'ResellerProfile';
  activatedAt?: Maybe<Scalars['DateTime']['output']>;
  biller?: Maybe<User>;
  billerId?: Maybe<Scalars['String']['output']>;
  creditLimit: Scalars['Float']['output'];
  isActive: Scalars['Boolean']['output'];
  outstandingBalance: Scalars['Float']['output'];
  profileStatus: ProfileStatus;
  rejectedAt?: Maybe<Scalars['DateTime']['output']>;
  rejectionReason?: Maybe<Scalars['String']['output']>;
  requestedAt: Scalars['DateTime']['output'];
  requestedBiller?: Maybe<User>;
  requestedBillerId?: Maybe<Scalars['String']['output']>;
  tier: UserTier;
  user: User;
  userId: Scalars['ID']['output'];
};

export type ResellerProfileCreateManyBillerInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  creditLimit: Scalars['Float']['input'];
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  outstandingBalance?: InputMaybe<Scalars['Float']['input']>;
  profileStatus?: InputMaybe<ProfileStatus>;
  rejectedAt?: InputMaybe<Scalars['DateTime']['input']>;
  rejectionReason?: InputMaybe<Scalars['String']['input']>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  requestedBillerId?: InputMaybe<Scalars['String']['input']>;
  tier: UserTier;
  userId: Scalars['String']['input'];
};

export type ResellerProfileCreateManyBillerInputEnvelope = {
  data: Array<ResellerProfileCreateManyBillerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerProfileCreateManyRequestedBillerInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  billerId?: InputMaybe<Scalars['String']['input']>;
  creditLimit: Scalars['Float']['input'];
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  outstandingBalance?: InputMaybe<Scalars['Float']['input']>;
  profileStatus?: InputMaybe<ProfileStatus>;
  rejectedAt?: InputMaybe<Scalars['DateTime']['input']>;
  rejectionReason?: InputMaybe<Scalars['String']['input']>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  tier: UserTier;
  userId: Scalars['String']['input'];
};

export type ResellerProfileCreateManyRequestedBillerInputEnvelope = {
  data: Array<ResellerProfileCreateManyRequestedBillerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerProfileCreateNestedManyWithoutBillerInput = {
  connect?: InputMaybe<Array<ResellerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerProfileCreateOrConnectWithoutBillerInput>>;
  create?: InputMaybe<Array<ResellerProfileCreateWithoutBillerInput>>;
  createMany?: InputMaybe<ResellerProfileCreateManyBillerInputEnvelope>;
};

export type ResellerProfileCreateNestedManyWithoutRequestedBillerInput = {
  connect?: InputMaybe<Array<ResellerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerProfileCreateOrConnectWithoutRequestedBillerInput>>;
  create?: InputMaybe<Array<ResellerProfileCreateWithoutRequestedBillerInput>>;
  createMany?: InputMaybe<ResellerProfileCreateManyRequestedBillerInputEnvelope>;
};

export type ResellerProfileCreateNestedOneWithoutUserInput = {
  connect?: InputMaybe<ResellerProfileWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerProfileCreateOrConnectWithoutUserInput>;
  create?: InputMaybe<ResellerProfileCreateWithoutUserInput>;
};

export type ResellerProfileCreateOrConnectWithoutBillerInput = {
  create: ResellerProfileCreateWithoutBillerInput;
  where: ResellerProfileWhereUniqueInput;
};

export type ResellerProfileCreateOrConnectWithoutRequestedBillerInput = {
  create: ResellerProfileCreateWithoutRequestedBillerInput;
  where: ResellerProfileWhereUniqueInput;
};

export type ResellerProfileCreateOrConnectWithoutUserInput = {
  create: ResellerProfileCreateWithoutUserInput;
  where: ResellerProfileWhereUniqueInput;
};

export type ResellerProfileCreateWithoutBillerInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  creditLimit: Scalars['Float']['input'];
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  outstandingBalance?: InputMaybe<Scalars['Float']['input']>;
  profileStatus?: InputMaybe<ProfileStatus>;
  rejectedAt?: InputMaybe<Scalars['DateTime']['input']>;
  rejectionReason?: InputMaybe<Scalars['String']['input']>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  requestedBiller?: InputMaybe<UserCreateNestedOneWithoutRequestedResellersInput>;
  tier: UserTier;
  user: UserCreateNestedOneWithoutResellerProfileInput;
};

export type ResellerProfileCreateWithoutRequestedBillerInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  biller?: InputMaybe<UserCreateNestedOneWithoutResellerProfileInput>;
  creditLimit: Scalars['Float']['input'];
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  outstandingBalance?: InputMaybe<Scalars['Float']['input']>;
  profileStatus?: InputMaybe<ProfileStatus>;
  rejectedAt?: InputMaybe<Scalars['DateTime']['input']>;
  rejectionReason?: InputMaybe<Scalars['String']['input']>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  tier: UserTier;
  user: UserCreateNestedOneWithoutResellerProfileInput;
};

export type ResellerProfileCreateWithoutUserInput = {
  activatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  biller?: InputMaybe<UserCreateNestedOneWithoutResellerProfileInput>;
  creditLimit: Scalars['Float']['input'];
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  outstandingBalance?: InputMaybe<Scalars['Float']['input']>;
  profileStatus?: InputMaybe<ProfileStatus>;
  rejectedAt?: InputMaybe<Scalars['DateTime']['input']>;
  rejectionReason?: InputMaybe<Scalars['String']['input']>;
  requestedAt?: InputMaybe<Scalars['DateTime']['input']>;
  requestedBiller?: InputMaybe<UserCreateNestedOneWithoutRequestedResellersInput>;
  tier: UserTier;
};

export type ResellerProfileListRelationFilter = {
  every?: InputMaybe<ResellerProfileWhereInput>;
  none?: InputMaybe<ResellerProfileWhereInput>;
  some?: InputMaybe<ResellerProfileWhereInput>;
};

export type ResellerProfileNullableScalarRelationFilter = {
  is?: InputMaybe<ResellerProfileWhereInput>;
  isNot?: InputMaybe<ResellerProfileWhereInput>;
};

export type ResellerProfileOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ResellerProfileOrderByWithRelationInput = {
  activatedAt?: InputMaybe<SortOrderInput>;
  biller?: InputMaybe<UserOrderByWithRelationInput>;
  billerId?: InputMaybe<SortOrderInput>;
  creditLimit?: InputMaybe<SortOrder>;
  isActive?: InputMaybe<SortOrder>;
  outstandingBalance?: InputMaybe<SortOrder>;
  profileStatus?: InputMaybe<SortOrder>;
  rejectedAt?: InputMaybe<SortOrderInput>;
  rejectionReason?: InputMaybe<SortOrderInput>;
  requestedAt?: InputMaybe<SortOrder>;
  requestedBiller?: InputMaybe<UserOrderByWithRelationInput>;
  requestedBillerId?: InputMaybe<SortOrderInput>;
  tier?: InputMaybe<SortOrder>;
  user?: InputMaybe<UserOrderByWithRelationInput>;
  userId?: InputMaybe<SortOrder>;
};

export type ResellerProfileScalarWhereInput = {
  AND?: InputMaybe<Array<ResellerProfileScalarWhereInput>>;
  NOT?: InputMaybe<Array<ResellerProfileScalarWhereInput>>;
  OR?: InputMaybe<Array<ResellerProfileScalarWhereInput>>;
  activatedAt?: InputMaybe<DateTimeNullableFilter>;
  billerId?: InputMaybe<StringNullableFilter>;
  creditLimit?: InputMaybe<FloatFilter>;
  isActive?: InputMaybe<BoolFilter>;
  outstandingBalance?: InputMaybe<FloatFilter>;
  profileStatus?: InputMaybe<EnumProfileStatusFilter>;
  rejectedAt?: InputMaybe<DateTimeNullableFilter>;
  rejectionReason?: InputMaybe<StringNullableFilter>;
  requestedAt?: InputMaybe<DateTimeFilter>;
  requestedBillerId?: InputMaybe<StringNullableFilter>;
  tier?: InputMaybe<EnumUserTierFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type ResellerProfileUpdateManyMutationInput = {
  activatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  creditLimit?: InputMaybe<FloatFieldUpdateOperationsInput>;
  isActive?: InputMaybe<BoolFieldUpdateOperationsInput>;
  outstandingBalance?: InputMaybe<FloatFieldUpdateOperationsInput>;
  profileStatus?: InputMaybe<EnumProfileStatusFieldUpdateOperationsInput>;
  rejectedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  rejectionReason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  requestedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
};

export type ResellerProfileUpdateManyWithWhereWithoutBillerInput = {
  data: ResellerProfileUpdateManyMutationInput;
  where: ResellerProfileScalarWhereInput;
};

export type ResellerProfileUpdateManyWithWhereWithoutRequestedBillerInput = {
  data: ResellerProfileUpdateManyMutationInput;
  where: ResellerProfileScalarWhereInput;
};

export type ResellerProfileUpdateManyWithoutBillerNestedInput = {
  connect?: InputMaybe<Array<ResellerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerProfileCreateOrConnectWithoutBillerInput>>;
  create?: InputMaybe<Array<ResellerProfileCreateWithoutBillerInput>>;
  createMany?: InputMaybe<ResellerProfileCreateManyBillerInputEnvelope>;
  delete?: InputMaybe<Array<ResellerProfileWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerProfileScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerProfileWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerProfileWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerProfileUpdateWithWhereUniqueWithoutBillerInput>>;
  updateMany?: InputMaybe<Array<ResellerProfileUpdateManyWithWhereWithoutBillerInput>>;
  upsert?: InputMaybe<Array<ResellerProfileUpsertWithWhereUniqueWithoutBillerInput>>;
};

export type ResellerProfileUpdateManyWithoutRequestedBillerNestedInput = {
  connect?: InputMaybe<Array<ResellerProfileWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerProfileCreateOrConnectWithoutRequestedBillerInput>>;
  create?: InputMaybe<Array<ResellerProfileCreateWithoutRequestedBillerInput>>;
  createMany?: InputMaybe<ResellerProfileCreateManyRequestedBillerInputEnvelope>;
  delete?: InputMaybe<Array<ResellerProfileWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerProfileScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerProfileWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerProfileWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerProfileUpdateWithWhereUniqueWithoutRequestedBillerInput>>;
  updateMany?: InputMaybe<Array<ResellerProfileUpdateManyWithWhereWithoutRequestedBillerInput>>;
  upsert?: InputMaybe<Array<ResellerProfileUpsertWithWhereUniqueWithoutRequestedBillerInput>>;
};

export type ResellerProfileUpdateOneWithoutUserNestedInput = {
  connect?: InputMaybe<ResellerProfileWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerProfileCreateOrConnectWithoutUserInput>;
  create?: InputMaybe<ResellerProfileCreateWithoutUserInput>;
  delete?: InputMaybe<ResellerProfileWhereInput>;
  disconnect?: InputMaybe<ResellerProfileWhereInput>;
  update?: InputMaybe<ResellerProfileUpdateToOneWithWhereWithoutUserInput>;
  upsert?: InputMaybe<ResellerProfileUpsertWithoutUserInput>;
};

export type ResellerProfileUpdateToOneWithWhereWithoutUserInput = {
  data: ResellerProfileUpdateWithoutUserInput;
  where?: InputMaybe<ResellerProfileWhereInput>;
};

export type ResellerProfileUpdateWithWhereUniqueWithoutBillerInput = {
  data: ResellerProfileUpdateWithoutBillerInput;
  where: ResellerProfileWhereUniqueInput;
};

export type ResellerProfileUpdateWithWhereUniqueWithoutRequestedBillerInput = {
  data: ResellerProfileUpdateWithoutRequestedBillerInput;
  where: ResellerProfileWhereUniqueInput;
};

export type ResellerProfileUpdateWithoutBillerInput = {
  activatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  creditLimit?: InputMaybe<FloatFieldUpdateOperationsInput>;
  isActive?: InputMaybe<BoolFieldUpdateOperationsInput>;
  outstandingBalance?: InputMaybe<FloatFieldUpdateOperationsInput>;
  profileStatus?: InputMaybe<EnumProfileStatusFieldUpdateOperationsInput>;
  rejectedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  rejectionReason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  requestedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  requestedBiller?: InputMaybe<UserUpdateOneWithoutRequestedResellersNestedInput>;
  tier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutResellerProfileNestedInput>;
};

export type ResellerProfileUpdateWithoutRequestedBillerInput = {
  activatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneWithoutResellerProfileNestedInput>;
  creditLimit?: InputMaybe<FloatFieldUpdateOperationsInput>;
  isActive?: InputMaybe<BoolFieldUpdateOperationsInput>;
  outstandingBalance?: InputMaybe<FloatFieldUpdateOperationsInput>;
  profileStatus?: InputMaybe<EnumProfileStatusFieldUpdateOperationsInput>;
  rejectedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  rejectionReason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  requestedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  tier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutResellerProfileNestedInput>;
};

export type ResellerProfileUpdateWithoutUserInput = {
  activatedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneWithoutResellerProfileNestedInput>;
  creditLimit?: InputMaybe<FloatFieldUpdateOperationsInput>;
  isActive?: InputMaybe<BoolFieldUpdateOperationsInput>;
  outstandingBalance?: InputMaybe<FloatFieldUpdateOperationsInput>;
  profileStatus?: InputMaybe<EnumProfileStatusFieldUpdateOperationsInput>;
  rejectedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  rejectionReason?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  requestedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  requestedBiller?: InputMaybe<UserUpdateOneWithoutRequestedResellersNestedInput>;
  tier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
};

export type ResellerProfileUpsertWithWhereUniqueWithoutBillerInput = {
  create: ResellerProfileCreateWithoutBillerInput;
  update: ResellerProfileUpdateWithoutBillerInput;
  where: ResellerProfileWhereUniqueInput;
};

export type ResellerProfileUpsertWithWhereUniqueWithoutRequestedBillerInput = {
  create: ResellerProfileCreateWithoutRequestedBillerInput;
  update: ResellerProfileUpdateWithoutRequestedBillerInput;
  where: ResellerProfileWhereUniqueInput;
};

export type ResellerProfileUpsertWithoutUserInput = {
  create: ResellerProfileCreateWithoutUserInput;
  update: ResellerProfileUpdateWithoutUserInput;
  where?: InputMaybe<ResellerProfileWhereInput>;
};

export type ResellerProfileWhereInput = {
  AND?: InputMaybe<Array<ResellerProfileWhereInput>>;
  NOT?: InputMaybe<Array<ResellerProfileWhereInput>>;
  OR?: InputMaybe<Array<ResellerProfileWhereInput>>;
  activatedAt?: InputMaybe<DateTimeNullableFilter>;
  biller?: InputMaybe<UserNullableScalarRelationFilter>;
  billerId?: InputMaybe<StringNullableFilter>;
  creditLimit?: InputMaybe<FloatFilter>;
  isActive?: InputMaybe<BoolFilter>;
  outstandingBalance?: InputMaybe<FloatFilter>;
  profileStatus?: InputMaybe<EnumProfileStatusFilter>;
  rejectedAt?: InputMaybe<DateTimeNullableFilter>;
  rejectionReason?: InputMaybe<StringNullableFilter>;
  requestedAt?: InputMaybe<DateTimeFilter>;
  requestedBiller?: InputMaybe<UserNullableScalarRelationFilter>;
  requestedBillerId?: InputMaybe<StringNullableFilter>;
  tier?: InputMaybe<EnumUserTierFilter>;
  user?: InputMaybe<UserScalarRelationFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type ResellerProfileWhereUniqueInput = {
  AND?: InputMaybe<Array<ResellerProfileWhereInput>>;
  NOT?: InputMaybe<Array<ResellerProfileWhereInput>>;
  OR?: InputMaybe<Array<ResellerProfileWhereInput>>;
  activatedAt?: InputMaybe<DateTimeNullableFilter>;
  biller?: InputMaybe<UserNullableScalarRelationFilter>;
  billerId?: InputMaybe<StringNullableFilter>;
  creditLimit?: InputMaybe<FloatFilter>;
  isActive?: InputMaybe<BoolFilter>;
  outstandingBalance?: InputMaybe<FloatFilter>;
  profileStatus?: InputMaybe<EnumProfileStatusFilter>;
  rejectedAt?: InputMaybe<DateTimeNullableFilter>;
  rejectionReason?: InputMaybe<StringNullableFilter>;
  requestedAt?: InputMaybe<DateTimeFilter>;
  requestedBiller?: InputMaybe<UserNullableScalarRelationFilter>;
  requestedBillerId?: InputMaybe<StringNullableFilter>;
  tier?: InputMaybe<EnumUserTierFilter>;
  user?: InputMaybe<UserScalarRelationFilter>;
  userId?: InputMaybe<Scalars['String']['input']>;
};

export type ResellerSale = {
  __typename?: 'ResellerSale';
  SaleOrder: SaleOrder;
  SaleOrderid: Scalars['String']['output'];
  SalesReturn?: Maybe<Array<SalesReturn>>;
  _count: ResellerSaleCount;
  approvedAt?: Maybe<Scalars['DateTime']['output']>;
  approvedBy?: Maybe<User>;
  approvedById?: Maybe<Scalars['String']['output']>;
  biller: User;
  billerId: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  items?: Maybe<Array<ResellerSaleItem>>;
  payments?: Maybe<Array<ResellerPayment>>;
  quotation?: Maybe<Quotation>;
  quotationId?: Maybe<Scalars['String']['output']>;
  reseller: User;
  resellerId: Scalars['String']['output'];
  status: SaleStatus;
  store: Store;
  storeId: Scalars['String']['output'];
  totalAmount: Scalars['Float']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type ResellerSaleAvgAggregate = {
  __typename?: 'ResellerSaleAvgAggregate';
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

export type ResellerSaleCount = {
  __typename?: 'ResellerSaleCount';
  SalesReturn: Scalars['Int']['output'];
  items: Scalars['Int']['output'];
  payments: Scalars['Int']['output'];
};

export type ResellerSaleCountAggregate = {
  __typename?: 'ResellerSaleCountAggregate';
  SaleOrderid: Scalars['Int']['output'];
  _all: Scalars['Int']['output'];
  approvedAt: Scalars['Int']['output'];
  approvedById: Scalars['Int']['output'];
  billerId: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  quotationId: Scalars['Int']['output'];
  resellerId: Scalars['Int']['output'];
  status: Scalars['Int']['output'];
  storeId: Scalars['Int']['output'];
  totalAmount: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
};

export type ResellerSaleCreateManyApprovedByInput = {
  SaleOrderid: Scalars['String']['input'];
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  billerId: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  quotationId?: InputMaybe<Scalars['String']['input']>;
  resellerId: Scalars['String']['input'];
  status: SaleStatus;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateManyApprovedByInputEnvelope = {
  data: Array<ResellerSaleCreateManyApprovedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerSaleCreateManyBillerInput = {
  SaleOrderid: Scalars['String']['input'];
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  approvedById?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  quotationId?: InputMaybe<Scalars['String']['input']>;
  resellerId: Scalars['String']['input'];
  status: SaleStatus;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateManyBillerInputEnvelope = {
  data: Array<ResellerSaleCreateManyBillerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerSaleCreateManyResellerInput = {
  SaleOrderid: Scalars['String']['input'];
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  approvedById?: InputMaybe<Scalars['String']['input']>;
  billerId: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  quotationId?: InputMaybe<Scalars['String']['input']>;
  status: SaleStatus;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateManyResellerInputEnvelope = {
  data: Array<ResellerSaleCreateManyResellerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerSaleCreateManyStoreInput = {
  SaleOrderid: Scalars['String']['input'];
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  approvedById?: InputMaybe<Scalars['String']['input']>;
  billerId: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  quotationId?: InputMaybe<Scalars['String']['input']>;
  resellerId: Scalars['String']['input'];
  status: SaleStatus;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateManyStoreInputEnvelope = {
  data: Array<ResellerSaleCreateManyStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerSaleCreateNestedManyWithoutApprovedByInput = {
  connect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleCreateOrConnectWithoutApprovedByInput>>;
  create?: InputMaybe<Array<ResellerSaleCreateWithoutApprovedByInput>>;
  createMany?: InputMaybe<ResellerSaleCreateManyApprovedByInputEnvelope>;
};

export type ResellerSaleCreateNestedManyWithoutBillerInput = {
  connect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleCreateOrConnectWithoutBillerInput>>;
  create?: InputMaybe<Array<ResellerSaleCreateWithoutBillerInput>>;
  createMany?: InputMaybe<ResellerSaleCreateManyBillerInputEnvelope>;
};

export type ResellerSaleCreateNestedManyWithoutResellerInput = {
  connect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleCreateOrConnectWithoutResellerInput>>;
  create?: InputMaybe<Array<ResellerSaleCreateWithoutResellerInput>>;
  createMany?: InputMaybe<ResellerSaleCreateManyResellerInputEnvelope>;
};

export type ResellerSaleCreateNestedManyWithoutStoreInput = {
  connect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<ResellerSaleCreateWithoutStoreInput>>;
  createMany?: InputMaybe<ResellerSaleCreateManyStoreInputEnvelope>;
};

export type ResellerSaleCreateNestedOneWithoutItemsInput = {
  connect?: InputMaybe<ResellerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerSaleCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<ResellerSaleCreateWithoutItemsInput>;
};

export type ResellerSaleCreateNestedOneWithoutPaymentsInput = {
  connect?: InputMaybe<ResellerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerSaleCreateOrConnectWithoutPaymentsInput>;
  create?: InputMaybe<ResellerSaleCreateWithoutPaymentsInput>;
};

export type ResellerSaleCreateNestedOneWithoutQuotationInput = {
  connect?: InputMaybe<ResellerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerSaleCreateOrConnectWithoutQuotationInput>;
  create?: InputMaybe<ResellerSaleCreateWithoutQuotationInput>;
};

export type ResellerSaleCreateNestedOneWithoutSaleOrderInput = {
  connect?: InputMaybe<ResellerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerSaleCreateOrConnectWithoutSaleOrderInput>;
  create?: InputMaybe<ResellerSaleCreateWithoutSaleOrderInput>;
};

export type ResellerSaleCreateNestedOneWithoutSalesReturnInput = {
  connect?: InputMaybe<ResellerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerSaleCreateOrConnectWithoutSalesReturnInput>;
  create?: InputMaybe<ResellerSaleCreateWithoutSalesReturnInput>;
};

export type ResellerSaleCreateOrConnectWithoutApprovedByInput = {
  create: ResellerSaleCreateWithoutApprovedByInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleCreateOrConnectWithoutBillerInput = {
  create: ResellerSaleCreateWithoutBillerInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleCreateOrConnectWithoutItemsInput = {
  create: ResellerSaleCreateWithoutItemsInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleCreateOrConnectWithoutPaymentsInput = {
  create: ResellerSaleCreateWithoutPaymentsInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleCreateOrConnectWithoutQuotationInput = {
  create: ResellerSaleCreateWithoutQuotationInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleCreateOrConnectWithoutResellerInput = {
  create: ResellerSaleCreateWithoutResellerInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleCreateOrConnectWithoutSaleOrderInput = {
  create: ResellerSaleCreateWithoutSaleOrderInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleCreateOrConnectWithoutSalesReturnInput = {
  create: ResellerSaleCreateWithoutSalesReturnInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleCreateOrConnectWithoutStoreInput = {
  create: ResellerSaleCreateWithoutStoreInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleCreateWithoutApprovedByInput = {
  SaleOrder: SaleOrderCreateNestedOneWithoutResellerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutResellerSaleInput>;
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  biller: UserCreateNestedOneWithoutBillerResellerSaleInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleInput>;
  reseller: UserCreateNestedOneWithoutResellerSalesInput;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutResellerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateWithoutBillerInput = {
  SaleOrder: SaleOrderCreateNestedOneWithoutResellerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutResellerSaleInput>;
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutResellerSaleInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleInput>;
  reseller: UserCreateNestedOneWithoutResellerSalesInput;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutResellerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateWithoutItemsInput = {
  SaleOrder: SaleOrderCreateNestedOneWithoutResellerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutResellerSaleInput>;
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutResellerSaleInput>;
  biller: UserCreateNestedOneWithoutBillerResellerSaleInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  payments?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleInput>;
  reseller: UserCreateNestedOneWithoutResellerSalesInput;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutResellerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateWithoutPaymentsInput = {
  SaleOrder: SaleOrderCreateNestedOneWithoutResellerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutResellerSaleInput>;
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutResellerSaleInput>;
  biller: UserCreateNestedOneWithoutBillerResellerSaleInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleInput>;
  reseller: UserCreateNestedOneWithoutResellerSalesInput;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutResellerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateWithoutQuotationInput = {
  SaleOrder: SaleOrderCreateNestedOneWithoutResellerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutResellerSaleInput>;
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutResellerSaleInput>;
  biller: UserCreateNestedOneWithoutBillerResellerSaleInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleInput>;
  reseller: UserCreateNestedOneWithoutResellerSalesInput;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutResellerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateWithoutResellerInput = {
  SaleOrder: SaleOrderCreateNestedOneWithoutResellerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutResellerSaleInput>;
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutResellerSaleInput>;
  biller: UserCreateNestedOneWithoutBillerResellerSaleInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleInput>;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutResellerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateWithoutSaleOrderInput = {
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutResellerSaleInput>;
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutResellerSaleInput>;
  biller: UserCreateNestedOneWithoutBillerResellerSaleInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleInput>;
  reseller: UserCreateNestedOneWithoutResellerSalesInput;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutResellerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateWithoutSalesReturnInput = {
  SaleOrder: SaleOrderCreateNestedOneWithoutResellerSaleInput;
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutResellerSaleInput>;
  biller: UserCreateNestedOneWithoutBillerResellerSaleInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleInput>;
  reseller: UserCreateNestedOneWithoutResellerSalesInput;
  status: SaleStatus;
  store: StoreCreateNestedOneWithoutResellerSalesInput;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleCreateWithoutStoreInput = {
  SaleOrder: SaleOrderCreateNestedOneWithoutResellerSaleInput;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutResellerSaleInput>;
  approvedAt?: InputMaybe<Scalars['DateTime']['input']>;
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutResellerSaleInput>;
  biller: UserCreateNestedOneWithoutBillerResellerSaleInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ResellerSaleItemCreateNestedManyWithoutSaleInput>;
  payments?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleInput>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleInput>;
  reseller: UserCreateNestedOneWithoutResellerSalesInput;
  status: SaleStatus;
  totalAmount: Scalars['Float']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ResellerSaleItem = {
  __typename?: 'ResellerSaleItem';
  id: Scalars['ID']['output'];
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  resellerSaleId: Scalars['String']['output'];
  sale: ResellerSale;
  unitPrice: Scalars['Float']['output'];
};

export type ResellerSaleItemCreateManyProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  resellerSaleId: Scalars['String']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type ResellerSaleItemCreateManyProductVariantInputEnvelope = {
  data: Array<ResellerSaleItemCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerSaleItemCreateManySaleInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type ResellerSaleItemCreateManySaleInputEnvelope = {
  data: Array<ResellerSaleItemCreateManySaleInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerSaleItemCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<ResellerSaleItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<ResellerSaleItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<ResellerSaleItemCreateManyProductVariantInputEnvelope>;
};

export type ResellerSaleItemCreateNestedManyWithoutSaleInput = {
  connect?: InputMaybe<Array<ResellerSaleItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleItemCreateOrConnectWithoutSaleInput>>;
  create?: InputMaybe<Array<ResellerSaleItemCreateWithoutSaleInput>>;
  createMany?: InputMaybe<ResellerSaleItemCreateManySaleInputEnvelope>;
};

export type ResellerSaleItemCreateOrConnectWithoutProductVariantInput = {
  create: ResellerSaleItemCreateWithoutProductVariantInput;
  where: ResellerSaleItemWhereUniqueInput;
};

export type ResellerSaleItemCreateOrConnectWithoutSaleInput = {
  create: ResellerSaleItemCreateWithoutSaleInput;
  where: ResellerSaleItemWhereUniqueInput;
};

export type ResellerSaleItemCreateWithoutProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  sale: ResellerSaleCreateNestedOneWithoutItemsInput;
  unitPrice: Scalars['Float']['input'];
};

export type ResellerSaleItemCreateWithoutSaleInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutResellerItemsInput;
  quantity: Scalars['Int']['input'];
  unitPrice: Scalars['Float']['input'];
};

export type ResellerSaleItemListRelationFilter = {
  every?: InputMaybe<ResellerSaleItemWhereInput>;
  none?: InputMaybe<ResellerSaleItemWhereInput>;
  some?: InputMaybe<ResellerSaleItemWhereInput>;
};

export type ResellerSaleItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ResellerSaleItemScalarWhereInput = {
  AND?: InputMaybe<Array<ResellerSaleItemScalarWhereInput>>;
  NOT?: InputMaybe<Array<ResellerSaleItemScalarWhereInput>>;
  OR?: InputMaybe<Array<ResellerSaleItemScalarWhereInput>>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  resellerSaleId?: InputMaybe<StringFilter>;
  unitPrice?: InputMaybe<FloatFilter>;
};

export type ResellerSaleItemUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  unitPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type ResellerSaleItemUpdateManyWithWhereWithoutProductVariantInput = {
  data: ResellerSaleItemUpdateManyMutationInput;
  where: ResellerSaleItemScalarWhereInput;
};

export type ResellerSaleItemUpdateManyWithWhereWithoutSaleInput = {
  data: ResellerSaleItemUpdateManyMutationInput;
  where: ResellerSaleItemScalarWhereInput;
};

export type ResellerSaleItemUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<ResellerSaleItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<ResellerSaleItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<ResellerSaleItemCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<ResellerSaleItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerSaleItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerSaleItemWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerSaleItemWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerSaleItemUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<ResellerSaleItemUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<ResellerSaleItemUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type ResellerSaleItemUpdateManyWithoutSaleNestedInput = {
  connect?: InputMaybe<Array<ResellerSaleItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleItemCreateOrConnectWithoutSaleInput>>;
  create?: InputMaybe<Array<ResellerSaleItemCreateWithoutSaleInput>>;
  createMany?: InputMaybe<ResellerSaleItemCreateManySaleInputEnvelope>;
  delete?: InputMaybe<Array<ResellerSaleItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerSaleItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerSaleItemWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerSaleItemWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerSaleItemUpdateWithWhereUniqueWithoutSaleInput>>;
  updateMany?: InputMaybe<Array<ResellerSaleItemUpdateManyWithWhereWithoutSaleInput>>;
  upsert?: InputMaybe<Array<ResellerSaleItemUpsertWithWhereUniqueWithoutSaleInput>>;
};

export type ResellerSaleItemUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: ResellerSaleItemUpdateWithoutProductVariantInput;
  where: ResellerSaleItemWhereUniqueInput;
};

export type ResellerSaleItemUpdateWithWhereUniqueWithoutSaleInput = {
  data: ResellerSaleItemUpdateWithoutSaleInput;
  where: ResellerSaleItemWhereUniqueInput;
};

export type ResellerSaleItemUpdateWithoutProductVariantInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  sale?: InputMaybe<ResellerSaleUpdateOneRequiredWithoutItemsNestedInput>;
  unitPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type ResellerSaleItemUpdateWithoutSaleInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutResellerItemsNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  unitPrice?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type ResellerSaleItemUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: ResellerSaleItemCreateWithoutProductVariantInput;
  update: ResellerSaleItemUpdateWithoutProductVariantInput;
  where: ResellerSaleItemWhereUniqueInput;
};

export type ResellerSaleItemUpsertWithWhereUniqueWithoutSaleInput = {
  create: ResellerSaleItemCreateWithoutSaleInput;
  update: ResellerSaleItemUpdateWithoutSaleInput;
  where: ResellerSaleItemWhereUniqueInput;
};

export type ResellerSaleItemWhereInput = {
  AND?: InputMaybe<Array<ResellerSaleItemWhereInput>>;
  NOT?: InputMaybe<Array<ResellerSaleItemWhereInput>>;
  OR?: InputMaybe<Array<ResellerSaleItemWhereInput>>;
  id?: InputMaybe<StringFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  resellerSaleId?: InputMaybe<StringFilter>;
  sale?: InputMaybe<ResellerSaleScalarRelationFilter>;
  unitPrice?: InputMaybe<FloatFilter>;
};

export type ResellerSaleItemWhereUniqueInput = {
  AND?: InputMaybe<Array<ResellerSaleItemWhereInput>>;
  NOT?: InputMaybe<Array<ResellerSaleItemWhereInput>>;
  OR?: InputMaybe<Array<ResellerSaleItemWhereInput>>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  resellerSaleId?: InputMaybe<StringFilter>;
  sale?: InputMaybe<ResellerSaleScalarRelationFilter>;
  unitPrice?: InputMaybe<FloatFilter>;
};

export type ResellerSaleListRelationFilter = {
  every?: InputMaybe<ResellerSaleWhereInput>;
  none?: InputMaybe<ResellerSaleWhereInput>;
  some?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleMaxAggregate = {
  __typename?: 'ResellerSaleMaxAggregate';
  SaleOrderid?: Maybe<Scalars['String']['output']>;
  approvedAt?: Maybe<Scalars['DateTime']['output']>;
  approvedById?: Maybe<Scalars['String']['output']>;
  billerId?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  quotationId?: Maybe<Scalars['String']['output']>;
  resellerId?: Maybe<Scalars['String']['output']>;
  status?: Maybe<SaleStatus>;
  storeId?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ResellerSaleMinAggregate = {
  __typename?: 'ResellerSaleMinAggregate';
  SaleOrderid?: Maybe<Scalars['String']['output']>;
  approvedAt?: Maybe<Scalars['DateTime']['output']>;
  approvedById?: Maybe<Scalars['String']['output']>;
  billerId?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  quotationId?: Maybe<Scalars['String']['output']>;
  resellerId?: Maybe<Scalars['String']['output']>;
  status?: Maybe<SaleStatus>;
  storeId?: Maybe<Scalars['String']['output']>;
  totalAmount?: Maybe<Scalars['Float']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type ResellerSaleNullableScalarRelationFilter = {
  is?: InputMaybe<ResellerSaleWhereInput>;
  isNot?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ResellerSaleScalarRelationFilter = {
  is?: InputMaybe<ResellerSaleWhereInput>;
  isNot?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleScalarWhereInput = {
  AND?: InputMaybe<Array<ResellerSaleScalarWhereInput>>;
  NOT?: InputMaybe<Array<ResellerSaleScalarWhereInput>>;
  OR?: InputMaybe<Array<ResellerSaleScalarWhereInput>>;
  SaleOrderid?: InputMaybe<StringFilter>;
  approvedAt?: InputMaybe<DateTimeNullableFilter>;
  approvedById?: InputMaybe<StringNullableFilter>;
  billerId?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  quotationId?: InputMaybe<StringNullableFilter>;
  resellerId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumSaleStatusFilter>;
  storeId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type ResellerSaleSumAggregate = {
  __typename?: 'ResellerSaleSumAggregate';
  totalAmount?: Maybe<Scalars['Float']['output']>;
};

export type ResellerSaleUpdateManyMutationInput = {
  approvedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ResellerSaleUpdateManyWithWhereWithoutApprovedByInput = {
  data: ResellerSaleUpdateManyMutationInput;
  where: ResellerSaleScalarWhereInput;
};

export type ResellerSaleUpdateManyWithWhereWithoutBillerInput = {
  data: ResellerSaleUpdateManyMutationInput;
  where: ResellerSaleScalarWhereInput;
};

export type ResellerSaleUpdateManyWithWhereWithoutResellerInput = {
  data: ResellerSaleUpdateManyMutationInput;
  where: ResellerSaleScalarWhereInput;
};

export type ResellerSaleUpdateManyWithWhereWithoutStoreInput = {
  data: ResellerSaleUpdateManyMutationInput;
  where: ResellerSaleScalarWhereInput;
};

export type ResellerSaleUpdateManyWithoutApprovedByNestedInput = {
  connect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleCreateOrConnectWithoutApprovedByInput>>;
  create?: InputMaybe<Array<ResellerSaleCreateWithoutApprovedByInput>>;
  createMany?: InputMaybe<ResellerSaleCreateManyApprovedByInputEnvelope>;
  delete?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerSaleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerSaleUpdateWithWhereUniqueWithoutApprovedByInput>>;
  updateMany?: InputMaybe<Array<ResellerSaleUpdateManyWithWhereWithoutApprovedByInput>>;
  upsert?: InputMaybe<Array<ResellerSaleUpsertWithWhereUniqueWithoutApprovedByInput>>;
};

export type ResellerSaleUpdateManyWithoutBillerNestedInput = {
  connect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleCreateOrConnectWithoutBillerInput>>;
  create?: InputMaybe<Array<ResellerSaleCreateWithoutBillerInput>>;
  createMany?: InputMaybe<ResellerSaleCreateManyBillerInputEnvelope>;
  delete?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerSaleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerSaleUpdateWithWhereUniqueWithoutBillerInput>>;
  updateMany?: InputMaybe<Array<ResellerSaleUpdateManyWithWhereWithoutBillerInput>>;
  upsert?: InputMaybe<Array<ResellerSaleUpsertWithWhereUniqueWithoutBillerInput>>;
};

export type ResellerSaleUpdateManyWithoutResellerNestedInput = {
  connect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleCreateOrConnectWithoutResellerInput>>;
  create?: InputMaybe<Array<ResellerSaleCreateWithoutResellerInput>>;
  createMany?: InputMaybe<ResellerSaleCreateManyResellerInputEnvelope>;
  delete?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerSaleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerSaleUpdateWithWhereUniqueWithoutResellerInput>>;
  updateMany?: InputMaybe<Array<ResellerSaleUpdateManyWithWhereWithoutResellerInput>>;
  upsert?: InputMaybe<Array<ResellerSaleUpsertWithWhereUniqueWithoutResellerInput>>;
};

export type ResellerSaleUpdateManyWithoutStoreNestedInput = {
  connect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerSaleCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<ResellerSaleCreateWithoutStoreInput>>;
  createMany?: InputMaybe<ResellerSaleCreateManyStoreInputEnvelope>;
  delete?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerSaleScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerSaleWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerSaleUpdateWithWhereUniqueWithoutStoreInput>>;
  updateMany?: InputMaybe<Array<ResellerSaleUpdateManyWithWhereWithoutStoreInput>>;
  upsert?: InputMaybe<Array<ResellerSaleUpsertWithWhereUniqueWithoutStoreInput>>;
};

export type ResellerSaleUpdateOneRequiredWithoutItemsNestedInput = {
  connect?: InputMaybe<ResellerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerSaleCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<ResellerSaleCreateWithoutItemsInput>;
  update?: InputMaybe<ResellerSaleUpdateToOneWithWhereWithoutItemsInput>;
  upsert?: InputMaybe<ResellerSaleUpsertWithoutItemsInput>;
};

export type ResellerSaleUpdateOneWithoutPaymentsNestedInput = {
  connect?: InputMaybe<ResellerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerSaleCreateOrConnectWithoutPaymentsInput>;
  create?: InputMaybe<ResellerSaleCreateWithoutPaymentsInput>;
  delete?: InputMaybe<ResellerSaleWhereInput>;
  disconnect?: InputMaybe<ResellerSaleWhereInput>;
  update?: InputMaybe<ResellerSaleUpdateToOneWithWhereWithoutPaymentsInput>;
  upsert?: InputMaybe<ResellerSaleUpsertWithoutPaymentsInput>;
};

export type ResellerSaleUpdateOneWithoutQuotationNestedInput = {
  connect?: InputMaybe<ResellerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerSaleCreateOrConnectWithoutQuotationInput>;
  create?: InputMaybe<ResellerSaleCreateWithoutQuotationInput>;
  delete?: InputMaybe<ResellerSaleWhereInput>;
  disconnect?: InputMaybe<ResellerSaleWhereInput>;
  update?: InputMaybe<ResellerSaleUpdateToOneWithWhereWithoutQuotationInput>;
  upsert?: InputMaybe<ResellerSaleUpsertWithoutQuotationInput>;
};

export type ResellerSaleUpdateOneWithoutSaleOrderNestedInput = {
  connect?: InputMaybe<ResellerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerSaleCreateOrConnectWithoutSaleOrderInput>;
  create?: InputMaybe<ResellerSaleCreateWithoutSaleOrderInput>;
  delete?: InputMaybe<ResellerSaleWhereInput>;
  disconnect?: InputMaybe<ResellerSaleWhereInput>;
  update?: InputMaybe<ResellerSaleUpdateToOneWithWhereWithoutSaleOrderInput>;
  upsert?: InputMaybe<ResellerSaleUpsertWithoutSaleOrderInput>;
};

export type ResellerSaleUpdateOneWithoutSalesReturnNestedInput = {
  connect?: InputMaybe<ResellerSaleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<ResellerSaleCreateOrConnectWithoutSalesReturnInput>;
  create?: InputMaybe<ResellerSaleCreateWithoutSalesReturnInput>;
  delete?: InputMaybe<ResellerSaleWhereInput>;
  disconnect?: InputMaybe<ResellerSaleWhereInput>;
  update?: InputMaybe<ResellerSaleUpdateToOneWithWhereWithoutSalesReturnInput>;
  upsert?: InputMaybe<ResellerSaleUpsertWithoutSalesReturnInput>;
};

export type ResellerSaleUpdateToOneWithWhereWithoutItemsInput = {
  data: ResellerSaleUpdateWithoutItemsInput;
  where?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleUpdateToOneWithWhereWithoutPaymentsInput = {
  data: ResellerSaleUpdateWithoutPaymentsInput;
  where?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleUpdateToOneWithWhereWithoutQuotationInput = {
  data: ResellerSaleUpdateWithoutQuotationInput;
  where?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleUpdateToOneWithWhereWithoutSaleOrderInput = {
  data: ResellerSaleUpdateWithoutSaleOrderInput;
  where?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleUpdateToOneWithWhereWithoutSalesReturnInput = {
  data: ResellerSaleUpdateWithoutSalesReturnInput;
  where?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleUpdateWithWhereUniqueWithoutApprovedByInput = {
  data: ResellerSaleUpdateWithoutApprovedByInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleUpdateWithWhereUniqueWithoutBillerInput = {
  data: ResellerSaleUpdateWithoutBillerInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleUpdateWithWhereUniqueWithoutResellerInput = {
  data: ResellerSaleUpdateWithoutResellerInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleUpdateWithWhereUniqueWithoutStoreInput = {
  data: ResellerSaleUpdateWithoutStoreInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleUpdateWithoutApprovedByInput = {
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutResellerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutResellerSaleNestedInput>;
  approvedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutBillerResellerSaleNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ResellerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleNestedInput>;
  reseller?: InputMaybe<UserUpdateOneRequiredWithoutResellerSalesNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutResellerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ResellerSaleUpdateWithoutBillerInput = {
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutResellerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutResellerSaleNestedInput>;
  approvedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  approvedBy?: InputMaybe<UserUpdateOneWithoutResellerSaleNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ResellerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleNestedInput>;
  reseller?: InputMaybe<UserUpdateOneRequiredWithoutResellerSalesNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutResellerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ResellerSaleUpdateWithoutItemsInput = {
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutResellerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutResellerSaleNestedInput>;
  approvedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  approvedBy?: InputMaybe<UserUpdateOneWithoutResellerSaleNestedInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutBillerResellerSaleNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  payments?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleNestedInput>;
  reseller?: InputMaybe<UserUpdateOneRequiredWithoutResellerSalesNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutResellerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ResellerSaleUpdateWithoutPaymentsInput = {
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutResellerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutResellerSaleNestedInput>;
  approvedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  approvedBy?: InputMaybe<UserUpdateOneWithoutResellerSaleNestedInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutBillerResellerSaleNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ResellerSaleItemUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleNestedInput>;
  reseller?: InputMaybe<UserUpdateOneRequiredWithoutResellerSalesNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutResellerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ResellerSaleUpdateWithoutQuotationInput = {
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutResellerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutResellerSaleNestedInput>;
  approvedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  approvedBy?: InputMaybe<UserUpdateOneWithoutResellerSaleNestedInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutBillerResellerSaleNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ResellerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleNestedInput>;
  reseller?: InputMaybe<UserUpdateOneRequiredWithoutResellerSalesNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutResellerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ResellerSaleUpdateWithoutResellerInput = {
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutResellerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutResellerSaleNestedInput>;
  approvedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  approvedBy?: InputMaybe<UserUpdateOneWithoutResellerSaleNestedInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutBillerResellerSaleNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ResellerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutResellerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ResellerSaleUpdateWithoutSaleOrderInput = {
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutResellerSaleNestedInput>;
  approvedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  approvedBy?: InputMaybe<UserUpdateOneWithoutResellerSaleNestedInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutBillerResellerSaleNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ResellerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleNestedInput>;
  reseller?: InputMaybe<UserUpdateOneRequiredWithoutResellerSalesNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutResellerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ResellerSaleUpdateWithoutSalesReturnInput = {
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutResellerSaleNestedInput>;
  approvedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  approvedBy?: InputMaybe<UserUpdateOneWithoutResellerSaleNestedInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutBillerResellerSaleNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ResellerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleNestedInput>;
  reseller?: InputMaybe<UserUpdateOneRequiredWithoutResellerSalesNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutResellerSalesNestedInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ResellerSaleUpdateWithoutStoreInput = {
  SaleOrder?: InputMaybe<SaleOrderUpdateOneRequiredWithoutResellerSaleNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutResellerSaleNestedInput>;
  approvedAt?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  approvedBy?: InputMaybe<UserUpdateOneWithoutResellerSaleNestedInput>;
  biller?: InputMaybe<UserUpdateOneRequiredWithoutBillerResellerSaleNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<ResellerSaleItemUpdateManyWithoutSaleNestedInput>;
  payments?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleNestedInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleNestedInput>;
  reseller?: InputMaybe<UserUpdateOneRequiredWithoutResellerSalesNestedInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type ResellerSaleUpsertWithWhereUniqueWithoutApprovedByInput = {
  create: ResellerSaleCreateWithoutApprovedByInput;
  update: ResellerSaleUpdateWithoutApprovedByInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleUpsertWithWhereUniqueWithoutBillerInput = {
  create: ResellerSaleCreateWithoutBillerInput;
  update: ResellerSaleUpdateWithoutBillerInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleUpsertWithWhereUniqueWithoutResellerInput = {
  create: ResellerSaleCreateWithoutResellerInput;
  update: ResellerSaleUpdateWithoutResellerInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleUpsertWithWhereUniqueWithoutStoreInput = {
  create: ResellerSaleCreateWithoutStoreInput;
  update: ResellerSaleUpdateWithoutStoreInput;
  where: ResellerSaleWhereUniqueInput;
};

export type ResellerSaleUpsertWithoutItemsInput = {
  create: ResellerSaleCreateWithoutItemsInput;
  update: ResellerSaleUpdateWithoutItemsInput;
  where?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleUpsertWithoutPaymentsInput = {
  create: ResellerSaleCreateWithoutPaymentsInput;
  update: ResellerSaleUpdateWithoutPaymentsInput;
  where?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleUpsertWithoutQuotationInput = {
  create: ResellerSaleCreateWithoutQuotationInput;
  update: ResellerSaleUpdateWithoutQuotationInput;
  where?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleUpsertWithoutSaleOrderInput = {
  create: ResellerSaleCreateWithoutSaleOrderInput;
  update: ResellerSaleUpdateWithoutSaleOrderInput;
  where?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleUpsertWithoutSalesReturnInput = {
  create: ResellerSaleCreateWithoutSalesReturnInput;
  update: ResellerSaleUpdateWithoutSalesReturnInput;
  where?: InputMaybe<ResellerSaleWhereInput>;
};

export type ResellerSaleWhereInput = {
  AND?: InputMaybe<Array<ResellerSaleWhereInput>>;
  NOT?: InputMaybe<Array<ResellerSaleWhereInput>>;
  OR?: InputMaybe<Array<ResellerSaleWhereInput>>;
  SaleOrder?: InputMaybe<SaleOrderScalarRelationFilter>;
  SaleOrderid?: InputMaybe<StringFilter>;
  SalesReturn?: InputMaybe<SalesReturnListRelationFilter>;
  approvedAt?: InputMaybe<DateTimeNullableFilter>;
  approvedBy?: InputMaybe<UserNullableScalarRelationFilter>;
  approvedById?: InputMaybe<StringNullableFilter>;
  biller?: InputMaybe<UserScalarRelationFilter>;
  billerId?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  items?: InputMaybe<ResellerSaleItemListRelationFilter>;
  payments?: InputMaybe<ResellerPaymentListRelationFilter>;
  quotation?: InputMaybe<QuotationNullableScalarRelationFilter>;
  quotationId?: InputMaybe<StringNullableFilter>;
  reseller?: InputMaybe<UserScalarRelationFilter>;
  resellerId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumSaleStatusFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type ResellerSaleWhereUniqueInput = {
  AND?: InputMaybe<Array<ResellerSaleWhereInput>>;
  NOT?: InputMaybe<Array<ResellerSaleWhereInput>>;
  OR?: InputMaybe<Array<ResellerSaleWhereInput>>;
  SaleOrder?: InputMaybe<SaleOrderScalarRelationFilter>;
  SaleOrderid?: InputMaybe<Scalars['String']['input']>;
  SalesReturn?: InputMaybe<SalesReturnListRelationFilter>;
  approvedAt?: InputMaybe<DateTimeNullableFilter>;
  approvedBy?: InputMaybe<UserNullableScalarRelationFilter>;
  approvedById?: InputMaybe<StringNullableFilter>;
  biller?: InputMaybe<UserScalarRelationFilter>;
  billerId?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<ResellerSaleItemListRelationFilter>;
  payments?: InputMaybe<ResellerPaymentListRelationFilter>;
  quotation?: InputMaybe<QuotationNullableScalarRelationFilter>;
  quotationId?: InputMaybe<Scalars['String']['input']>;
  reseller?: InputMaybe<UserScalarRelationFilter>;
  resellerId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumSaleStatusFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type ResellerTierHistory = {
  __typename?: 'ResellerTierHistory';
  admin: User;
  changedAt: Scalars['DateTime']['output'];
  changedBy: Scalars['String']['output'];
  fromTier: UserTier;
  id: Scalars['ID']['output'];
  toTier: UserTier;
  user: User;
  userId: Scalars['String']['output'];
};

export type ResellerTierHistoryCreateManyAdminInput = {
  changedAt?: InputMaybe<Scalars['DateTime']['input']>;
  fromTier: UserTier;
  id?: InputMaybe<Scalars['String']['input']>;
  toTier: UserTier;
  userId: Scalars['String']['input'];
};

export type ResellerTierHistoryCreateManyAdminInputEnvelope = {
  data: Array<ResellerTierHistoryCreateManyAdminInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerTierHistoryCreateManyUserInput = {
  changedAt?: InputMaybe<Scalars['DateTime']['input']>;
  changedBy: Scalars['String']['input'];
  fromTier: UserTier;
  id?: InputMaybe<Scalars['String']['input']>;
  toTier: UserTier;
};

export type ResellerTierHistoryCreateManyUserInputEnvelope = {
  data: Array<ResellerTierHistoryCreateManyUserInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ResellerTierHistoryCreateNestedManyWithoutAdminInput = {
  connect?: InputMaybe<Array<ResellerTierHistoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerTierHistoryCreateOrConnectWithoutAdminInput>>;
  create?: InputMaybe<Array<ResellerTierHistoryCreateWithoutAdminInput>>;
  createMany?: InputMaybe<ResellerTierHistoryCreateManyAdminInputEnvelope>;
};

export type ResellerTierHistoryCreateNestedManyWithoutUserInput = {
  connect?: InputMaybe<Array<ResellerTierHistoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerTierHistoryCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<ResellerTierHistoryCreateWithoutUserInput>>;
  createMany?: InputMaybe<ResellerTierHistoryCreateManyUserInputEnvelope>;
};

export type ResellerTierHistoryCreateOrConnectWithoutAdminInput = {
  create: ResellerTierHistoryCreateWithoutAdminInput;
  where: ResellerTierHistoryWhereUniqueInput;
};

export type ResellerTierHistoryCreateOrConnectWithoutUserInput = {
  create: ResellerTierHistoryCreateWithoutUserInput;
  where: ResellerTierHistoryWhereUniqueInput;
};

export type ResellerTierHistoryCreateWithoutAdminInput = {
  changedAt?: InputMaybe<Scalars['DateTime']['input']>;
  fromTier: UserTier;
  id?: InputMaybe<Scalars['String']['input']>;
  toTier: UserTier;
  user: UserCreateNestedOneWithoutResellerTierHistoryInput;
};

export type ResellerTierHistoryCreateWithoutUserInput = {
  admin: UserCreateNestedOneWithoutResellerTierHistoryChangedBysInput;
  changedAt?: InputMaybe<Scalars['DateTime']['input']>;
  fromTier: UserTier;
  id?: InputMaybe<Scalars['String']['input']>;
  toTier: UserTier;
};

export type ResellerTierHistoryListRelationFilter = {
  every?: InputMaybe<ResellerTierHistoryWhereInput>;
  none?: InputMaybe<ResellerTierHistoryWhereInput>;
  some?: InputMaybe<ResellerTierHistoryWhereInput>;
};

export type ResellerTierHistoryOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ResellerTierHistoryScalarWhereInput = {
  AND?: InputMaybe<Array<ResellerTierHistoryScalarWhereInput>>;
  NOT?: InputMaybe<Array<ResellerTierHistoryScalarWhereInput>>;
  OR?: InputMaybe<Array<ResellerTierHistoryScalarWhereInput>>;
  changedAt?: InputMaybe<DateTimeFilter>;
  changedBy?: InputMaybe<StringFilter>;
  fromTier?: InputMaybe<EnumUserTierFilter>;
  id?: InputMaybe<StringFilter>;
  toTier?: InputMaybe<EnumUserTierFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type ResellerTierHistoryUpdateManyMutationInput = {
  changedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fromTier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  toTier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
};

export type ResellerTierHistoryUpdateManyWithWhereWithoutAdminInput = {
  data: ResellerTierHistoryUpdateManyMutationInput;
  where: ResellerTierHistoryScalarWhereInput;
};

export type ResellerTierHistoryUpdateManyWithWhereWithoutUserInput = {
  data: ResellerTierHistoryUpdateManyMutationInput;
  where: ResellerTierHistoryScalarWhereInput;
};

export type ResellerTierHistoryUpdateManyWithoutAdminNestedInput = {
  connect?: InputMaybe<Array<ResellerTierHistoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerTierHistoryCreateOrConnectWithoutAdminInput>>;
  create?: InputMaybe<Array<ResellerTierHistoryCreateWithoutAdminInput>>;
  createMany?: InputMaybe<ResellerTierHistoryCreateManyAdminInputEnvelope>;
  delete?: InputMaybe<Array<ResellerTierHistoryWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerTierHistoryScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerTierHistoryWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerTierHistoryWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerTierHistoryUpdateWithWhereUniqueWithoutAdminInput>>;
  updateMany?: InputMaybe<Array<ResellerTierHistoryUpdateManyWithWhereWithoutAdminInput>>;
  upsert?: InputMaybe<Array<ResellerTierHistoryUpsertWithWhereUniqueWithoutAdminInput>>;
};

export type ResellerTierHistoryUpdateManyWithoutUserNestedInput = {
  connect?: InputMaybe<Array<ResellerTierHistoryWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<ResellerTierHistoryCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<ResellerTierHistoryCreateWithoutUserInput>>;
  createMany?: InputMaybe<ResellerTierHistoryCreateManyUserInputEnvelope>;
  delete?: InputMaybe<Array<ResellerTierHistoryWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<ResellerTierHistoryScalarWhereInput>>;
  disconnect?: InputMaybe<Array<ResellerTierHistoryWhereUniqueInput>>;
  set?: InputMaybe<Array<ResellerTierHistoryWhereUniqueInput>>;
  update?: InputMaybe<Array<ResellerTierHistoryUpdateWithWhereUniqueWithoutUserInput>>;
  updateMany?: InputMaybe<Array<ResellerTierHistoryUpdateManyWithWhereWithoutUserInput>>;
  upsert?: InputMaybe<Array<ResellerTierHistoryUpsertWithWhereUniqueWithoutUserInput>>;
};

export type ResellerTierHistoryUpdateWithWhereUniqueWithoutAdminInput = {
  data: ResellerTierHistoryUpdateWithoutAdminInput;
  where: ResellerTierHistoryWhereUniqueInput;
};

export type ResellerTierHistoryUpdateWithWhereUniqueWithoutUserInput = {
  data: ResellerTierHistoryUpdateWithoutUserInput;
  where: ResellerTierHistoryWhereUniqueInput;
};

export type ResellerTierHistoryUpdateWithoutAdminInput = {
  changedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fromTier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  toTier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneRequiredWithoutResellerTierHistoryNestedInput>;
};

export type ResellerTierHistoryUpdateWithoutUserInput = {
  admin?: InputMaybe<UserUpdateOneRequiredWithoutResellerTierHistoryChangedBysNestedInput>;
  changedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fromTier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  toTier?: InputMaybe<EnumUserTierFieldUpdateOperationsInput>;
};

export type ResellerTierHistoryUpsertWithWhereUniqueWithoutAdminInput = {
  create: ResellerTierHistoryCreateWithoutAdminInput;
  update: ResellerTierHistoryUpdateWithoutAdminInput;
  where: ResellerTierHistoryWhereUniqueInput;
};

export type ResellerTierHistoryUpsertWithWhereUniqueWithoutUserInput = {
  create: ResellerTierHistoryCreateWithoutUserInput;
  update: ResellerTierHistoryUpdateWithoutUserInput;
  where: ResellerTierHistoryWhereUniqueInput;
};

export type ResellerTierHistoryWhereInput = {
  AND?: InputMaybe<Array<ResellerTierHistoryWhereInput>>;
  NOT?: InputMaybe<Array<ResellerTierHistoryWhereInput>>;
  OR?: InputMaybe<Array<ResellerTierHistoryWhereInput>>;
  admin?: InputMaybe<UserScalarRelationFilter>;
  changedAt?: InputMaybe<DateTimeFilter>;
  changedBy?: InputMaybe<StringFilter>;
  fromTier?: InputMaybe<EnumUserTierFilter>;
  id?: InputMaybe<StringFilter>;
  toTier?: InputMaybe<EnumUserTierFilter>;
  user?: InputMaybe<UserScalarRelationFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type ResellerTierHistoryWhereUniqueInput = {
  AND?: InputMaybe<Array<ResellerTierHistoryWhereInput>>;
  NOT?: InputMaybe<Array<ResellerTierHistoryWhereInput>>;
  OR?: InputMaybe<Array<ResellerTierHistoryWhereInput>>;
  admin?: InputMaybe<UserScalarRelationFilter>;
  changedAt?: InputMaybe<DateTimeFilter>;
  changedBy?: InputMaybe<StringFilter>;
  fromTier?: InputMaybe<EnumUserTierFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  toTier?: InputMaybe<EnumUserTierFilter>;
  user?: InputMaybe<UserScalarRelationFilter>;
  userId?: InputMaybe<StringFilter>;
};

export enum ReturnLocation {
  Lagos = 'LAGOS',
  OutsideLagos = 'OUTSIDE_LAGOS'
}

export enum ReturnStatus {
  Accepted = 'ACCEPTED',
  Fulfilled = 'FULFILLED',
  Pending = 'PENDING',
  Rejected = 'REJECTED'
}

export type RfqDashboard = {
  __typename?: 'RfqDashboard';
  draft: Scalars['Float']['output'];
  pendingQuotes: Array<SupplierQuoteSummary>;
  rejected: Scalars['Float']['output'];
  requisitionId?: Maybe<Scalars['ID']['output']>;
  selected: Scalars['Float']['output'];
  submitted: Scalars['Float']['output'];
  total: Scalars['Float']['output'];
};

export type RfqStatusCounts = {
  __typename?: 'RfqStatusCounts';
  draft: Scalars['Float']['output'];
  rejected: Scalars['Float']['output'];
  requisitionId?: Maybe<Scalars['ID']['output']>;
  selected: Scalars['Float']['output'];
  submitted: Scalars['Float']['output'];
  total: Scalars['Float']['output'];
};

export type Role = {
  __typename?: 'Role';
  _count: RoleCount;
  createdAt: Scalars['DateTime']['output'];
  createdBy?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  permissions?: Maybe<Array<Permission>>;
  users?: Maybe<Array<User>>;
};

export type RoleCount = {
  __typename?: 'RoleCount';
  permissions: Scalars['Int']['output'];
  users: Scalars['Int']['output'];
};

export type RoleCreateNestedOneWithoutUsersInput = {
  connect?: InputMaybe<RoleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<RoleCreateOrConnectWithoutUsersInput>;
  create?: InputMaybe<RoleCreateWithoutUsersInput>;
};

export type RoleCreateOrConnectWithoutUsersInput = {
  create: RoleCreateWithoutUsersInput;
  where: RoleWhereUniqueInput;
};

export type RoleCreateWithoutUsersInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  createdBy?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  permissions?: InputMaybe<PermissionCreateNestedManyWithoutRolesInput>;
};

export type RoleListRelationFilter = {
  every?: InputMaybe<RoleWhereInput>;
  none?: InputMaybe<RoleWhereInput>;
  some?: InputMaybe<RoleWhereInput>;
};

export enum RoleName {
  Admin = 'ADMIN',
  Biller = 'BILLER',
  Manager = 'MANAGER'
}

export type RoleOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  createdBy?: InputMaybe<SortOrderInput>;
  description?: InputMaybe<SortOrderInput>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  permissions?: InputMaybe<PermissionOrderByRelationAggregateInput>;
  users?: InputMaybe<UserOrderByRelationAggregateInput>;
};

export type RoleScalarRelationFilter = {
  is?: InputMaybe<RoleWhereInput>;
  isNot?: InputMaybe<RoleWhereInput>;
};

export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
  connect?: InputMaybe<RoleWhereUniqueInput>;
  connectOrCreate?: InputMaybe<RoleCreateOrConnectWithoutUsersInput>;
  create?: InputMaybe<RoleCreateWithoutUsersInput>;
  update?: InputMaybe<RoleUpdateToOneWithWhereWithoutUsersInput>;
  upsert?: InputMaybe<RoleUpsertWithoutUsersInput>;
};

export type RoleUpdateToOneWithWhereWithoutUsersInput = {
  data: RoleUpdateWithoutUsersInput;
  where?: InputMaybe<RoleWhereInput>;
};

export type RoleUpdateWithoutUsersInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  createdBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  description?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  permissions?: InputMaybe<PermissionUpdateManyWithoutRolesNestedInput>;
};

export type RoleUpsertWithoutUsersInput = {
  create: RoleCreateWithoutUsersInput;
  update: RoleUpdateWithoutUsersInput;
  where?: InputMaybe<RoleWhereInput>;
};

export type RoleWhereInput = {
  AND?: InputMaybe<Array<RoleWhereInput>>;
  NOT?: InputMaybe<Array<RoleWhereInput>>;
  OR?: InputMaybe<Array<RoleWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  createdBy?: InputMaybe<StringNullableFilter>;
  description?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  permissions?: InputMaybe<PermissionListRelationFilter>;
  users?: InputMaybe<UserListRelationFilter>;
};

export type RoleWhereUniqueInput = {
  AND?: InputMaybe<Array<RoleWhereInput>>;
  NOT?: InputMaybe<Array<RoleWhereInput>>;
  OR?: InputMaybe<Array<RoleWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  createdBy?: InputMaybe<StringNullableFilter>;
  description?: InputMaybe<StringNullableFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissions?: InputMaybe<PermissionListRelationFilter>;
  users?: InputMaybe<UserListRelationFilter>;
};

export enum SaleChannel {
  App = 'APP',
  InStore = 'IN_STORE',
  Web = 'WEB'
}

export type SaleOrder = {
  __typename?: 'SaleOrder';
  ConsumerPayment?: Maybe<Array<ConsumerPayment>>;
  ResellerPayment?: Maybe<Array<ResellerPayment>>;
  _count: SaleOrderCount;
  billerId: Scalars['String']['output'];
  consumerSale?: Maybe<ConsumerSale>;
  createdAt: Scalars['DateTime']['output'];
  fulfillment?: Maybe<Fulfillment>;
  id: Scalars['ID']['output'];
  phase: OrderPhase;
  quotation?: Maybe<Quotation>;
  resellerSale?: Maybe<ResellerSale>;
  resellerSaleid?: Maybe<Scalars['String']['output']>;
  status: SaleStatus;
  storeId: Scalars['String']['output'];
  totalAmount: Scalars['Float']['output'];
  type: SaleType;
  updatedAt: Scalars['DateTime']['output'];
};

export type SaleOrderCount = {
  __typename?: 'SaleOrderCount';
  ConsumerPayment: Scalars['Int']['output'];
  ResellerPayment: Scalars['Int']['output'];
};

export type SaleOrderCreateNestedOneWithoutConsumerPaymentInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutConsumerPaymentInput>;
  create?: InputMaybe<SaleOrderCreateWithoutConsumerPaymentInput>;
};

export type SaleOrderCreateNestedOneWithoutConsumerSaleInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutConsumerSaleInput>;
  create?: InputMaybe<SaleOrderCreateWithoutConsumerSaleInput>;
};

export type SaleOrderCreateNestedOneWithoutFulfillmentInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutFulfillmentInput>;
  create?: InputMaybe<SaleOrderCreateWithoutFulfillmentInput>;
};

export type SaleOrderCreateNestedOneWithoutQuotationInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutQuotationInput>;
  create?: InputMaybe<SaleOrderCreateWithoutQuotationInput>;
};

export type SaleOrderCreateNestedOneWithoutResellerPaymentInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutResellerPaymentInput>;
  create?: InputMaybe<SaleOrderCreateWithoutResellerPaymentInput>;
};

export type SaleOrderCreateNestedOneWithoutResellerSaleInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutResellerSaleInput>;
  create?: InputMaybe<SaleOrderCreateWithoutResellerSaleInput>;
};

export type SaleOrderCreateOrConnectWithoutConsumerPaymentInput = {
  create: SaleOrderCreateWithoutConsumerPaymentInput;
  where: SaleOrderWhereUniqueInput;
};

export type SaleOrderCreateOrConnectWithoutConsumerSaleInput = {
  create: SaleOrderCreateWithoutConsumerSaleInput;
  where: SaleOrderWhereUniqueInput;
};

export type SaleOrderCreateOrConnectWithoutFulfillmentInput = {
  create: SaleOrderCreateWithoutFulfillmentInput;
  where: SaleOrderWhereUniqueInput;
};

export type SaleOrderCreateOrConnectWithoutQuotationInput = {
  create: SaleOrderCreateWithoutQuotationInput;
  where: SaleOrderWhereUniqueInput;
};

export type SaleOrderCreateOrConnectWithoutResellerPaymentInput = {
  create: SaleOrderCreateWithoutResellerPaymentInput;
  where: SaleOrderWhereUniqueInput;
};

export type SaleOrderCreateOrConnectWithoutResellerSaleInput = {
  create: SaleOrderCreateWithoutResellerSaleInput;
  where: SaleOrderWhereUniqueInput;
};

export type SaleOrderCreateWithoutConsumerPaymentInput = {
  ResellerPayment?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleOrderInput>;
  billerId: Scalars['String']['input'];
  consumerSale?: InputMaybe<ConsumerSaleCreateNestedOneWithoutSaleOrderInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fulfillment?: InputMaybe<FulfillmentCreateNestedOneWithoutSaleOrderInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  phase?: InputMaybe<OrderPhase>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleOrderInput>;
  resellerSale?: InputMaybe<ResellerSaleCreateNestedOneWithoutSaleOrderInput>;
  resellerSaleid?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<SaleStatus>;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SaleOrderCreateWithoutConsumerSaleInput = {
  ConsumerPayment?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleOrderInput>;
  ResellerPayment?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleOrderInput>;
  billerId: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fulfillment?: InputMaybe<FulfillmentCreateNestedOneWithoutSaleOrderInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  phase?: InputMaybe<OrderPhase>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleOrderInput>;
  resellerSale?: InputMaybe<ResellerSaleCreateNestedOneWithoutSaleOrderInput>;
  resellerSaleid?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<SaleStatus>;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SaleOrderCreateWithoutFulfillmentInput = {
  ConsumerPayment?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleOrderInput>;
  ResellerPayment?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleOrderInput>;
  billerId: Scalars['String']['input'];
  consumerSale?: InputMaybe<ConsumerSaleCreateNestedOneWithoutSaleOrderInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  phase?: InputMaybe<OrderPhase>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleOrderInput>;
  resellerSale?: InputMaybe<ResellerSaleCreateNestedOneWithoutSaleOrderInput>;
  resellerSaleid?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<SaleStatus>;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SaleOrderCreateWithoutQuotationInput = {
  ConsumerPayment?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleOrderInput>;
  ResellerPayment?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleOrderInput>;
  billerId: Scalars['String']['input'];
  consumerSale?: InputMaybe<ConsumerSaleCreateNestedOneWithoutSaleOrderInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fulfillment?: InputMaybe<FulfillmentCreateNestedOneWithoutSaleOrderInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  phase?: InputMaybe<OrderPhase>;
  resellerSale?: InputMaybe<ResellerSaleCreateNestedOneWithoutSaleOrderInput>;
  resellerSaleid?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<SaleStatus>;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SaleOrderCreateWithoutResellerPaymentInput = {
  ConsumerPayment?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleOrderInput>;
  billerId: Scalars['String']['input'];
  consumerSale?: InputMaybe<ConsumerSaleCreateNestedOneWithoutSaleOrderInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fulfillment?: InputMaybe<FulfillmentCreateNestedOneWithoutSaleOrderInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  phase?: InputMaybe<OrderPhase>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleOrderInput>;
  resellerSale?: InputMaybe<ResellerSaleCreateNestedOneWithoutSaleOrderInput>;
  resellerSaleid?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<SaleStatus>;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SaleOrderCreateWithoutResellerSaleInput = {
  ConsumerPayment?: InputMaybe<ConsumerPaymentCreateNestedManyWithoutSaleOrderInput>;
  ResellerPayment?: InputMaybe<ResellerPaymentCreateNestedManyWithoutSaleOrderInput>;
  billerId: Scalars['String']['input'];
  consumerSale?: InputMaybe<ConsumerSaleCreateNestedOneWithoutSaleOrderInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fulfillment?: InputMaybe<FulfillmentCreateNestedOneWithoutSaleOrderInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  phase?: InputMaybe<OrderPhase>;
  quotation?: InputMaybe<QuotationCreateNestedOneWithoutSaleOrderInput>;
  resellerSaleid?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<SaleStatus>;
  storeId: Scalars['String']['input'];
  totalAmount: Scalars['Float']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SaleOrderNullableScalarRelationFilter = {
  is?: InputMaybe<SaleOrderWhereInput>;
  isNot?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderScalarRelationFilter = {
  is?: InputMaybe<SaleOrderWhereInput>;
  isNot?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpdateOneRequiredWithoutConsumerPaymentNestedInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutConsumerPaymentInput>;
  create?: InputMaybe<SaleOrderCreateWithoutConsumerPaymentInput>;
  update?: InputMaybe<SaleOrderUpdateToOneWithWhereWithoutConsumerPaymentInput>;
  upsert?: InputMaybe<SaleOrderUpsertWithoutConsumerPaymentInput>;
};

export type SaleOrderUpdateOneRequiredWithoutConsumerSaleNestedInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutConsumerSaleInput>;
  create?: InputMaybe<SaleOrderCreateWithoutConsumerSaleInput>;
  update?: InputMaybe<SaleOrderUpdateToOneWithWhereWithoutConsumerSaleInput>;
  upsert?: InputMaybe<SaleOrderUpsertWithoutConsumerSaleInput>;
};

export type SaleOrderUpdateOneRequiredWithoutFulfillmentNestedInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutFulfillmentInput>;
  create?: InputMaybe<SaleOrderCreateWithoutFulfillmentInput>;
  update?: InputMaybe<SaleOrderUpdateToOneWithWhereWithoutFulfillmentInput>;
  upsert?: InputMaybe<SaleOrderUpsertWithoutFulfillmentInput>;
};

export type SaleOrderUpdateOneRequiredWithoutResellerPaymentNestedInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutResellerPaymentInput>;
  create?: InputMaybe<SaleOrderCreateWithoutResellerPaymentInput>;
  update?: InputMaybe<SaleOrderUpdateToOneWithWhereWithoutResellerPaymentInput>;
  upsert?: InputMaybe<SaleOrderUpsertWithoutResellerPaymentInput>;
};

export type SaleOrderUpdateOneRequiredWithoutResellerSaleNestedInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutResellerSaleInput>;
  create?: InputMaybe<SaleOrderCreateWithoutResellerSaleInput>;
  update?: InputMaybe<SaleOrderUpdateToOneWithWhereWithoutResellerSaleInput>;
  upsert?: InputMaybe<SaleOrderUpsertWithoutResellerSaleInput>;
};

export type SaleOrderUpdateOneWithoutQuotationNestedInput = {
  connect?: InputMaybe<SaleOrderWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SaleOrderCreateOrConnectWithoutQuotationInput>;
  create?: InputMaybe<SaleOrderCreateWithoutQuotationInput>;
  delete?: InputMaybe<SaleOrderWhereInput>;
  disconnect?: InputMaybe<SaleOrderWhereInput>;
  update?: InputMaybe<SaleOrderUpdateToOneWithWhereWithoutQuotationInput>;
  upsert?: InputMaybe<SaleOrderUpsertWithoutQuotationInput>;
};

export type SaleOrderUpdateToOneWithWhereWithoutConsumerPaymentInput = {
  data: SaleOrderUpdateWithoutConsumerPaymentInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpdateToOneWithWhereWithoutConsumerSaleInput = {
  data: SaleOrderUpdateWithoutConsumerSaleInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpdateToOneWithWhereWithoutFulfillmentInput = {
  data: SaleOrderUpdateWithoutFulfillmentInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpdateToOneWithWhereWithoutQuotationInput = {
  data: SaleOrderUpdateWithoutQuotationInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpdateToOneWithWhereWithoutResellerPaymentInput = {
  data: SaleOrderUpdateWithoutResellerPaymentInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpdateToOneWithWhereWithoutResellerSaleInput = {
  data: SaleOrderUpdateWithoutResellerSaleInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpdateWithoutConsumerPaymentInput = {
  ResellerPayment?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleOrderNestedInput>;
  billerId?: InputMaybe<StringFieldUpdateOperationsInput>;
  consumerSale?: InputMaybe<ConsumerSaleUpdateOneWithoutSaleOrderNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fulfillment?: InputMaybe<FulfillmentUpdateOneWithoutSaleOrderNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  phase?: InputMaybe<EnumOrderPhaseFieldUpdateOperationsInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleOrderNestedInput>;
  resellerSale?: InputMaybe<ResellerSaleUpdateOneWithoutSaleOrderNestedInput>;
  resellerSaleid?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  storeId?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SaleOrderUpdateWithoutConsumerSaleInput = {
  ConsumerPayment?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleOrderNestedInput>;
  ResellerPayment?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleOrderNestedInput>;
  billerId?: InputMaybe<StringFieldUpdateOperationsInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fulfillment?: InputMaybe<FulfillmentUpdateOneWithoutSaleOrderNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  phase?: InputMaybe<EnumOrderPhaseFieldUpdateOperationsInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleOrderNestedInput>;
  resellerSale?: InputMaybe<ResellerSaleUpdateOneWithoutSaleOrderNestedInput>;
  resellerSaleid?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  storeId?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SaleOrderUpdateWithoutFulfillmentInput = {
  ConsumerPayment?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleOrderNestedInput>;
  ResellerPayment?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleOrderNestedInput>;
  billerId?: InputMaybe<StringFieldUpdateOperationsInput>;
  consumerSale?: InputMaybe<ConsumerSaleUpdateOneWithoutSaleOrderNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  phase?: InputMaybe<EnumOrderPhaseFieldUpdateOperationsInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleOrderNestedInput>;
  resellerSale?: InputMaybe<ResellerSaleUpdateOneWithoutSaleOrderNestedInput>;
  resellerSaleid?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  storeId?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SaleOrderUpdateWithoutQuotationInput = {
  ConsumerPayment?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleOrderNestedInput>;
  ResellerPayment?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleOrderNestedInput>;
  billerId?: InputMaybe<StringFieldUpdateOperationsInput>;
  consumerSale?: InputMaybe<ConsumerSaleUpdateOneWithoutSaleOrderNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fulfillment?: InputMaybe<FulfillmentUpdateOneWithoutSaleOrderNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  phase?: InputMaybe<EnumOrderPhaseFieldUpdateOperationsInput>;
  resellerSale?: InputMaybe<ResellerSaleUpdateOneWithoutSaleOrderNestedInput>;
  resellerSaleid?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  storeId?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SaleOrderUpdateWithoutResellerPaymentInput = {
  ConsumerPayment?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleOrderNestedInput>;
  billerId?: InputMaybe<StringFieldUpdateOperationsInput>;
  consumerSale?: InputMaybe<ConsumerSaleUpdateOneWithoutSaleOrderNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fulfillment?: InputMaybe<FulfillmentUpdateOneWithoutSaleOrderNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  phase?: InputMaybe<EnumOrderPhaseFieldUpdateOperationsInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleOrderNestedInput>;
  resellerSale?: InputMaybe<ResellerSaleUpdateOneWithoutSaleOrderNestedInput>;
  resellerSaleid?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  storeId?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SaleOrderUpdateWithoutResellerSaleInput = {
  ConsumerPayment?: InputMaybe<ConsumerPaymentUpdateManyWithoutSaleOrderNestedInput>;
  ResellerPayment?: InputMaybe<ResellerPaymentUpdateManyWithoutSaleOrderNestedInput>;
  billerId?: InputMaybe<StringFieldUpdateOperationsInput>;
  consumerSale?: InputMaybe<ConsumerSaleUpdateOneWithoutSaleOrderNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fulfillment?: InputMaybe<FulfillmentUpdateOneWithoutSaleOrderNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  phase?: InputMaybe<EnumOrderPhaseFieldUpdateOperationsInput>;
  quotation?: InputMaybe<QuotationUpdateOneWithoutSaleOrderNestedInput>;
  resellerSaleid?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSaleStatusFieldUpdateOperationsInput>;
  storeId?: InputMaybe<StringFieldUpdateOperationsInput>;
  totalAmount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SaleOrderUpsertWithoutConsumerPaymentInput = {
  create: SaleOrderCreateWithoutConsumerPaymentInput;
  update: SaleOrderUpdateWithoutConsumerPaymentInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpsertWithoutConsumerSaleInput = {
  create: SaleOrderCreateWithoutConsumerSaleInput;
  update: SaleOrderUpdateWithoutConsumerSaleInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpsertWithoutFulfillmentInput = {
  create: SaleOrderCreateWithoutFulfillmentInput;
  update: SaleOrderUpdateWithoutFulfillmentInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpsertWithoutQuotationInput = {
  create: SaleOrderCreateWithoutQuotationInput;
  update: SaleOrderUpdateWithoutQuotationInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpsertWithoutResellerPaymentInput = {
  create: SaleOrderCreateWithoutResellerPaymentInput;
  update: SaleOrderUpdateWithoutResellerPaymentInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderUpsertWithoutResellerSaleInput = {
  create: SaleOrderCreateWithoutResellerSaleInput;
  update: SaleOrderUpdateWithoutResellerSaleInput;
  where?: InputMaybe<SaleOrderWhereInput>;
};

export type SaleOrderWhereInput = {
  AND?: InputMaybe<Array<SaleOrderWhereInput>>;
  ConsumerPayment?: InputMaybe<ConsumerPaymentListRelationFilter>;
  NOT?: InputMaybe<Array<SaleOrderWhereInput>>;
  OR?: InputMaybe<Array<SaleOrderWhereInput>>;
  ResellerPayment?: InputMaybe<ResellerPaymentListRelationFilter>;
  billerId?: InputMaybe<StringFilter>;
  consumerSale?: InputMaybe<ConsumerSaleNullableScalarRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  fulfillment?: InputMaybe<FulfillmentNullableScalarRelationFilter>;
  id?: InputMaybe<StringFilter>;
  phase?: InputMaybe<EnumOrderPhaseFilter>;
  quotation?: InputMaybe<QuotationNullableScalarRelationFilter>;
  resellerSale?: InputMaybe<ResellerSaleNullableScalarRelationFilter>;
  resellerSaleid?: InputMaybe<StringNullableFilter>;
  status?: InputMaybe<EnumSaleStatusFilter>;
  storeId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  type?: InputMaybe<EnumSaleTypeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type SaleOrderWhereUniqueInput = {
  AND?: InputMaybe<Array<SaleOrderWhereInput>>;
  ConsumerPayment?: InputMaybe<ConsumerPaymentListRelationFilter>;
  NOT?: InputMaybe<Array<SaleOrderWhereInput>>;
  OR?: InputMaybe<Array<SaleOrderWhereInput>>;
  ResellerPayment?: InputMaybe<ResellerPaymentListRelationFilter>;
  billerId?: InputMaybe<StringFilter>;
  consumerSale?: InputMaybe<ConsumerSaleNullableScalarRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  fulfillment?: InputMaybe<FulfillmentNullableScalarRelationFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  phase?: InputMaybe<EnumOrderPhaseFilter>;
  quotation?: InputMaybe<QuotationNullableScalarRelationFilter>;
  resellerSale?: InputMaybe<ResellerSaleNullableScalarRelationFilter>;
  resellerSaleid?: InputMaybe<StringNullableFilter>;
  status?: InputMaybe<EnumSaleStatusFilter>;
  storeId?: InputMaybe<StringFilter>;
  totalAmount?: InputMaybe<FloatFilter>;
  type?: InputMaybe<EnumSaleTypeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export enum SaleStatus {
  Approved = 'APPROVED',
  Cancelled = 'CANCELLED',
  Fulfilled = 'FULFILLED',
  Paid = 'PAID',
  Pending = 'PENDING'
}

export enum SaleType {
  Consumer = 'CONSUMER',
  Reseller = 'RESELLER'
}

export type SalesReturn = {
  __typename?: 'SalesReturn';
  _count: SalesReturnCount;
  approvedBy?: Maybe<User>;
  approvedById?: Maybe<Scalars['String']['output']>;
  consumerSale?: Maybe<ConsumerSale>;
  consumerSaleId?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  isApprovedLate: Scalars['Boolean']['output'];
  items?: Maybe<Array<SalesReturnItem>>;
  receivedBy: User;
  receivedById: Scalars['String']['output'];
  resellerSale?: Maybe<ResellerSale>;
  resellerSaleId?: Maybe<Scalars['String']['output']>;
  returnLocation: ReturnLocation;
  returnedBy: User;
  returnedById: Scalars['String']['output'];
  status: ReturnStatus;
  store: Store;
  storeId: Scalars['String']['output'];
  type: SaleType;
  updatedAt: Scalars['DateTime']['output'];
};

export type SalesReturnCount = {
  __typename?: 'SalesReturnCount';
  items: Scalars['Int']['output'];
};

export type SalesReturnCreateManyApprovedByInput = {
  consumerSaleId?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  receivedById: Scalars['String']['input'];
  resellerSaleId?: InputMaybe<Scalars['String']['input']>;
  returnLocation: ReturnLocation;
  returnedById: Scalars['String']['input'];
  status: ReturnStatus;
  storeId: Scalars['String']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateManyApprovedByInputEnvelope = {
  data: Array<SalesReturnCreateManyApprovedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SalesReturnCreateManyConsumerSaleInput = {
  approvedById?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  receivedById: Scalars['String']['input'];
  resellerSaleId?: InputMaybe<Scalars['String']['input']>;
  returnLocation: ReturnLocation;
  returnedById: Scalars['String']['input'];
  status: ReturnStatus;
  storeId: Scalars['String']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateManyConsumerSaleInputEnvelope = {
  data: Array<SalesReturnCreateManyConsumerSaleInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SalesReturnCreateManyReceivedByInput = {
  approvedById?: InputMaybe<Scalars['String']['input']>;
  consumerSaleId?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  resellerSaleId?: InputMaybe<Scalars['String']['input']>;
  returnLocation: ReturnLocation;
  returnedById: Scalars['String']['input'];
  status: ReturnStatus;
  storeId: Scalars['String']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateManyReceivedByInputEnvelope = {
  data: Array<SalesReturnCreateManyReceivedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SalesReturnCreateManyResellerSaleInput = {
  approvedById?: InputMaybe<Scalars['String']['input']>;
  consumerSaleId?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  receivedById: Scalars['String']['input'];
  returnLocation: ReturnLocation;
  returnedById: Scalars['String']['input'];
  status: ReturnStatus;
  storeId: Scalars['String']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateManyResellerSaleInputEnvelope = {
  data: Array<SalesReturnCreateManyResellerSaleInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SalesReturnCreateManyReturnedByInput = {
  approvedById?: InputMaybe<Scalars['String']['input']>;
  consumerSaleId?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  receivedById: Scalars['String']['input'];
  resellerSaleId?: InputMaybe<Scalars['String']['input']>;
  returnLocation: ReturnLocation;
  status: ReturnStatus;
  storeId: Scalars['String']['input'];
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateManyReturnedByInputEnvelope = {
  data: Array<SalesReturnCreateManyReturnedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SalesReturnCreateManyStoreInput = {
  approvedById?: InputMaybe<Scalars['String']['input']>;
  consumerSaleId?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  receivedById: Scalars['String']['input'];
  resellerSaleId?: InputMaybe<Scalars['String']['input']>;
  returnLocation: ReturnLocation;
  returnedById: Scalars['String']['input'];
  status: ReturnStatus;
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateManyStoreInputEnvelope = {
  data: Array<SalesReturnCreateManyStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SalesReturnCreateNestedManyWithoutApprovedByInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutApprovedByInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutApprovedByInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyApprovedByInputEnvelope>;
};

export type SalesReturnCreateNestedManyWithoutConsumerSaleInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutConsumerSaleInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutConsumerSaleInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyConsumerSaleInputEnvelope>;
};

export type SalesReturnCreateNestedManyWithoutReceivedByInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutReceivedByInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutReceivedByInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyReceivedByInputEnvelope>;
};

export type SalesReturnCreateNestedManyWithoutResellerSaleInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutResellerSaleInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutResellerSaleInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyResellerSaleInputEnvelope>;
};

export type SalesReturnCreateNestedManyWithoutReturnedByInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutReturnedByInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutReturnedByInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyReturnedByInputEnvelope>;
};

export type SalesReturnCreateNestedManyWithoutStoreInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutStoreInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyStoreInputEnvelope>;
};

export type SalesReturnCreateNestedOneWithoutItemsInput = {
  connect?: InputMaybe<SalesReturnWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SalesReturnCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<SalesReturnCreateWithoutItemsInput>;
};

export type SalesReturnCreateOrConnectWithoutApprovedByInput = {
  create: SalesReturnCreateWithoutApprovedByInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnCreateOrConnectWithoutConsumerSaleInput = {
  create: SalesReturnCreateWithoutConsumerSaleInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnCreateOrConnectWithoutItemsInput = {
  create: SalesReturnCreateWithoutItemsInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnCreateOrConnectWithoutReceivedByInput = {
  create: SalesReturnCreateWithoutReceivedByInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnCreateOrConnectWithoutResellerSaleInput = {
  create: SalesReturnCreateWithoutResellerSaleInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnCreateOrConnectWithoutReturnedByInput = {
  create: SalesReturnCreateWithoutReturnedByInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnCreateOrConnectWithoutStoreInput = {
  create: SalesReturnCreateWithoutStoreInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnCreateWithoutApprovedByInput = {
  consumerSale?: InputMaybe<ConsumerSaleCreateNestedOneWithoutSalesReturnInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  items?: InputMaybe<SalesReturnItemCreateNestedManyWithoutReturnInput>;
  receivedBy: UserCreateNestedOneWithoutSalesReturnReceiversInput;
  resellerSale?: InputMaybe<ResellerSaleCreateNestedOneWithoutSalesReturnInput>;
  returnLocation: ReturnLocation;
  returnedBy: UserCreateNestedOneWithoutSalesReturnRequestersInput;
  status: ReturnStatus;
  store: StoreCreateNestedOneWithoutSalesReturnsInput;
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateWithoutConsumerSaleInput = {
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutSalesReturnInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  items?: InputMaybe<SalesReturnItemCreateNestedManyWithoutReturnInput>;
  receivedBy: UserCreateNestedOneWithoutSalesReturnReceiversInput;
  resellerSale?: InputMaybe<ResellerSaleCreateNestedOneWithoutSalesReturnInput>;
  returnLocation: ReturnLocation;
  returnedBy: UserCreateNestedOneWithoutSalesReturnRequestersInput;
  status: ReturnStatus;
  store: StoreCreateNestedOneWithoutSalesReturnsInput;
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateWithoutItemsInput = {
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutSalesReturnInput>;
  consumerSale?: InputMaybe<ConsumerSaleCreateNestedOneWithoutSalesReturnInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  receivedBy: UserCreateNestedOneWithoutSalesReturnReceiversInput;
  resellerSale?: InputMaybe<ResellerSaleCreateNestedOneWithoutSalesReturnInput>;
  returnLocation: ReturnLocation;
  returnedBy: UserCreateNestedOneWithoutSalesReturnRequestersInput;
  status: ReturnStatus;
  store: StoreCreateNestedOneWithoutSalesReturnsInput;
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateWithoutReceivedByInput = {
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutSalesReturnInput>;
  consumerSale?: InputMaybe<ConsumerSaleCreateNestedOneWithoutSalesReturnInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  items?: InputMaybe<SalesReturnItemCreateNestedManyWithoutReturnInput>;
  resellerSale?: InputMaybe<ResellerSaleCreateNestedOneWithoutSalesReturnInput>;
  returnLocation: ReturnLocation;
  returnedBy: UserCreateNestedOneWithoutSalesReturnRequestersInput;
  status: ReturnStatus;
  store: StoreCreateNestedOneWithoutSalesReturnsInput;
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateWithoutResellerSaleInput = {
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutSalesReturnInput>;
  consumerSale?: InputMaybe<ConsumerSaleCreateNestedOneWithoutSalesReturnInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  items?: InputMaybe<SalesReturnItemCreateNestedManyWithoutReturnInput>;
  receivedBy: UserCreateNestedOneWithoutSalesReturnReceiversInput;
  returnLocation: ReturnLocation;
  returnedBy: UserCreateNestedOneWithoutSalesReturnRequestersInput;
  status: ReturnStatus;
  store: StoreCreateNestedOneWithoutSalesReturnsInput;
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateWithoutReturnedByInput = {
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutSalesReturnInput>;
  consumerSale?: InputMaybe<ConsumerSaleCreateNestedOneWithoutSalesReturnInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  items?: InputMaybe<SalesReturnItemCreateNestedManyWithoutReturnInput>;
  receivedBy: UserCreateNestedOneWithoutSalesReturnReceiversInput;
  resellerSale?: InputMaybe<ResellerSaleCreateNestedOneWithoutSalesReturnInput>;
  returnLocation: ReturnLocation;
  status: ReturnStatus;
  store: StoreCreateNestedOneWithoutSalesReturnsInput;
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnCreateWithoutStoreInput = {
  approvedBy?: InputMaybe<UserCreateNestedOneWithoutSalesReturnInput>;
  consumerSale?: InputMaybe<ConsumerSaleCreateNestedOneWithoutSalesReturnInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<Scalars['Boolean']['input']>;
  items?: InputMaybe<SalesReturnItemCreateNestedManyWithoutReturnInput>;
  receivedBy: UserCreateNestedOneWithoutSalesReturnReceiversInput;
  resellerSale?: InputMaybe<ResellerSaleCreateNestedOneWithoutSalesReturnInput>;
  returnLocation: ReturnLocation;
  returnedBy: UserCreateNestedOneWithoutSalesReturnRequestersInput;
  status: ReturnStatus;
  type: SaleType;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SalesReturnItem = {
  __typename?: 'SalesReturnItem';
  condition: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  return: SalesReturn;
  salesReturnId: Scalars['String']['output'];
};

export type SalesReturnItemCreateManyProductVariantInput = {
  condition: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  salesReturnId: Scalars['String']['input'];
};

export type SalesReturnItemCreateManyProductVariantInputEnvelope = {
  data: Array<SalesReturnItemCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SalesReturnItemCreateManyReturnInput = {
  condition: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type SalesReturnItemCreateManyReturnInputEnvelope = {
  data: Array<SalesReturnItemCreateManyReturnInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SalesReturnItemCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<SalesReturnItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<SalesReturnItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<SalesReturnItemCreateManyProductVariantInputEnvelope>;
};

export type SalesReturnItemCreateNestedManyWithoutReturnInput = {
  connect?: InputMaybe<Array<SalesReturnItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnItemCreateOrConnectWithoutReturnInput>>;
  create?: InputMaybe<Array<SalesReturnItemCreateWithoutReturnInput>>;
  createMany?: InputMaybe<SalesReturnItemCreateManyReturnInputEnvelope>;
};

export type SalesReturnItemCreateOrConnectWithoutProductVariantInput = {
  create: SalesReturnItemCreateWithoutProductVariantInput;
  where: SalesReturnItemWhereUniqueInput;
};

export type SalesReturnItemCreateOrConnectWithoutReturnInput = {
  create: SalesReturnItemCreateWithoutReturnInput;
  where: SalesReturnItemWhereUniqueInput;
};

export type SalesReturnItemCreateWithoutProductVariantInput = {
  condition: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  return: SalesReturnCreateNestedOneWithoutItemsInput;
};

export type SalesReturnItemCreateWithoutReturnInput = {
  condition: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutReturnItemsInput;
  quantity: Scalars['Int']['input'];
};

export type SalesReturnItemListRelationFilter = {
  every?: InputMaybe<SalesReturnItemWhereInput>;
  none?: InputMaybe<SalesReturnItemWhereInput>;
  some?: InputMaybe<SalesReturnItemWhereInput>;
};

export type SalesReturnItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SalesReturnItemScalarWhereInput = {
  AND?: InputMaybe<Array<SalesReturnItemScalarWhereInput>>;
  NOT?: InputMaybe<Array<SalesReturnItemScalarWhereInput>>;
  OR?: InputMaybe<Array<SalesReturnItemScalarWhereInput>>;
  condition?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  salesReturnId?: InputMaybe<StringFilter>;
};

export type SalesReturnItemUpdateManyMutationInput = {
  condition?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type SalesReturnItemUpdateManyWithWhereWithoutProductVariantInput = {
  data: SalesReturnItemUpdateManyMutationInput;
  where: SalesReturnItemScalarWhereInput;
};

export type SalesReturnItemUpdateManyWithWhereWithoutReturnInput = {
  data: SalesReturnItemUpdateManyMutationInput;
  where: SalesReturnItemScalarWhereInput;
};

export type SalesReturnItemUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<SalesReturnItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<SalesReturnItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<SalesReturnItemCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<SalesReturnItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SalesReturnItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SalesReturnItemWhereUniqueInput>>;
  set?: InputMaybe<Array<SalesReturnItemWhereUniqueInput>>;
  update?: InputMaybe<Array<SalesReturnItemUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<SalesReturnItemUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<SalesReturnItemUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type SalesReturnItemUpdateManyWithoutReturnNestedInput = {
  connect?: InputMaybe<Array<SalesReturnItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnItemCreateOrConnectWithoutReturnInput>>;
  create?: InputMaybe<Array<SalesReturnItemCreateWithoutReturnInput>>;
  createMany?: InputMaybe<SalesReturnItemCreateManyReturnInputEnvelope>;
  delete?: InputMaybe<Array<SalesReturnItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SalesReturnItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SalesReturnItemWhereUniqueInput>>;
  set?: InputMaybe<Array<SalesReturnItemWhereUniqueInput>>;
  update?: InputMaybe<Array<SalesReturnItemUpdateWithWhereUniqueWithoutReturnInput>>;
  updateMany?: InputMaybe<Array<SalesReturnItemUpdateManyWithWhereWithoutReturnInput>>;
  upsert?: InputMaybe<Array<SalesReturnItemUpsertWithWhereUniqueWithoutReturnInput>>;
};

export type SalesReturnItemUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: SalesReturnItemUpdateWithoutProductVariantInput;
  where: SalesReturnItemWhereUniqueInput;
};

export type SalesReturnItemUpdateWithWhereUniqueWithoutReturnInput = {
  data: SalesReturnItemUpdateWithoutReturnInput;
  where: SalesReturnItemWhereUniqueInput;
};

export type SalesReturnItemUpdateWithoutProductVariantInput = {
  condition?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  return?: InputMaybe<SalesReturnUpdateOneRequiredWithoutItemsNestedInput>;
};

export type SalesReturnItemUpdateWithoutReturnInput = {
  condition?: InputMaybe<StringFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutReturnItemsNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type SalesReturnItemUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: SalesReturnItemCreateWithoutProductVariantInput;
  update: SalesReturnItemUpdateWithoutProductVariantInput;
  where: SalesReturnItemWhereUniqueInput;
};

export type SalesReturnItemUpsertWithWhereUniqueWithoutReturnInput = {
  create: SalesReturnItemCreateWithoutReturnInput;
  update: SalesReturnItemUpdateWithoutReturnInput;
  where: SalesReturnItemWhereUniqueInput;
};

export type SalesReturnItemWhereInput = {
  AND?: InputMaybe<Array<SalesReturnItemWhereInput>>;
  NOT?: InputMaybe<Array<SalesReturnItemWhereInput>>;
  OR?: InputMaybe<Array<SalesReturnItemWhereInput>>;
  condition?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  return?: InputMaybe<SalesReturnScalarRelationFilter>;
  salesReturnId?: InputMaybe<StringFilter>;
};

export type SalesReturnItemWhereUniqueInput = {
  AND?: InputMaybe<Array<SalesReturnItemWhereInput>>;
  NOT?: InputMaybe<Array<SalesReturnItemWhereInput>>;
  OR?: InputMaybe<Array<SalesReturnItemWhereInput>>;
  condition?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  return?: InputMaybe<SalesReturnScalarRelationFilter>;
  salesReturnId?: InputMaybe<StringFilter>;
};

export type SalesReturnListRelationFilter = {
  every?: InputMaybe<SalesReturnWhereInput>;
  none?: InputMaybe<SalesReturnWhereInput>;
  some?: InputMaybe<SalesReturnWhereInput>;
};

export type SalesReturnOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SalesReturnScalarRelationFilter = {
  is?: InputMaybe<SalesReturnWhereInput>;
  isNot?: InputMaybe<SalesReturnWhereInput>;
};

export type SalesReturnScalarWhereInput = {
  AND?: InputMaybe<Array<SalesReturnScalarWhereInput>>;
  NOT?: InputMaybe<Array<SalesReturnScalarWhereInput>>;
  OR?: InputMaybe<Array<SalesReturnScalarWhereInput>>;
  approvedById?: InputMaybe<StringNullableFilter>;
  consumerSaleId?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  isApprovedLate?: InputMaybe<BoolFilter>;
  receivedById?: InputMaybe<StringFilter>;
  resellerSaleId?: InputMaybe<StringNullableFilter>;
  returnLocation?: InputMaybe<EnumReturnLocationFilter>;
  returnedById?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumReturnStatusFilter>;
  storeId?: InputMaybe<StringFilter>;
  type?: InputMaybe<EnumSaleTypeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type SalesReturnUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isApprovedLate?: InputMaybe<BoolFieldUpdateOperationsInput>;
  returnLocation?: InputMaybe<EnumReturnLocationFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SalesReturnUpdateManyWithWhereWithoutApprovedByInput = {
  data: SalesReturnUpdateManyMutationInput;
  where: SalesReturnScalarWhereInput;
};

export type SalesReturnUpdateManyWithWhereWithoutConsumerSaleInput = {
  data: SalesReturnUpdateManyMutationInput;
  where: SalesReturnScalarWhereInput;
};

export type SalesReturnUpdateManyWithWhereWithoutReceivedByInput = {
  data: SalesReturnUpdateManyMutationInput;
  where: SalesReturnScalarWhereInput;
};

export type SalesReturnUpdateManyWithWhereWithoutResellerSaleInput = {
  data: SalesReturnUpdateManyMutationInput;
  where: SalesReturnScalarWhereInput;
};

export type SalesReturnUpdateManyWithWhereWithoutReturnedByInput = {
  data: SalesReturnUpdateManyMutationInput;
  where: SalesReturnScalarWhereInput;
};

export type SalesReturnUpdateManyWithWhereWithoutStoreInput = {
  data: SalesReturnUpdateManyMutationInput;
  where: SalesReturnScalarWhereInput;
};

export type SalesReturnUpdateManyWithoutApprovedByNestedInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutApprovedByInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutApprovedByInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyApprovedByInputEnvelope>;
  delete?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SalesReturnScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  set?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  update?: InputMaybe<Array<SalesReturnUpdateWithWhereUniqueWithoutApprovedByInput>>;
  updateMany?: InputMaybe<Array<SalesReturnUpdateManyWithWhereWithoutApprovedByInput>>;
  upsert?: InputMaybe<Array<SalesReturnUpsertWithWhereUniqueWithoutApprovedByInput>>;
};

export type SalesReturnUpdateManyWithoutConsumerSaleNestedInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutConsumerSaleInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutConsumerSaleInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyConsumerSaleInputEnvelope>;
  delete?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SalesReturnScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  set?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  update?: InputMaybe<Array<SalesReturnUpdateWithWhereUniqueWithoutConsumerSaleInput>>;
  updateMany?: InputMaybe<Array<SalesReturnUpdateManyWithWhereWithoutConsumerSaleInput>>;
  upsert?: InputMaybe<Array<SalesReturnUpsertWithWhereUniqueWithoutConsumerSaleInput>>;
};

export type SalesReturnUpdateManyWithoutReceivedByNestedInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutReceivedByInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutReceivedByInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyReceivedByInputEnvelope>;
  delete?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SalesReturnScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  set?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  update?: InputMaybe<Array<SalesReturnUpdateWithWhereUniqueWithoutReceivedByInput>>;
  updateMany?: InputMaybe<Array<SalesReturnUpdateManyWithWhereWithoutReceivedByInput>>;
  upsert?: InputMaybe<Array<SalesReturnUpsertWithWhereUniqueWithoutReceivedByInput>>;
};

export type SalesReturnUpdateManyWithoutResellerSaleNestedInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutResellerSaleInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutResellerSaleInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyResellerSaleInputEnvelope>;
  delete?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SalesReturnScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  set?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  update?: InputMaybe<Array<SalesReturnUpdateWithWhereUniqueWithoutResellerSaleInput>>;
  updateMany?: InputMaybe<Array<SalesReturnUpdateManyWithWhereWithoutResellerSaleInput>>;
  upsert?: InputMaybe<Array<SalesReturnUpsertWithWhereUniqueWithoutResellerSaleInput>>;
};

export type SalesReturnUpdateManyWithoutReturnedByNestedInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutReturnedByInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutReturnedByInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyReturnedByInputEnvelope>;
  delete?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SalesReturnScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  set?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  update?: InputMaybe<Array<SalesReturnUpdateWithWhereUniqueWithoutReturnedByInput>>;
  updateMany?: InputMaybe<Array<SalesReturnUpdateManyWithWhereWithoutReturnedByInput>>;
  upsert?: InputMaybe<Array<SalesReturnUpsertWithWhereUniqueWithoutReturnedByInput>>;
};

export type SalesReturnUpdateManyWithoutStoreNestedInput = {
  connect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SalesReturnCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<SalesReturnCreateWithoutStoreInput>>;
  createMany?: InputMaybe<SalesReturnCreateManyStoreInputEnvelope>;
  delete?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SalesReturnScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  set?: InputMaybe<Array<SalesReturnWhereUniqueInput>>;
  update?: InputMaybe<Array<SalesReturnUpdateWithWhereUniqueWithoutStoreInput>>;
  updateMany?: InputMaybe<Array<SalesReturnUpdateManyWithWhereWithoutStoreInput>>;
  upsert?: InputMaybe<Array<SalesReturnUpsertWithWhereUniqueWithoutStoreInput>>;
};

export type SalesReturnUpdateOneRequiredWithoutItemsNestedInput = {
  connect?: InputMaybe<SalesReturnWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SalesReturnCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<SalesReturnCreateWithoutItemsInput>;
  update?: InputMaybe<SalesReturnUpdateToOneWithWhereWithoutItemsInput>;
  upsert?: InputMaybe<SalesReturnUpsertWithoutItemsInput>;
};

export type SalesReturnUpdateToOneWithWhereWithoutItemsInput = {
  data: SalesReturnUpdateWithoutItemsInput;
  where?: InputMaybe<SalesReturnWhereInput>;
};

export type SalesReturnUpdateWithWhereUniqueWithoutApprovedByInput = {
  data: SalesReturnUpdateWithoutApprovedByInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpdateWithWhereUniqueWithoutConsumerSaleInput = {
  data: SalesReturnUpdateWithoutConsumerSaleInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpdateWithWhereUniqueWithoutReceivedByInput = {
  data: SalesReturnUpdateWithoutReceivedByInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpdateWithWhereUniqueWithoutResellerSaleInput = {
  data: SalesReturnUpdateWithoutResellerSaleInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpdateWithWhereUniqueWithoutReturnedByInput = {
  data: SalesReturnUpdateWithoutReturnedByInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpdateWithWhereUniqueWithoutStoreInput = {
  data: SalesReturnUpdateWithoutStoreInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpdateWithoutApprovedByInput = {
  consumerSale?: InputMaybe<ConsumerSaleUpdateOneWithoutSalesReturnNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isApprovedLate?: InputMaybe<BoolFieldUpdateOperationsInput>;
  items?: InputMaybe<SalesReturnItemUpdateManyWithoutReturnNestedInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnReceiversNestedInput>;
  resellerSale?: InputMaybe<ResellerSaleUpdateOneWithoutSalesReturnNestedInput>;
  returnLocation?: InputMaybe<EnumReturnLocationFieldUpdateOperationsInput>;
  returnedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnRequestersNestedInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutSalesReturnsNestedInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SalesReturnUpdateWithoutConsumerSaleInput = {
  approvedBy?: InputMaybe<UserUpdateOneWithoutSalesReturnNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isApprovedLate?: InputMaybe<BoolFieldUpdateOperationsInput>;
  items?: InputMaybe<SalesReturnItemUpdateManyWithoutReturnNestedInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnReceiversNestedInput>;
  resellerSale?: InputMaybe<ResellerSaleUpdateOneWithoutSalesReturnNestedInput>;
  returnLocation?: InputMaybe<EnumReturnLocationFieldUpdateOperationsInput>;
  returnedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnRequestersNestedInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutSalesReturnsNestedInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SalesReturnUpdateWithoutItemsInput = {
  approvedBy?: InputMaybe<UserUpdateOneWithoutSalesReturnNestedInput>;
  consumerSale?: InputMaybe<ConsumerSaleUpdateOneWithoutSalesReturnNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isApprovedLate?: InputMaybe<BoolFieldUpdateOperationsInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnReceiversNestedInput>;
  resellerSale?: InputMaybe<ResellerSaleUpdateOneWithoutSalesReturnNestedInput>;
  returnLocation?: InputMaybe<EnumReturnLocationFieldUpdateOperationsInput>;
  returnedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnRequestersNestedInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutSalesReturnsNestedInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SalesReturnUpdateWithoutReceivedByInput = {
  approvedBy?: InputMaybe<UserUpdateOneWithoutSalesReturnNestedInput>;
  consumerSale?: InputMaybe<ConsumerSaleUpdateOneWithoutSalesReturnNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isApprovedLate?: InputMaybe<BoolFieldUpdateOperationsInput>;
  items?: InputMaybe<SalesReturnItemUpdateManyWithoutReturnNestedInput>;
  resellerSale?: InputMaybe<ResellerSaleUpdateOneWithoutSalesReturnNestedInput>;
  returnLocation?: InputMaybe<EnumReturnLocationFieldUpdateOperationsInput>;
  returnedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnRequestersNestedInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutSalesReturnsNestedInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SalesReturnUpdateWithoutResellerSaleInput = {
  approvedBy?: InputMaybe<UserUpdateOneWithoutSalesReturnNestedInput>;
  consumerSale?: InputMaybe<ConsumerSaleUpdateOneWithoutSalesReturnNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isApprovedLate?: InputMaybe<BoolFieldUpdateOperationsInput>;
  items?: InputMaybe<SalesReturnItemUpdateManyWithoutReturnNestedInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnReceiversNestedInput>;
  returnLocation?: InputMaybe<EnumReturnLocationFieldUpdateOperationsInput>;
  returnedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnRequestersNestedInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutSalesReturnsNestedInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SalesReturnUpdateWithoutReturnedByInput = {
  approvedBy?: InputMaybe<UserUpdateOneWithoutSalesReturnNestedInput>;
  consumerSale?: InputMaybe<ConsumerSaleUpdateOneWithoutSalesReturnNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isApprovedLate?: InputMaybe<BoolFieldUpdateOperationsInput>;
  items?: InputMaybe<SalesReturnItemUpdateManyWithoutReturnNestedInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnReceiversNestedInput>;
  resellerSale?: InputMaybe<ResellerSaleUpdateOneWithoutSalesReturnNestedInput>;
  returnLocation?: InputMaybe<EnumReturnLocationFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutSalesReturnsNestedInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SalesReturnUpdateWithoutStoreInput = {
  approvedBy?: InputMaybe<UserUpdateOneWithoutSalesReturnNestedInput>;
  consumerSale?: InputMaybe<ConsumerSaleUpdateOneWithoutSalesReturnNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isApprovedLate?: InputMaybe<BoolFieldUpdateOperationsInput>;
  items?: InputMaybe<SalesReturnItemUpdateManyWithoutReturnNestedInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnReceiversNestedInput>;
  resellerSale?: InputMaybe<ResellerSaleUpdateOneWithoutSalesReturnNestedInput>;
  returnLocation?: InputMaybe<EnumReturnLocationFieldUpdateOperationsInput>;
  returnedBy?: InputMaybe<UserUpdateOneRequiredWithoutSalesReturnRequestersNestedInput>;
  status?: InputMaybe<EnumReturnStatusFieldUpdateOperationsInput>;
  type?: InputMaybe<EnumSaleTypeFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SalesReturnUpsertWithWhereUniqueWithoutApprovedByInput = {
  create: SalesReturnCreateWithoutApprovedByInput;
  update: SalesReturnUpdateWithoutApprovedByInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpsertWithWhereUniqueWithoutConsumerSaleInput = {
  create: SalesReturnCreateWithoutConsumerSaleInput;
  update: SalesReturnUpdateWithoutConsumerSaleInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpsertWithWhereUniqueWithoutReceivedByInput = {
  create: SalesReturnCreateWithoutReceivedByInput;
  update: SalesReturnUpdateWithoutReceivedByInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpsertWithWhereUniqueWithoutResellerSaleInput = {
  create: SalesReturnCreateWithoutResellerSaleInput;
  update: SalesReturnUpdateWithoutResellerSaleInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpsertWithWhereUniqueWithoutReturnedByInput = {
  create: SalesReturnCreateWithoutReturnedByInput;
  update: SalesReturnUpdateWithoutReturnedByInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpsertWithWhereUniqueWithoutStoreInput = {
  create: SalesReturnCreateWithoutStoreInput;
  update: SalesReturnUpdateWithoutStoreInput;
  where: SalesReturnWhereUniqueInput;
};

export type SalesReturnUpsertWithoutItemsInput = {
  create: SalesReturnCreateWithoutItemsInput;
  update: SalesReturnUpdateWithoutItemsInput;
  where?: InputMaybe<SalesReturnWhereInput>;
};

export type SalesReturnWhereInput = {
  AND?: InputMaybe<Array<SalesReturnWhereInput>>;
  NOT?: InputMaybe<Array<SalesReturnWhereInput>>;
  OR?: InputMaybe<Array<SalesReturnWhereInput>>;
  approvedBy?: InputMaybe<UserNullableScalarRelationFilter>;
  approvedById?: InputMaybe<StringNullableFilter>;
  consumerSale?: InputMaybe<ConsumerSaleNullableScalarRelationFilter>;
  consumerSaleId?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  isApprovedLate?: InputMaybe<BoolFilter>;
  items?: InputMaybe<SalesReturnItemListRelationFilter>;
  receivedBy?: InputMaybe<UserScalarRelationFilter>;
  receivedById?: InputMaybe<StringFilter>;
  resellerSale?: InputMaybe<ResellerSaleNullableScalarRelationFilter>;
  resellerSaleId?: InputMaybe<StringNullableFilter>;
  returnLocation?: InputMaybe<EnumReturnLocationFilter>;
  returnedBy?: InputMaybe<UserScalarRelationFilter>;
  returnedById?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumReturnStatusFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  type?: InputMaybe<EnumSaleTypeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type SalesReturnWhereUniqueInput = {
  AND?: InputMaybe<Array<SalesReturnWhereInput>>;
  NOT?: InputMaybe<Array<SalesReturnWhereInput>>;
  OR?: InputMaybe<Array<SalesReturnWhereInput>>;
  approvedBy?: InputMaybe<UserNullableScalarRelationFilter>;
  approvedById?: InputMaybe<StringNullableFilter>;
  consumerSale?: InputMaybe<ConsumerSaleNullableScalarRelationFilter>;
  consumerSaleId?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  isApprovedLate?: InputMaybe<BoolFilter>;
  items?: InputMaybe<SalesReturnItemListRelationFilter>;
  receivedBy?: InputMaybe<UserScalarRelationFilter>;
  receivedById?: InputMaybe<StringFilter>;
  resellerSale?: InputMaybe<ResellerSaleNullableScalarRelationFilter>;
  resellerSaleId?: InputMaybe<StringNullableFilter>;
  returnLocation?: InputMaybe<EnumReturnLocationFilter>;
  returnedBy?: InputMaybe<UserScalarRelationFilter>;
  returnedById?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumReturnStatusFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  type?: InputMaybe<EnumSaleTypeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type SelectSupplierQuoteInput = {
  exclusive?: InputMaybe<Scalars['Boolean']['input']>;
  quoteId: Scalars['String']['input'];
};

export type SendSupportMessageInput = {
  message: Scalars['String']['input'];
};

export type SetReorderSettingsInput = {
  productVariantId: Scalars['String']['input'];
  reorderPoint?: InputMaybe<Scalars['Int']['input']>;
  reorderQty?: InputMaybe<Scalars['Int']['input']>;
  storeId: Scalars['String']['input'];
};

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type SortOrderInput = {
  nulls?: InputMaybe<NullsOrder>;
  sort: SortOrder;
};

export type Stock = {
  __typename?: 'Stock';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  reorderPoint?: Maybe<Scalars['Int']['output']>;
  reorderQty?: Maybe<Scalars['Int']['output']>;
  reserved: Scalars['Int']['output'];
  store: Store;
  storeId: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type StockAvgAggregate = {
  __typename?: 'StockAvgAggregate';
  quantity?: Maybe<Scalars['Float']['output']>;
  reorderPoint?: Maybe<Scalars['Float']['output']>;
  reorderQty?: Maybe<Scalars['Float']['output']>;
  reserved?: Maybe<Scalars['Float']['output']>;
};

export type StockCountAggregate = {
  __typename?: 'StockCountAggregate';
  _all: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  productVariantId: Scalars['Int']['output'];
  quantity: Scalars['Int']['output'];
  reorderPoint: Scalars['Int']['output'];
  reorderQty: Scalars['Int']['output'];
  reserved: Scalars['Int']['output'];
  storeId: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
};

export type StockCreateManyProductVariantInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  reorderPoint?: InputMaybe<Scalars['Int']['input']>;
  reorderQty?: InputMaybe<Scalars['Int']['input']>;
  reserved?: InputMaybe<Scalars['Int']['input']>;
  storeId: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StockCreateManyProductVariantInputEnvelope = {
  data: Array<StockCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockCreateManyStoreInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
  reorderPoint?: InputMaybe<Scalars['Int']['input']>;
  reorderQty?: InputMaybe<Scalars['Int']['input']>;
  reserved?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StockCreateManyStoreInputEnvelope = {
  data: Array<StockCreateManyStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<StockWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<StockCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<StockCreateManyProductVariantInputEnvelope>;
};

export type StockCreateNestedManyWithoutStoreInput = {
  connect?: InputMaybe<Array<StockWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<StockCreateWithoutStoreInput>>;
  createMany?: InputMaybe<StockCreateManyStoreInputEnvelope>;
};

export type StockCreateOrConnectWithoutProductVariantInput = {
  create: StockCreateWithoutProductVariantInput;
  where: StockWhereUniqueInput;
};

export type StockCreateOrConnectWithoutStoreInput = {
  create: StockCreateWithoutStoreInput;
  where: StockWhereUniqueInput;
};

export type StockCreateWithoutProductVariantInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  reorderPoint?: InputMaybe<Scalars['Int']['input']>;
  reorderQty?: InputMaybe<Scalars['Int']['input']>;
  reserved?: InputMaybe<Scalars['Int']['input']>;
  store: StoreCreateNestedOneWithoutStocksInput;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StockCreateWithoutStoreInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutStockItemsInput;
  quantity: Scalars['Int']['input'];
  reorderPoint?: InputMaybe<Scalars['Int']['input']>;
  reorderQty?: InputMaybe<Scalars['Int']['input']>;
  reserved?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StockListRelationFilter = {
  every?: InputMaybe<StockWhereInput>;
  none?: InputMaybe<StockWhereInput>;
  some?: InputMaybe<StockWhereInput>;
};

export type StockMaxAggregate = {
  __typename?: 'StockMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  productVariantId?: Maybe<Scalars['String']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  reorderPoint?: Maybe<Scalars['Int']['output']>;
  reorderQty?: Maybe<Scalars['Int']['output']>;
  reserved?: Maybe<Scalars['Int']['output']>;
  storeId?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type StockMinAggregate = {
  __typename?: 'StockMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  productVariantId?: Maybe<Scalars['String']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  reorderPoint?: Maybe<Scalars['Int']['output']>;
  reorderQty?: Maybe<Scalars['Int']['output']>;
  reserved?: Maybe<Scalars['Int']['output']>;
  storeId?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

/** Unified stock movements */
export type StockMovement = {
  __typename?: 'StockMovement';
  _count: StockMovementCount;
  createdAt: Scalars['DateTime']['output'];
  direction: MovementDirection;
  id: Scalars['ID']['output'];
  items?: Maybe<Array<StockMovementItem>>;
  movementType: MovementType;
  referenceEntity: Scalars['String']['output'];
  referenceId: Scalars['String']['output'];
  store: Store;
  storeId: Scalars['String']['output'];
};

export type StockMovementCount = {
  __typename?: 'StockMovementCount';
  items: Scalars['Int']['output'];
};

export type StockMovementCountAggregate = {
  __typename?: 'StockMovementCountAggregate';
  _all: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  direction: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  movementType: Scalars['Int']['output'];
  referenceEntity: Scalars['Int']['output'];
  referenceId: Scalars['Int']['output'];
  storeId: Scalars['Int']['output'];
};

export type StockMovementCreateManyStoreInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  direction: MovementDirection;
  id?: InputMaybe<Scalars['String']['input']>;
  movementType: MovementType;
  referenceEntity: Scalars['String']['input'];
  referenceId: Scalars['String']['input'];
};

export type StockMovementCreateManyStoreInputEnvelope = {
  data: Array<StockMovementCreateManyStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockMovementCreateNestedManyWithoutStoreInput = {
  connect?: InputMaybe<Array<StockMovementWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockMovementCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<StockMovementCreateWithoutStoreInput>>;
  createMany?: InputMaybe<StockMovementCreateManyStoreInputEnvelope>;
};

export type StockMovementCreateNestedOneWithoutItemsInput = {
  connect?: InputMaybe<StockMovementWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StockMovementCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<StockMovementCreateWithoutItemsInput>;
};

export type StockMovementCreateOrConnectWithoutItemsInput = {
  create: StockMovementCreateWithoutItemsInput;
  where: StockMovementWhereUniqueInput;
};

export type StockMovementCreateOrConnectWithoutStoreInput = {
  create: StockMovementCreateWithoutStoreInput;
  where: StockMovementWhereUniqueInput;
};

export type StockMovementCreateWithoutItemsInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  direction: MovementDirection;
  id?: InputMaybe<Scalars['String']['input']>;
  movementType: MovementType;
  referenceEntity: Scalars['String']['input'];
  referenceId: Scalars['String']['input'];
  store: StoreCreateNestedOneWithoutMovementsInput;
};

export type StockMovementCreateWithoutStoreInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  direction: MovementDirection;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockMovementItemCreateNestedManyWithoutMovementInput>;
  movementType: MovementType;
  referenceEntity: Scalars['String']['input'];
  referenceId: Scalars['String']['input'];
};

export type StockMovementItem = {
  __typename?: 'StockMovementItem';
  id: Scalars['ID']['output'];
  movement: StockMovement;
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  stockMovementId: Scalars['String']['output'];
};

export type StockMovementItemCreateManyMovementInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type StockMovementItemCreateManyMovementInputEnvelope = {
  data: Array<StockMovementItemCreateManyMovementInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockMovementItemCreateManyProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  stockMovementId: Scalars['String']['input'];
};

export type StockMovementItemCreateManyProductVariantInputEnvelope = {
  data: Array<StockMovementItemCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockMovementItemCreateNestedManyWithoutMovementInput = {
  connect?: InputMaybe<Array<StockMovementItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockMovementItemCreateOrConnectWithoutMovementInput>>;
  create?: InputMaybe<Array<StockMovementItemCreateWithoutMovementInput>>;
  createMany?: InputMaybe<StockMovementItemCreateManyMovementInputEnvelope>;
};

export type StockMovementItemCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<StockMovementItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockMovementItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<StockMovementItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<StockMovementItemCreateManyProductVariantInputEnvelope>;
};

export type StockMovementItemCreateOrConnectWithoutMovementInput = {
  create: StockMovementItemCreateWithoutMovementInput;
  where: StockMovementItemWhereUniqueInput;
};

export type StockMovementItemCreateOrConnectWithoutProductVariantInput = {
  create: StockMovementItemCreateWithoutProductVariantInput;
  where: StockMovementItemWhereUniqueInput;
};

export type StockMovementItemCreateWithoutMovementInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutStockMovementItemInput;
  quantity: Scalars['Int']['input'];
};

export type StockMovementItemCreateWithoutProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  movement: StockMovementCreateNestedOneWithoutItemsInput;
  quantity: Scalars['Int']['input'];
};

export type StockMovementItemListRelationFilter = {
  every?: InputMaybe<StockMovementItemWhereInput>;
  none?: InputMaybe<StockMovementItemWhereInput>;
  some?: InputMaybe<StockMovementItemWhereInput>;
};

export type StockMovementItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StockMovementItemScalarWhereInput = {
  AND?: InputMaybe<Array<StockMovementItemScalarWhereInput>>;
  NOT?: InputMaybe<Array<StockMovementItemScalarWhereInput>>;
  OR?: InputMaybe<Array<StockMovementItemScalarWhereInput>>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  stockMovementId?: InputMaybe<StringFilter>;
};

export type StockMovementItemUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StockMovementItemUpdateManyWithWhereWithoutMovementInput = {
  data: StockMovementItemUpdateManyMutationInput;
  where: StockMovementItemScalarWhereInput;
};

export type StockMovementItemUpdateManyWithWhereWithoutProductVariantInput = {
  data: StockMovementItemUpdateManyMutationInput;
  where: StockMovementItemScalarWhereInput;
};

export type StockMovementItemUpdateManyWithoutMovementNestedInput = {
  connect?: InputMaybe<Array<StockMovementItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockMovementItemCreateOrConnectWithoutMovementInput>>;
  create?: InputMaybe<Array<StockMovementItemCreateWithoutMovementInput>>;
  createMany?: InputMaybe<StockMovementItemCreateManyMovementInputEnvelope>;
  delete?: InputMaybe<Array<StockMovementItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockMovementItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockMovementItemWhereUniqueInput>>;
  set?: InputMaybe<Array<StockMovementItemWhereUniqueInput>>;
  update?: InputMaybe<Array<StockMovementItemUpdateWithWhereUniqueWithoutMovementInput>>;
  updateMany?: InputMaybe<Array<StockMovementItemUpdateManyWithWhereWithoutMovementInput>>;
  upsert?: InputMaybe<Array<StockMovementItemUpsertWithWhereUniqueWithoutMovementInput>>;
};

export type StockMovementItemUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<StockMovementItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockMovementItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<StockMovementItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<StockMovementItemCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<StockMovementItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockMovementItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockMovementItemWhereUniqueInput>>;
  set?: InputMaybe<Array<StockMovementItemWhereUniqueInput>>;
  update?: InputMaybe<Array<StockMovementItemUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<StockMovementItemUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<StockMovementItemUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type StockMovementItemUpdateWithWhereUniqueWithoutMovementInput = {
  data: StockMovementItemUpdateWithoutMovementInput;
  where: StockMovementItemWhereUniqueInput;
};

export type StockMovementItemUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: StockMovementItemUpdateWithoutProductVariantInput;
  where: StockMovementItemWhereUniqueInput;
};

export type StockMovementItemUpdateWithoutMovementInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutStockMovementItemNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StockMovementItemUpdateWithoutProductVariantInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  movement?: InputMaybe<StockMovementUpdateOneRequiredWithoutItemsNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StockMovementItemUpsertWithWhereUniqueWithoutMovementInput = {
  create: StockMovementItemCreateWithoutMovementInput;
  update: StockMovementItemUpdateWithoutMovementInput;
  where: StockMovementItemWhereUniqueInput;
};

export type StockMovementItemUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: StockMovementItemCreateWithoutProductVariantInput;
  update: StockMovementItemUpdateWithoutProductVariantInput;
  where: StockMovementItemWhereUniqueInput;
};

export type StockMovementItemWhereInput = {
  AND?: InputMaybe<Array<StockMovementItemWhereInput>>;
  NOT?: InputMaybe<Array<StockMovementItemWhereInput>>;
  OR?: InputMaybe<Array<StockMovementItemWhereInput>>;
  id?: InputMaybe<StringFilter>;
  movement?: InputMaybe<StockMovementScalarRelationFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  stockMovementId?: InputMaybe<StringFilter>;
};

export type StockMovementItemWhereUniqueInput = {
  AND?: InputMaybe<Array<StockMovementItemWhereInput>>;
  NOT?: InputMaybe<Array<StockMovementItemWhereInput>>;
  OR?: InputMaybe<Array<StockMovementItemWhereInput>>;
  id?: InputMaybe<Scalars['String']['input']>;
  movement?: InputMaybe<StockMovementScalarRelationFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  stockMovementId?: InputMaybe<StringFilter>;
};

export type StockMovementListRelationFilter = {
  every?: InputMaybe<StockMovementWhereInput>;
  none?: InputMaybe<StockMovementWhereInput>;
  some?: InputMaybe<StockMovementWhereInput>;
};

export type StockMovementMaxAggregate = {
  __typename?: 'StockMovementMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  direction?: Maybe<MovementDirection>;
  id?: Maybe<Scalars['String']['output']>;
  movementType?: Maybe<MovementType>;
  referenceEntity?: Maybe<Scalars['String']['output']>;
  referenceId?: Maybe<Scalars['String']['output']>;
  storeId?: Maybe<Scalars['String']['output']>;
};

export type StockMovementMinAggregate = {
  __typename?: 'StockMovementMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  direction?: Maybe<MovementDirection>;
  id?: Maybe<Scalars['String']['output']>;
  movementType?: Maybe<MovementType>;
  referenceEntity?: Maybe<Scalars['String']['output']>;
  referenceId?: Maybe<Scalars['String']['output']>;
  storeId?: Maybe<Scalars['String']['output']>;
};

export type StockMovementOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StockMovementScalarRelationFilter = {
  is?: InputMaybe<StockMovementWhereInput>;
  isNot?: InputMaybe<StockMovementWhereInput>;
};

export type StockMovementScalarWhereInput = {
  AND?: InputMaybe<Array<StockMovementScalarWhereInput>>;
  NOT?: InputMaybe<Array<StockMovementScalarWhereInput>>;
  OR?: InputMaybe<Array<StockMovementScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  direction?: InputMaybe<EnumMovementDirectionFilter>;
  id?: InputMaybe<StringFilter>;
  movementType?: InputMaybe<EnumMovementTypeFilter>;
  referenceEntity?: InputMaybe<StringFilter>;
  referenceId?: InputMaybe<StringFilter>;
  storeId?: InputMaybe<StringFilter>;
};

export type StockMovementUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  direction?: InputMaybe<EnumMovementDirectionFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  movementType?: InputMaybe<EnumMovementTypeFieldUpdateOperationsInput>;
  referenceEntity?: InputMaybe<StringFieldUpdateOperationsInput>;
  referenceId?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type StockMovementUpdateManyWithWhereWithoutStoreInput = {
  data: StockMovementUpdateManyMutationInput;
  where: StockMovementScalarWhereInput;
};

export type StockMovementUpdateManyWithoutStoreNestedInput = {
  connect?: InputMaybe<Array<StockMovementWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockMovementCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<StockMovementCreateWithoutStoreInput>>;
  createMany?: InputMaybe<StockMovementCreateManyStoreInputEnvelope>;
  delete?: InputMaybe<Array<StockMovementWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockMovementScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockMovementWhereUniqueInput>>;
  set?: InputMaybe<Array<StockMovementWhereUniqueInput>>;
  update?: InputMaybe<Array<StockMovementUpdateWithWhereUniqueWithoutStoreInput>>;
  updateMany?: InputMaybe<Array<StockMovementUpdateManyWithWhereWithoutStoreInput>>;
  upsert?: InputMaybe<Array<StockMovementUpsertWithWhereUniqueWithoutStoreInput>>;
};

export type StockMovementUpdateOneRequiredWithoutItemsNestedInput = {
  connect?: InputMaybe<StockMovementWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StockMovementCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<StockMovementCreateWithoutItemsInput>;
  update?: InputMaybe<StockMovementUpdateToOneWithWhereWithoutItemsInput>;
  upsert?: InputMaybe<StockMovementUpsertWithoutItemsInput>;
};

export type StockMovementUpdateToOneWithWhereWithoutItemsInput = {
  data: StockMovementUpdateWithoutItemsInput;
  where?: InputMaybe<StockMovementWhereInput>;
};

export type StockMovementUpdateWithWhereUniqueWithoutStoreInput = {
  data: StockMovementUpdateWithoutStoreInput;
  where: StockMovementWhereUniqueInput;
};

export type StockMovementUpdateWithoutItemsInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  direction?: InputMaybe<EnumMovementDirectionFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  movementType?: InputMaybe<EnumMovementTypeFieldUpdateOperationsInput>;
  referenceEntity?: InputMaybe<StringFieldUpdateOperationsInput>;
  referenceId?: InputMaybe<StringFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutMovementsNestedInput>;
};

export type StockMovementUpdateWithoutStoreInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  direction?: InputMaybe<EnumMovementDirectionFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<StockMovementItemUpdateManyWithoutMovementNestedInput>;
  movementType?: InputMaybe<EnumMovementTypeFieldUpdateOperationsInput>;
  referenceEntity?: InputMaybe<StringFieldUpdateOperationsInput>;
  referenceId?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type StockMovementUpsertWithWhereUniqueWithoutStoreInput = {
  create: StockMovementCreateWithoutStoreInput;
  update: StockMovementUpdateWithoutStoreInput;
  where: StockMovementWhereUniqueInput;
};

export type StockMovementUpsertWithoutItemsInput = {
  create: StockMovementCreateWithoutItemsInput;
  update: StockMovementUpdateWithoutItemsInput;
  where?: InputMaybe<StockMovementWhereInput>;
};

export type StockMovementWhereInput = {
  AND?: InputMaybe<Array<StockMovementWhereInput>>;
  NOT?: InputMaybe<Array<StockMovementWhereInput>>;
  OR?: InputMaybe<Array<StockMovementWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  direction?: InputMaybe<EnumMovementDirectionFilter>;
  id?: InputMaybe<StringFilter>;
  items?: InputMaybe<StockMovementItemListRelationFilter>;
  movementType?: InputMaybe<EnumMovementTypeFilter>;
  referenceEntity?: InputMaybe<StringFilter>;
  referenceId?: InputMaybe<StringFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
};

export type StockMovementWhereUniqueInput = {
  AND?: InputMaybe<Array<StockMovementWhereInput>>;
  NOT?: InputMaybe<Array<StockMovementWhereInput>>;
  OR?: InputMaybe<Array<StockMovementWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  direction?: InputMaybe<EnumMovementDirectionFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockMovementItemListRelationFilter>;
  movementType?: InputMaybe<EnumMovementTypeFilter>;
  referenceEntity?: InputMaybe<StringFilter>;
  referenceId?: InputMaybe<StringFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
};

export type StockOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StockReceiptBatch = {
  __typename?: 'StockReceiptBatch';
  PurchaseOrder?: Maybe<Array<PurchaseOrder>>;
  _count: StockReceiptBatchCount;
  confirmedBy: User;
  confirmedById: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  items?: Maybe<Array<StockReceiptBatchItem>>;
  purchaseOrderId: Scalars['String']['output'];
  purchaseReturns?: Maybe<Array<PurchaseReturnItem>>;
  receivedAt: Scalars['DateTime']['output'];
  receivedBy: User;
  receivedById: Scalars['String']['output'];
  store: Store;
  storeId: Scalars['String']['output'];
  waybillUrl?: Maybe<Scalars['String']['output']>;
};

export type StockReceiptBatchCount = {
  __typename?: 'StockReceiptBatchCount';
  PurchaseOrder: Scalars['Int']['output'];
  items: Scalars['Int']['output'];
  purchaseReturns: Scalars['Int']['output'];
};

export type StockReceiptBatchCountAggregate = {
  __typename?: 'StockReceiptBatchCountAggregate';
  _all: Scalars['Int']['output'];
  confirmedById: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  purchaseOrderId: Scalars['Int']['output'];
  receivedAt: Scalars['Int']['output'];
  receivedById: Scalars['Int']['output'];
  storeId: Scalars['Int']['output'];
  waybillUrl: Scalars['Int']['output'];
};

export type StockReceiptBatchCreateManyConfirmedByInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  purchaseOrderId: Scalars['String']['input'];
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedById: Scalars['String']['input'];
  storeId: Scalars['String']['input'];
  waybillUrl?: InputMaybe<Scalars['String']['input']>;
};

export type StockReceiptBatchCreateManyConfirmedByInputEnvelope = {
  data: Array<StockReceiptBatchCreateManyConfirmedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockReceiptBatchCreateManyReceivedByInput = {
  confirmedById: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  purchaseOrderId: Scalars['String']['input'];
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  storeId: Scalars['String']['input'];
  waybillUrl?: InputMaybe<Scalars['String']['input']>;
};

export type StockReceiptBatchCreateManyReceivedByInputEnvelope = {
  data: Array<StockReceiptBatchCreateManyReceivedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockReceiptBatchCreateManyStoreInput = {
  confirmedById: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  purchaseOrderId: Scalars['String']['input'];
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedById: Scalars['String']['input'];
  waybillUrl?: InputMaybe<Scalars['String']['input']>;
};

export type StockReceiptBatchCreateManyStoreInputEnvelope = {
  data: Array<StockReceiptBatchCreateManyStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockReceiptBatchCreateNestedManyWithoutConfirmedByInput = {
  connect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchCreateOrConnectWithoutConfirmedByInput>>;
  create?: InputMaybe<Array<StockReceiptBatchCreateWithoutConfirmedByInput>>;
  createMany?: InputMaybe<StockReceiptBatchCreateManyConfirmedByInputEnvelope>;
};

export type StockReceiptBatchCreateNestedManyWithoutPurchaseOrderInput = {
  connect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchCreateOrConnectWithoutPurchaseOrderInput>>;
  create?: InputMaybe<Array<StockReceiptBatchCreateWithoutPurchaseOrderInput>>;
};

export type StockReceiptBatchCreateNestedManyWithoutReceivedByInput = {
  connect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchCreateOrConnectWithoutReceivedByInput>>;
  create?: InputMaybe<Array<StockReceiptBatchCreateWithoutReceivedByInput>>;
  createMany?: InputMaybe<StockReceiptBatchCreateManyReceivedByInputEnvelope>;
};

export type StockReceiptBatchCreateNestedManyWithoutStoreInput = {
  connect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<StockReceiptBatchCreateWithoutStoreInput>>;
  createMany?: InputMaybe<StockReceiptBatchCreateManyStoreInputEnvelope>;
};

export type StockReceiptBatchCreateNestedOneWithoutItemsInput = {
  connect?: InputMaybe<StockReceiptBatchWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StockReceiptBatchCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<StockReceiptBatchCreateWithoutItemsInput>;
};

export type StockReceiptBatchCreateNestedOneWithoutPurchaseReturnsInput = {
  connect?: InputMaybe<StockReceiptBatchWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StockReceiptBatchCreateOrConnectWithoutPurchaseReturnsInput>;
  create?: InputMaybe<StockReceiptBatchCreateWithoutPurchaseReturnsInput>;
};

export type StockReceiptBatchCreateOrConnectWithoutConfirmedByInput = {
  create: StockReceiptBatchCreateWithoutConfirmedByInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchCreateOrConnectWithoutItemsInput = {
  create: StockReceiptBatchCreateWithoutItemsInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchCreateOrConnectWithoutPurchaseOrderInput = {
  create: StockReceiptBatchCreateWithoutPurchaseOrderInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchCreateOrConnectWithoutPurchaseReturnsInput = {
  create: StockReceiptBatchCreateWithoutPurchaseReturnsInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchCreateOrConnectWithoutReceivedByInput = {
  create: StockReceiptBatchCreateWithoutReceivedByInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchCreateOrConnectWithoutStoreInput = {
  create: StockReceiptBatchCreateWithoutStoreInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchCreateWithoutConfirmedByInput = {
  PurchaseOrder?: InputMaybe<PurchaseOrderCreateNestedManyWithoutReceiptsInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutBatchInput>;
  purchaseOrderId: Scalars['String']['input'];
  purchaseReturns?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutBatchInput>;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedBy: UserCreateNestedOneWithoutStockReceiptBatchReceivedBysInput;
  store: StoreCreateNestedOneWithoutReceiptsInput;
  waybillUrl?: InputMaybe<Scalars['String']['input']>;
};

export type StockReceiptBatchCreateWithoutItemsInput = {
  PurchaseOrder?: InputMaybe<PurchaseOrderCreateNestedManyWithoutReceiptsInput>;
  confirmedBy: UserCreateNestedOneWithoutStockReceiptBatchConfirmedBysInput;
  id?: InputMaybe<Scalars['String']['input']>;
  purchaseOrderId: Scalars['String']['input'];
  purchaseReturns?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutBatchInput>;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedBy: UserCreateNestedOneWithoutStockReceiptBatchReceivedBysInput;
  store: StoreCreateNestedOneWithoutReceiptsInput;
  waybillUrl?: InputMaybe<Scalars['String']['input']>;
};

export type StockReceiptBatchCreateWithoutPurchaseOrderInput = {
  confirmedBy: UserCreateNestedOneWithoutStockReceiptBatchConfirmedBysInput;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutBatchInput>;
  purchaseOrderId: Scalars['String']['input'];
  purchaseReturns?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutBatchInput>;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedBy: UserCreateNestedOneWithoutStockReceiptBatchReceivedBysInput;
  store: StoreCreateNestedOneWithoutReceiptsInput;
  waybillUrl?: InputMaybe<Scalars['String']['input']>;
};

export type StockReceiptBatchCreateWithoutPurchaseReturnsInput = {
  PurchaseOrder?: InputMaybe<PurchaseOrderCreateNestedManyWithoutReceiptsInput>;
  confirmedBy: UserCreateNestedOneWithoutStockReceiptBatchConfirmedBysInput;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutBatchInput>;
  purchaseOrderId: Scalars['String']['input'];
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedBy: UserCreateNestedOneWithoutStockReceiptBatchReceivedBysInput;
  store: StoreCreateNestedOneWithoutReceiptsInput;
  waybillUrl?: InputMaybe<Scalars['String']['input']>;
};

export type StockReceiptBatchCreateWithoutReceivedByInput = {
  PurchaseOrder?: InputMaybe<PurchaseOrderCreateNestedManyWithoutReceiptsInput>;
  confirmedBy: UserCreateNestedOneWithoutStockReceiptBatchConfirmedBysInput;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutBatchInput>;
  purchaseOrderId: Scalars['String']['input'];
  purchaseReturns?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutBatchInput>;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  store: StoreCreateNestedOneWithoutReceiptsInput;
  waybillUrl?: InputMaybe<Scalars['String']['input']>;
};

export type StockReceiptBatchCreateWithoutStoreInput = {
  PurchaseOrder?: InputMaybe<PurchaseOrderCreateNestedManyWithoutReceiptsInput>;
  confirmedBy: UserCreateNestedOneWithoutStockReceiptBatchConfirmedBysInput;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockReceiptBatchItemCreateNestedManyWithoutBatchInput>;
  purchaseOrderId: Scalars['String']['input'];
  purchaseReturns?: InputMaybe<PurchaseReturnItemCreateNestedManyWithoutBatchInput>;
  receivedAt?: InputMaybe<Scalars['DateTime']['input']>;
  receivedBy: UserCreateNestedOneWithoutStockReceiptBatchReceivedBysInput;
  waybillUrl?: InputMaybe<Scalars['String']['input']>;
};

export type StockReceiptBatchItem = {
  __typename?: 'StockReceiptBatchItem';
  batch: StockReceiptBatch;
  id: Scalars['ID']['output'];
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  stockReceiptBatchId: Scalars['String']['output'];
};

export type StockReceiptBatchItemCreateManyBatchInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type StockReceiptBatchItemCreateManyBatchInputEnvelope = {
  data: Array<StockReceiptBatchItemCreateManyBatchInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockReceiptBatchItemCreateManyProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  stockReceiptBatchId: Scalars['String']['input'];
};

export type StockReceiptBatchItemCreateManyProductVariantInputEnvelope = {
  data: Array<StockReceiptBatchItemCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockReceiptBatchItemCreateNestedManyWithoutBatchInput = {
  connect?: InputMaybe<Array<StockReceiptBatchItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchItemCreateOrConnectWithoutBatchInput>>;
  create?: InputMaybe<Array<StockReceiptBatchItemCreateWithoutBatchInput>>;
  createMany?: InputMaybe<StockReceiptBatchItemCreateManyBatchInputEnvelope>;
};

export type StockReceiptBatchItemCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<StockReceiptBatchItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<StockReceiptBatchItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<StockReceiptBatchItemCreateManyProductVariantInputEnvelope>;
};

export type StockReceiptBatchItemCreateOrConnectWithoutBatchInput = {
  create: StockReceiptBatchItemCreateWithoutBatchInput;
  where: StockReceiptBatchItemWhereUniqueInput;
};

export type StockReceiptBatchItemCreateOrConnectWithoutProductVariantInput = {
  create: StockReceiptBatchItemCreateWithoutProductVariantInput;
  where: StockReceiptBatchItemWhereUniqueInput;
};

export type StockReceiptBatchItemCreateWithoutBatchInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutReceiptItemsInput;
  quantity: Scalars['Int']['input'];
};

export type StockReceiptBatchItemCreateWithoutProductVariantInput = {
  batch: StockReceiptBatchCreateNestedOneWithoutItemsInput;
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
};

export type StockReceiptBatchItemListRelationFilter = {
  every?: InputMaybe<StockReceiptBatchItemWhereInput>;
  none?: InputMaybe<StockReceiptBatchItemWhereInput>;
  some?: InputMaybe<StockReceiptBatchItemWhereInput>;
};

export type StockReceiptBatchItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StockReceiptBatchItemScalarWhereInput = {
  AND?: InputMaybe<Array<StockReceiptBatchItemScalarWhereInput>>;
  NOT?: InputMaybe<Array<StockReceiptBatchItemScalarWhereInput>>;
  OR?: InputMaybe<Array<StockReceiptBatchItemScalarWhereInput>>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  stockReceiptBatchId?: InputMaybe<StringFilter>;
};

export type StockReceiptBatchItemUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StockReceiptBatchItemUpdateManyWithWhereWithoutBatchInput = {
  data: StockReceiptBatchItemUpdateManyMutationInput;
  where: StockReceiptBatchItemScalarWhereInput;
};

export type StockReceiptBatchItemUpdateManyWithWhereWithoutProductVariantInput = {
  data: StockReceiptBatchItemUpdateManyMutationInput;
  where: StockReceiptBatchItemScalarWhereInput;
};

export type StockReceiptBatchItemUpdateManyWithoutBatchNestedInput = {
  connect?: InputMaybe<Array<StockReceiptBatchItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchItemCreateOrConnectWithoutBatchInput>>;
  create?: InputMaybe<Array<StockReceiptBatchItemCreateWithoutBatchInput>>;
  createMany?: InputMaybe<StockReceiptBatchItemCreateManyBatchInputEnvelope>;
  delete?: InputMaybe<Array<StockReceiptBatchItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockReceiptBatchItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockReceiptBatchItemWhereUniqueInput>>;
  set?: InputMaybe<Array<StockReceiptBatchItemWhereUniqueInput>>;
  update?: InputMaybe<Array<StockReceiptBatchItemUpdateWithWhereUniqueWithoutBatchInput>>;
  updateMany?: InputMaybe<Array<StockReceiptBatchItemUpdateManyWithWhereWithoutBatchInput>>;
  upsert?: InputMaybe<Array<StockReceiptBatchItemUpsertWithWhereUniqueWithoutBatchInput>>;
};

export type StockReceiptBatchItemUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<StockReceiptBatchItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<StockReceiptBatchItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<StockReceiptBatchItemCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<StockReceiptBatchItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockReceiptBatchItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockReceiptBatchItemWhereUniqueInput>>;
  set?: InputMaybe<Array<StockReceiptBatchItemWhereUniqueInput>>;
  update?: InputMaybe<Array<StockReceiptBatchItemUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<StockReceiptBatchItemUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<StockReceiptBatchItemUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type StockReceiptBatchItemUpdateWithWhereUniqueWithoutBatchInput = {
  data: StockReceiptBatchItemUpdateWithoutBatchInput;
  where: StockReceiptBatchItemWhereUniqueInput;
};

export type StockReceiptBatchItemUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: StockReceiptBatchItemUpdateWithoutProductVariantInput;
  where: StockReceiptBatchItemWhereUniqueInput;
};

export type StockReceiptBatchItemUpdateWithoutBatchInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutReceiptItemsNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StockReceiptBatchItemUpdateWithoutProductVariantInput = {
  batch?: InputMaybe<StockReceiptBatchUpdateOneRequiredWithoutItemsNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StockReceiptBatchItemUpsertWithWhereUniqueWithoutBatchInput = {
  create: StockReceiptBatchItemCreateWithoutBatchInput;
  update: StockReceiptBatchItemUpdateWithoutBatchInput;
  where: StockReceiptBatchItemWhereUniqueInput;
};

export type StockReceiptBatchItemUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: StockReceiptBatchItemCreateWithoutProductVariantInput;
  update: StockReceiptBatchItemUpdateWithoutProductVariantInput;
  where: StockReceiptBatchItemWhereUniqueInput;
};

export type StockReceiptBatchItemWhereInput = {
  AND?: InputMaybe<Array<StockReceiptBatchItemWhereInput>>;
  NOT?: InputMaybe<Array<StockReceiptBatchItemWhereInput>>;
  OR?: InputMaybe<Array<StockReceiptBatchItemWhereInput>>;
  batch?: InputMaybe<StockReceiptBatchScalarRelationFilter>;
  id?: InputMaybe<StringFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  stockReceiptBatchId?: InputMaybe<StringFilter>;
};

export type StockReceiptBatchItemWhereUniqueInput = {
  AND?: InputMaybe<Array<StockReceiptBatchItemWhereInput>>;
  NOT?: InputMaybe<Array<StockReceiptBatchItemWhereInput>>;
  OR?: InputMaybe<Array<StockReceiptBatchItemWhereInput>>;
  batch?: InputMaybe<StockReceiptBatchScalarRelationFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  stockReceiptBatchId?: InputMaybe<StringFilter>;
};

export type StockReceiptBatchListRelationFilter = {
  every?: InputMaybe<StockReceiptBatchWhereInput>;
  none?: InputMaybe<StockReceiptBatchWhereInput>;
  some?: InputMaybe<StockReceiptBatchWhereInput>;
};

export type StockReceiptBatchMaxAggregate = {
  __typename?: 'StockReceiptBatchMaxAggregate';
  confirmedById?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  purchaseOrderId?: Maybe<Scalars['String']['output']>;
  receivedAt?: Maybe<Scalars['DateTime']['output']>;
  receivedById?: Maybe<Scalars['String']['output']>;
  storeId?: Maybe<Scalars['String']['output']>;
  waybillUrl?: Maybe<Scalars['String']['output']>;
};

export type StockReceiptBatchMinAggregate = {
  __typename?: 'StockReceiptBatchMinAggregate';
  confirmedById?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  purchaseOrderId?: Maybe<Scalars['String']['output']>;
  receivedAt?: Maybe<Scalars['DateTime']['output']>;
  receivedById?: Maybe<Scalars['String']['output']>;
  storeId?: Maybe<Scalars['String']['output']>;
  waybillUrl?: Maybe<Scalars['String']['output']>;
};

export type StockReceiptBatchOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StockReceiptBatchScalarRelationFilter = {
  is?: InputMaybe<StockReceiptBatchWhereInput>;
  isNot?: InputMaybe<StockReceiptBatchWhereInput>;
};

export type StockReceiptBatchScalarWhereInput = {
  AND?: InputMaybe<Array<StockReceiptBatchScalarWhereInput>>;
  NOT?: InputMaybe<Array<StockReceiptBatchScalarWhereInput>>;
  OR?: InputMaybe<Array<StockReceiptBatchScalarWhereInput>>;
  confirmedById?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  purchaseOrderId?: InputMaybe<StringFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  receivedById?: InputMaybe<StringFilter>;
  storeId?: InputMaybe<StringFilter>;
  waybillUrl?: InputMaybe<StringNullableFilter>;
};

export type StockReceiptBatchUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrderId?: InputMaybe<StringFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  waybillUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StockReceiptBatchUpdateManyWithWhereWithoutConfirmedByInput = {
  data: StockReceiptBatchUpdateManyMutationInput;
  where: StockReceiptBatchScalarWhereInput;
};

export type StockReceiptBatchUpdateManyWithWhereWithoutPurchaseOrderInput = {
  data: StockReceiptBatchUpdateManyMutationInput;
  where: StockReceiptBatchScalarWhereInput;
};

export type StockReceiptBatchUpdateManyWithWhereWithoutReceivedByInput = {
  data: StockReceiptBatchUpdateManyMutationInput;
  where: StockReceiptBatchScalarWhereInput;
};

export type StockReceiptBatchUpdateManyWithWhereWithoutStoreInput = {
  data: StockReceiptBatchUpdateManyMutationInput;
  where: StockReceiptBatchScalarWhereInput;
};

export type StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput = {
  connect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchCreateOrConnectWithoutConfirmedByInput>>;
  create?: InputMaybe<Array<StockReceiptBatchCreateWithoutConfirmedByInput>>;
  createMany?: InputMaybe<StockReceiptBatchCreateManyConfirmedByInputEnvelope>;
  delete?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockReceiptBatchScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  set?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  update?: InputMaybe<Array<StockReceiptBatchUpdateWithWhereUniqueWithoutConfirmedByInput>>;
  updateMany?: InputMaybe<Array<StockReceiptBatchUpdateManyWithWhereWithoutConfirmedByInput>>;
  upsert?: InputMaybe<Array<StockReceiptBatchUpsertWithWhereUniqueWithoutConfirmedByInput>>;
};

export type StockReceiptBatchUpdateManyWithoutPurchaseOrderNestedInput = {
  connect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchCreateOrConnectWithoutPurchaseOrderInput>>;
  create?: InputMaybe<Array<StockReceiptBatchCreateWithoutPurchaseOrderInput>>;
  delete?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockReceiptBatchScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  set?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  update?: InputMaybe<Array<StockReceiptBatchUpdateWithWhereUniqueWithoutPurchaseOrderInput>>;
  updateMany?: InputMaybe<Array<StockReceiptBatchUpdateManyWithWhereWithoutPurchaseOrderInput>>;
  upsert?: InputMaybe<Array<StockReceiptBatchUpsertWithWhereUniqueWithoutPurchaseOrderInput>>;
};

export type StockReceiptBatchUpdateManyWithoutReceivedByNestedInput = {
  connect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchCreateOrConnectWithoutReceivedByInput>>;
  create?: InputMaybe<Array<StockReceiptBatchCreateWithoutReceivedByInput>>;
  createMany?: InputMaybe<StockReceiptBatchCreateManyReceivedByInputEnvelope>;
  delete?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockReceiptBatchScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  set?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  update?: InputMaybe<Array<StockReceiptBatchUpdateWithWhereUniqueWithoutReceivedByInput>>;
  updateMany?: InputMaybe<Array<StockReceiptBatchUpdateManyWithWhereWithoutReceivedByInput>>;
  upsert?: InputMaybe<Array<StockReceiptBatchUpsertWithWhereUniqueWithoutReceivedByInput>>;
};

export type StockReceiptBatchUpdateManyWithoutStoreNestedInput = {
  connect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockReceiptBatchCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<StockReceiptBatchCreateWithoutStoreInput>>;
  createMany?: InputMaybe<StockReceiptBatchCreateManyStoreInputEnvelope>;
  delete?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockReceiptBatchScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  set?: InputMaybe<Array<StockReceiptBatchWhereUniqueInput>>;
  update?: InputMaybe<Array<StockReceiptBatchUpdateWithWhereUniqueWithoutStoreInput>>;
  updateMany?: InputMaybe<Array<StockReceiptBatchUpdateManyWithWhereWithoutStoreInput>>;
  upsert?: InputMaybe<Array<StockReceiptBatchUpsertWithWhereUniqueWithoutStoreInput>>;
};

export type StockReceiptBatchUpdateOneRequiredWithoutItemsNestedInput = {
  connect?: InputMaybe<StockReceiptBatchWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StockReceiptBatchCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<StockReceiptBatchCreateWithoutItemsInput>;
  update?: InputMaybe<StockReceiptBatchUpdateToOneWithWhereWithoutItemsInput>;
  upsert?: InputMaybe<StockReceiptBatchUpsertWithoutItemsInput>;
};

export type StockReceiptBatchUpdateOneRequiredWithoutPurchaseReturnsNestedInput = {
  connect?: InputMaybe<StockReceiptBatchWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StockReceiptBatchCreateOrConnectWithoutPurchaseReturnsInput>;
  create?: InputMaybe<StockReceiptBatchCreateWithoutPurchaseReturnsInput>;
  update?: InputMaybe<StockReceiptBatchUpdateToOneWithWhereWithoutPurchaseReturnsInput>;
  upsert?: InputMaybe<StockReceiptBatchUpsertWithoutPurchaseReturnsInput>;
};

export type StockReceiptBatchUpdateToOneWithWhereWithoutItemsInput = {
  data: StockReceiptBatchUpdateWithoutItemsInput;
  where?: InputMaybe<StockReceiptBatchWhereInput>;
};

export type StockReceiptBatchUpdateToOneWithWhereWithoutPurchaseReturnsInput = {
  data: StockReceiptBatchUpdateWithoutPurchaseReturnsInput;
  where?: InputMaybe<StockReceiptBatchWhereInput>;
};

export type StockReceiptBatchUpdateWithWhereUniqueWithoutConfirmedByInput = {
  data: StockReceiptBatchUpdateWithoutConfirmedByInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
  data: StockReceiptBatchUpdateWithoutPurchaseOrderInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchUpdateWithWhereUniqueWithoutReceivedByInput = {
  data: StockReceiptBatchUpdateWithoutReceivedByInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchUpdateWithWhereUniqueWithoutStoreInput = {
  data: StockReceiptBatchUpdateWithoutStoreInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchUpdateWithoutConfirmedByInput = {
  PurchaseOrder?: InputMaybe<PurchaseOrderUpdateManyWithoutReceiptsNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutBatchNestedInput>;
  purchaseOrderId?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseReturns?: InputMaybe<PurchaseReturnItemUpdateManyWithoutBatchNestedInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockReceiptBatchReceivedBysNestedInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutReceiptsNestedInput>;
  waybillUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StockReceiptBatchUpdateWithoutItemsInput = {
  PurchaseOrder?: InputMaybe<PurchaseOrderUpdateManyWithoutReceiptsNestedInput>;
  confirmedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockReceiptBatchConfirmedBysNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrderId?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseReturns?: InputMaybe<PurchaseReturnItemUpdateManyWithoutBatchNestedInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockReceiptBatchReceivedBysNestedInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutReceiptsNestedInput>;
  waybillUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StockReceiptBatchUpdateWithoutPurchaseOrderInput = {
  confirmedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockReceiptBatchConfirmedBysNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutBatchNestedInput>;
  purchaseOrderId?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseReturns?: InputMaybe<PurchaseReturnItemUpdateManyWithoutBatchNestedInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockReceiptBatchReceivedBysNestedInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutReceiptsNestedInput>;
  waybillUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StockReceiptBatchUpdateWithoutPurchaseReturnsInput = {
  PurchaseOrder?: InputMaybe<PurchaseOrderUpdateManyWithoutReceiptsNestedInput>;
  confirmedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockReceiptBatchConfirmedBysNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutBatchNestedInput>;
  purchaseOrderId?: InputMaybe<StringFieldUpdateOperationsInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockReceiptBatchReceivedBysNestedInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutReceiptsNestedInput>;
  waybillUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StockReceiptBatchUpdateWithoutReceivedByInput = {
  PurchaseOrder?: InputMaybe<PurchaseOrderUpdateManyWithoutReceiptsNestedInput>;
  confirmedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockReceiptBatchConfirmedBysNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutBatchNestedInput>;
  purchaseOrderId?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseReturns?: InputMaybe<PurchaseReturnItemUpdateManyWithoutBatchNestedInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutReceiptsNestedInput>;
  waybillUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StockReceiptBatchUpdateWithoutStoreInput = {
  PurchaseOrder?: InputMaybe<PurchaseOrderUpdateManyWithoutReceiptsNestedInput>;
  confirmedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockReceiptBatchConfirmedBysNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<StockReceiptBatchItemUpdateManyWithoutBatchNestedInput>;
  purchaseOrderId?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseReturns?: InputMaybe<PurchaseReturnItemUpdateManyWithoutBatchNestedInput>;
  receivedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  receivedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockReceiptBatchReceivedBysNestedInput>;
  waybillUrl?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
};

export type StockReceiptBatchUpsertWithWhereUniqueWithoutConfirmedByInput = {
  create: StockReceiptBatchCreateWithoutConfirmedByInput;
  update: StockReceiptBatchUpdateWithoutConfirmedByInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
  create: StockReceiptBatchCreateWithoutPurchaseOrderInput;
  update: StockReceiptBatchUpdateWithoutPurchaseOrderInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchUpsertWithWhereUniqueWithoutReceivedByInput = {
  create: StockReceiptBatchCreateWithoutReceivedByInput;
  update: StockReceiptBatchUpdateWithoutReceivedByInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchUpsertWithWhereUniqueWithoutStoreInput = {
  create: StockReceiptBatchCreateWithoutStoreInput;
  update: StockReceiptBatchUpdateWithoutStoreInput;
  where: StockReceiptBatchWhereUniqueInput;
};

export type StockReceiptBatchUpsertWithoutItemsInput = {
  create: StockReceiptBatchCreateWithoutItemsInput;
  update: StockReceiptBatchUpdateWithoutItemsInput;
  where?: InputMaybe<StockReceiptBatchWhereInput>;
};

export type StockReceiptBatchUpsertWithoutPurchaseReturnsInput = {
  create: StockReceiptBatchCreateWithoutPurchaseReturnsInput;
  update: StockReceiptBatchUpdateWithoutPurchaseReturnsInput;
  where?: InputMaybe<StockReceiptBatchWhereInput>;
};

export type StockReceiptBatchWhereInput = {
  AND?: InputMaybe<Array<StockReceiptBatchWhereInput>>;
  NOT?: InputMaybe<Array<StockReceiptBatchWhereInput>>;
  OR?: InputMaybe<Array<StockReceiptBatchWhereInput>>;
  PurchaseOrder?: InputMaybe<PurchaseOrderListRelationFilter>;
  confirmedBy?: InputMaybe<UserScalarRelationFilter>;
  confirmedById?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  items?: InputMaybe<StockReceiptBatchItemListRelationFilter>;
  purchaseOrderId?: InputMaybe<StringFilter>;
  purchaseReturns?: InputMaybe<PurchaseReturnItemListRelationFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  receivedBy?: InputMaybe<UserScalarRelationFilter>;
  receivedById?: InputMaybe<StringFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  waybillUrl?: InputMaybe<StringNullableFilter>;
};

export type StockReceiptBatchWhereUniqueInput = {
  AND?: InputMaybe<Array<StockReceiptBatchWhereInput>>;
  NOT?: InputMaybe<Array<StockReceiptBatchWhereInput>>;
  OR?: InputMaybe<Array<StockReceiptBatchWhereInput>>;
  PurchaseOrder?: InputMaybe<PurchaseOrderListRelationFilter>;
  confirmedBy?: InputMaybe<UserScalarRelationFilter>;
  confirmedById?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockReceiptBatchItemListRelationFilter>;
  purchaseOrderId?: InputMaybe<StringFilter>;
  purchaseReturns?: InputMaybe<PurchaseReturnItemListRelationFilter>;
  receivedAt?: InputMaybe<DateTimeFilter>;
  receivedBy?: InputMaybe<UserScalarRelationFilter>;
  receivedById?: InputMaybe<StringFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  waybillUrl?: InputMaybe<StringNullableFilter>;
};

export type StockScalarWhereInput = {
  AND?: InputMaybe<Array<StockScalarWhereInput>>;
  NOT?: InputMaybe<Array<StockScalarWhereInput>>;
  OR?: InputMaybe<Array<StockScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  reorderPoint?: InputMaybe<IntNullableFilter>;
  reorderQty?: InputMaybe<IntNullableFilter>;
  reserved?: InputMaybe<IntFilter>;
  storeId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type StockStoreIdProductVariantIdCompoundUniqueInput = {
  productVariantId: Scalars['String']['input'];
  storeId: Scalars['String']['input'];
};

export type StockSumAggregate = {
  __typename?: 'StockSumAggregate';
  quantity?: Maybe<Scalars['Int']['output']>;
  reorderPoint?: Maybe<Scalars['Int']['output']>;
  reorderQty?: Maybe<Scalars['Int']['output']>;
  reserved?: Maybe<Scalars['Int']['output']>;
};

export type StockTransfer = {
  __typename?: 'StockTransfer';
  _count: StockTransferCount;
  approvedBy: User;
  approvedById: Scalars['String']['output'];
  createdAt: Scalars['DateTime']['output'];
  fromStore: Store;
  fromStoreId: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  items?: Maybe<Array<StockTransferItem>>;
  requestedBy: User;
  requestedById: Scalars['String']['output'];
  status: TransferStatus;
  toStore: Store;
  toStoreId: Scalars['String']['output'];
};

export type StockTransferCount = {
  __typename?: 'StockTransferCount';
  items: Scalars['Int']['output'];
};

export type StockTransferCountAggregate = {
  __typename?: 'StockTransferCountAggregate';
  _all: Scalars['Int']['output'];
  approvedById: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  fromStoreId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  requestedById: Scalars['Int']['output'];
  status: Scalars['Int']['output'];
  toStoreId: Scalars['Int']['output'];
};

export type StockTransferCreateManyApprovedByInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fromStoreId: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  requestedById: Scalars['String']['input'];
  status: TransferStatus;
  toStoreId: Scalars['String']['input'];
};

export type StockTransferCreateManyApprovedByInputEnvelope = {
  data: Array<StockTransferCreateManyApprovedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockTransferCreateManyFromStoreInput = {
  approvedById: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  requestedById: Scalars['String']['input'];
  status: TransferStatus;
  toStoreId: Scalars['String']['input'];
};

export type StockTransferCreateManyFromStoreInputEnvelope = {
  data: Array<StockTransferCreateManyFromStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockTransferCreateManyRequestedByInput = {
  approvedById: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fromStoreId: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  status: TransferStatus;
  toStoreId: Scalars['String']['input'];
};

export type StockTransferCreateManyRequestedByInputEnvelope = {
  data: Array<StockTransferCreateManyRequestedByInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockTransferCreateManyToStoreInput = {
  approvedById: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fromStoreId: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  requestedById: Scalars['String']['input'];
  status: TransferStatus;
};

export type StockTransferCreateManyToStoreInputEnvelope = {
  data: Array<StockTransferCreateManyToStoreInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockTransferCreateNestedManyWithoutApprovedByInput = {
  connect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferCreateOrConnectWithoutApprovedByInput>>;
  create?: InputMaybe<Array<StockTransferCreateWithoutApprovedByInput>>;
  createMany?: InputMaybe<StockTransferCreateManyApprovedByInputEnvelope>;
};

export type StockTransferCreateNestedManyWithoutFromStoreInput = {
  connect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferCreateOrConnectWithoutFromStoreInput>>;
  create?: InputMaybe<Array<StockTransferCreateWithoutFromStoreInput>>;
  createMany?: InputMaybe<StockTransferCreateManyFromStoreInputEnvelope>;
};

export type StockTransferCreateNestedManyWithoutRequestedByInput = {
  connect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferCreateOrConnectWithoutRequestedByInput>>;
  create?: InputMaybe<Array<StockTransferCreateWithoutRequestedByInput>>;
  createMany?: InputMaybe<StockTransferCreateManyRequestedByInputEnvelope>;
};

export type StockTransferCreateNestedManyWithoutToStoreInput = {
  connect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferCreateOrConnectWithoutToStoreInput>>;
  create?: InputMaybe<Array<StockTransferCreateWithoutToStoreInput>>;
  createMany?: InputMaybe<StockTransferCreateManyToStoreInputEnvelope>;
};

export type StockTransferCreateNestedOneWithoutItemsInput = {
  connect?: InputMaybe<StockTransferWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StockTransferCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<StockTransferCreateWithoutItemsInput>;
};

export type StockTransferCreateOrConnectWithoutApprovedByInput = {
  create: StockTransferCreateWithoutApprovedByInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferCreateOrConnectWithoutFromStoreInput = {
  create: StockTransferCreateWithoutFromStoreInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferCreateOrConnectWithoutItemsInput = {
  create: StockTransferCreateWithoutItemsInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferCreateOrConnectWithoutRequestedByInput = {
  create: StockTransferCreateWithoutRequestedByInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferCreateOrConnectWithoutToStoreInput = {
  create: StockTransferCreateWithoutToStoreInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferCreateWithoutApprovedByInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fromStore: StoreCreateNestedOneWithoutTransfersOutInput;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockTransferItemCreateNestedManyWithoutTransferInput>;
  requestedBy: UserCreateNestedOneWithoutStockTransferRequestsInput;
  status: TransferStatus;
  toStore: StoreCreateNestedOneWithoutTransfersInInput;
};

export type StockTransferCreateWithoutFromStoreInput = {
  approvedBy: UserCreateNestedOneWithoutStockTransferApprovalsInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockTransferItemCreateNestedManyWithoutTransferInput>;
  requestedBy: UserCreateNestedOneWithoutStockTransferRequestsInput;
  status: TransferStatus;
  toStore: StoreCreateNestedOneWithoutTransfersInInput;
};

export type StockTransferCreateWithoutItemsInput = {
  approvedBy: UserCreateNestedOneWithoutStockTransferApprovalsInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fromStore: StoreCreateNestedOneWithoutTransfersOutInput;
  id?: InputMaybe<Scalars['String']['input']>;
  requestedBy: UserCreateNestedOneWithoutStockTransferRequestsInput;
  status: TransferStatus;
  toStore: StoreCreateNestedOneWithoutTransfersInInput;
};

export type StockTransferCreateWithoutRequestedByInput = {
  approvedBy: UserCreateNestedOneWithoutStockTransferApprovalsInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fromStore: StoreCreateNestedOneWithoutTransfersOutInput;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockTransferItemCreateNestedManyWithoutTransferInput>;
  status: TransferStatus;
  toStore: StoreCreateNestedOneWithoutTransfersInInput;
};

export type StockTransferCreateWithoutToStoreInput = {
  approvedBy: UserCreateNestedOneWithoutStockTransferApprovalsInput;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  fromStore: StoreCreateNestedOneWithoutTransfersOutInput;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockTransferItemCreateNestedManyWithoutTransferInput>;
  requestedBy: UserCreateNestedOneWithoutStockTransferRequestsInput;
  status: TransferStatus;
};

export type StockTransferItem = {
  __typename?: 'StockTransferItem';
  id: Scalars['ID']['output'];
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
  stockTransferId: Scalars['String']['output'];
  transfer: StockTransfer;
};

export type StockTransferItemCreateManyProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  stockTransferId: Scalars['String']['input'];
};

export type StockTransferItemCreateManyProductVariantInputEnvelope = {
  data: Array<StockTransferItemCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockTransferItemCreateManyTransferInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  quantity: Scalars['Int']['input'];
};

export type StockTransferItemCreateManyTransferInputEnvelope = {
  data: Array<StockTransferItemCreateManyTransferInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StockTransferItemCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<StockTransferItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<StockTransferItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<StockTransferItemCreateManyProductVariantInputEnvelope>;
};

export type StockTransferItemCreateNestedManyWithoutTransferInput = {
  connect?: InputMaybe<Array<StockTransferItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferItemCreateOrConnectWithoutTransferInput>>;
  create?: InputMaybe<Array<StockTransferItemCreateWithoutTransferInput>>;
  createMany?: InputMaybe<StockTransferItemCreateManyTransferInputEnvelope>;
};

export type StockTransferItemCreateOrConnectWithoutProductVariantInput = {
  create: StockTransferItemCreateWithoutProductVariantInput;
  where: StockTransferItemWhereUniqueInput;
};

export type StockTransferItemCreateOrConnectWithoutTransferInput = {
  create: StockTransferItemCreateWithoutTransferInput;
  where: StockTransferItemWhereUniqueInput;
};

export type StockTransferItemCreateWithoutProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  transfer: StockTransferCreateNestedOneWithoutItemsInput;
};

export type StockTransferItemCreateWithoutTransferInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutTransferItemsInput;
  quantity: Scalars['Int']['input'];
};

export type StockTransferItemListRelationFilter = {
  every?: InputMaybe<StockTransferItemWhereInput>;
  none?: InputMaybe<StockTransferItemWhereInput>;
  some?: InputMaybe<StockTransferItemWhereInput>;
};

export type StockTransferItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StockTransferItemScalarWhereInput = {
  AND?: InputMaybe<Array<StockTransferItemScalarWhereInput>>;
  NOT?: InputMaybe<Array<StockTransferItemScalarWhereInput>>;
  OR?: InputMaybe<Array<StockTransferItemScalarWhereInput>>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  stockTransferId?: InputMaybe<StringFilter>;
};

export type StockTransferItemUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StockTransferItemUpdateManyWithWhereWithoutProductVariantInput = {
  data: StockTransferItemUpdateManyMutationInput;
  where: StockTransferItemScalarWhereInput;
};

export type StockTransferItemUpdateManyWithWhereWithoutTransferInput = {
  data: StockTransferItemUpdateManyMutationInput;
  where: StockTransferItemScalarWhereInput;
};

export type StockTransferItemUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<StockTransferItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<StockTransferItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<StockTransferItemCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<StockTransferItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockTransferItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockTransferItemWhereUniqueInput>>;
  set?: InputMaybe<Array<StockTransferItemWhereUniqueInput>>;
  update?: InputMaybe<Array<StockTransferItemUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<StockTransferItemUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<StockTransferItemUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type StockTransferItemUpdateManyWithoutTransferNestedInput = {
  connect?: InputMaybe<Array<StockTransferItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferItemCreateOrConnectWithoutTransferInput>>;
  create?: InputMaybe<Array<StockTransferItemCreateWithoutTransferInput>>;
  createMany?: InputMaybe<StockTransferItemCreateManyTransferInputEnvelope>;
  delete?: InputMaybe<Array<StockTransferItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockTransferItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockTransferItemWhereUniqueInput>>;
  set?: InputMaybe<Array<StockTransferItemWhereUniqueInput>>;
  update?: InputMaybe<Array<StockTransferItemUpdateWithWhereUniqueWithoutTransferInput>>;
  updateMany?: InputMaybe<Array<StockTransferItemUpdateManyWithWhereWithoutTransferInput>>;
  upsert?: InputMaybe<Array<StockTransferItemUpsertWithWhereUniqueWithoutTransferInput>>;
};

export type StockTransferItemUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: StockTransferItemUpdateWithoutProductVariantInput;
  where: StockTransferItemWhereUniqueInput;
};

export type StockTransferItemUpdateWithWhereUniqueWithoutTransferInput = {
  data: StockTransferItemUpdateWithoutTransferInput;
  where: StockTransferItemWhereUniqueInput;
};

export type StockTransferItemUpdateWithoutProductVariantInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  transfer?: InputMaybe<StockTransferUpdateOneRequiredWithoutItemsNestedInput>;
};

export type StockTransferItemUpdateWithoutTransferInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutTransferItemsNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
};

export type StockTransferItemUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: StockTransferItemCreateWithoutProductVariantInput;
  update: StockTransferItemUpdateWithoutProductVariantInput;
  where: StockTransferItemWhereUniqueInput;
};

export type StockTransferItemUpsertWithWhereUniqueWithoutTransferInput = {
  create: StockTransferItemCreateWithoutTransferInput;
  update: StockTransferItemUpdateWithoutTransferInput;
  where: StockTransferItemWhereUniqueInput;
};

export type StockTransferItemWhereInput = {
  AND?: InputMaybe<Array<StockTransferItemWhereInput>>;
  NOT?: InputMaybe<Array<StockTransferItemWhereInput>>;
  OR?: InputMaybe<Array<StockTransferItemWhereInput>>;
  id?: InputMaybe<StringFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  stockTransferId?: InputMaybe<StringFilter>;
  transfer?: InputMaybe<StockTransferScalarRelationFilter>;
};

export type StockTransferItemWhereUniqueInput = {
  AND?: InputMaybe<Array<StockTransferItemWhereInput>>;
  NOT?: InputMaybe<Array<StockTransferItemWhereInput>>;
  OR?: InputMaybe<Array<StockTransferItemWhereInput>>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  stockTransferId?: InputMaybe<StringFilter>;
  transfer?: InputMaybe<StockTransferScalarRelationFilter>;
};

export type StockTransferListRelationFilter = {
  every?: InputMaybe<StockTransferWhereInput>;
  none?: InputMaybe<StockTransferWhereInput>;
  some?: InputMaybe<StockTransferWhereInput>;
};

export type StockTransferMaxAggregate = {
  __typename?: 'StockTransferMaxAggregate';
  approvedById?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  fromStoreId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  requestedById?: Maybe<Scalars['String']['output']>;
  status?: Maybe<TransferStatus>;
  toStoreId?: Maybe<Scalars['String']['output']>;
};

export type StockTransferMinAggregate = {
  __typename?: 'StockTransferMinAggregate';
  approvedById?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  fromStoreId?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  requestedById?: Maybe<Scalars['String']['output']>;
  status?: Maybe<TransferStatus>;
  toStoreId?: Maybe<Scalars['String']['output']>;
};

export type StockTransferOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StockTransferScalarRelationFilter = {
  is?: InputMaybe<StockTransferWhereInput>;
  isNot?: InputMaybe<StockTransferWhereInput>;
};

export type StockTransferScalarWhereInput = {
  AND?: InputMaybe<Array<StockTransferScalarWhereInput>>;
  NOT?: InputMaybe<Array<StockTransferScalarWhereInput>>;
  OR?: InputMaybe<Array<StockTransferScalarWhereInput>>;
  approvedById?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  fromStoreId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  requestedById?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumTransferStatusFilter>;
  toStoreId?: InputMaybe<StringFilter>;
};

export type StockTransferUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumTransferStatusFieldUpdateOperationsInput>;
};

export type StockTransferUpdateManyWithWhereWithoutApprovedByInput = {
  data: StockTransferUpdateManyMutationInput;
  where: StockTransferScalarWhereInput;
};

export type StockTransferUpdateManyWithWhereWithoutFromStoreInput = {
  data: StockTransferUpdateManyMutationInput;
  where: StockTransferScalarWhereInput;
};

export type StockTransferUpdateManyWithWhereWithoutRequestedByInput = {
  data: StockTransferUpdateManyMutationInput;
  where: StockTransferScalarWhereInput;
};

export type StockTransferUpdateManyWithWhereWithoutToStoreInput = {
  data: StockTransferUpdateManyMutationInput;
  where: StockTransferScalarWhereInput;
};

export type StockTransferUpdateManyWithoutApprovedByNestedInput = {
  connect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferCreateOrConnectWithoutApprovedByInput>>;
  create?: InputMaybe<Array<StockTransferCreateWithoutApprovedByInput>>;
  createMany?: InputMaybe<StockTransferCreateManyApprovedByInputEnvelope>;
  delete?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockTransferScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  set?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  update?: InputMaybe<Array<StockTransferUpdateWithWhereUniqueWithoutApprovedByInput>>;
  updateMany?: InputMaybe<Array<StockTransferUpdateManyWithWhereWithoutApprovedByInput>>;
  upsert?: InputMaybe<Array<StockTransferUpsertWithWhereUniqueWithoutApprovedByInput>>;
};

export type StockTransferUpdateManyWithoutFromStoreNestedInput = {
  connect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferCreateOrConnectWithoutFromStoreInput>>;
  create?: InputMaybe<Array<StockTransferCreateWithoutFromStoreInput>>;
  createMany?: InputMaybe<StockTransferCreateManyFromStoreInputEnvelope>;
  delete?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockTransferScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  set?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  update?: InputMaybe<Array<StockTransferUpdateWithWhereUniqueWithoutFromStoreInput>>;
  updateMany?: InputMaybe<Array<StockTransferUpdateManyWithWhereWithoutFromStoreInput>>;
  upsert?: InputMaybe<Array<StockTransferUpsertWithWhereUniqueWithoutFromStoreInput>>;
};

export type StockTransferUpdateManyWithoutRequestedByNestedInput = {
  connect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferCreateOrConnectWithoutRequestedByInput>>;
  create?: InputMaybe<Array<StockTransferCreateWithoutRequestedByInput>>;
  createMany?: InputMaybe<StockTransferCreateManyRequestedByInputEnvelope>;
  delete?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockTransferScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  set?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  update?: InputMaybe<Array<StockTransferUpdateWithWhereUniqueWithoutRequestedByInput>>;
  updateMany?: InputMaybe<Array<StockTransferUpdateManyWithWhereWithoutRequestedByInput>>;
  upsert?: InputMaybe<Array<StockTransferUpsertWithWhereUniqueWithoutRequestedByInput>>;
};

export type StockTransferUpdateManyWithoutToStoreNestedInput = {
  connect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockTransferCreateOrConnectWithoutToStoreInput>>;
  create?: InputMaybe<Array<StockTransferCreateWithoutToStoreInput>>;
  createMany?: InputMaybe<StockTransferCreateManyToStoreInputEnvelope>;
  delete?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockTransferScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  set?: InputMaybe<Array<StockTransferWhereUniqueInput>>;
  update?: InputMaybe<Array<StockTransferUpdateWithWhereUniqueWithoutToStoreInput>>;
  updateMany?: InputMaybe<Array<StockTransferUpdateManyWithWhereWithoutToStoreInput>>;
  upsert?: InputMaybe<Array<StockTransferUpsertWithWhereUniqueWithoutToStoreInput>>;
};

export type StockTransferUpdateOneRequiredWithoutItemsNestedInput = {
  connect?: InputMaybe<StockTransferWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StockTransferCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<StockTransferCreateWithoutItemsInput>;
  update?: InputMaybe<StockTransferUpdateToOneWithWhereWithoutItemsInput>;
  upsert?: InputMaybe<StockTransferUpsertWithoutItemsInput>;
};

export type StockTransferUpdateToOneWithWhereWithoutItemsInput = {
  data: StockTransferUpdateWithoutItemsInput;
  where?: InputMaybe<StockTransferWhereInput>;
};

export type StockTransferUpdateWithWhereUniqueWithoutApprovedByInput = {
  data: StockTransferUpdateWithoutApprovedByInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferUpdateWithWhereUniqueWithoutFromStoreInput = {
  data: StockTransferUpdateWithoutFromStoreInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferUpdateWithWhereUniqueWithoutRequestedByInput = {
  data: StockTransferUpdateWithoutRequestedByInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferUpdateWithWhereUniqueWithoutToStoreInput = {
  data: StockTransferUpdateWithoutToStoreInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferUpdateWithoutApprovedByInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fromStore?: InputMaybe<StoreUpdateOneRequiredWithoutTransfersOutNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<StockTransferItemUpdateManyWithoutTransferNestedInput>;
  requestedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockTransferRequestsNestedInput>;
  status?: InputMaybe<EnumTransferStatusFieldUpdateOperationsInput>;
  toStore?: InputMaybe<StoreUpdateOneRequiredWithoutTransfersInNestedInput>;
};

export type StockTransferUpdateWithoutFromStoreInput = {
  approvedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockTransferApprovalsNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<StockTransferItemUpdateManyWithoutTransferNestedInput>;
  requestedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockTransferRequestsNestedInput>;
  status?: InputMaybe<EnumTransferStatusFieldUpdateOperationsInput>;
  toStore?: InputMaybe<StoreUpdateOneRequiredWithoutTransfersInNestedInput>;
};

export type StockTransferUpdateWithoutItemsInput = {
  approvedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockTransferApprovalsNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fromStore?: InputMaybe<StoreUpdateOneRequiredWithoutTransfersOutNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  requestedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockTransferRequestsNestedInput>;
  status?: InputMaybe<EnumTransferStatusFieldUpdateOperationsInput>;
  toStore?: InputMaybe<StoreUpdateOneRequiredWithoutTransfersInNestedInput>;
};

export type StockTransferUpdateWithoutRequestedByInput = {
  approvedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockTransferApprovalsNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fromStore?: InputMaybe<StoreUpdateOneRequiredWithoutTransfersOutNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<StockTransferItemUpdateManyWithoutTransferNestedInput>;
  status?: InputMaybe<EnumTransferStatusFieldUpdateOperationsInput>;
  toStore?: InputMaybe<StoreUpdateOneRequiredWithoutTransfersInNestedInput>;
};

export type StockTransferUpdateWithoutToStoreInput = {
  approvedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockTransferApprovalsNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  fromStore?: InputMaybe<StoreUpdateOneRequiredWithoutTransfersOutNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<StockTransferItemUpdateManyWithoutTransferNestedInput>;
  requestedBy?: InputMaybe<UserUpdateOneRequiredWithoutStockTransferRequestsNestedInput>;
  status?: InputMaybe<EnumTransferStatusFieldUpdateOperationsInput>;
};

export type StockTransferUpsertWithWhereUniqueWithoutApprovedByInput = {
  create: StockTransferCreateWithoutApprovedByInput;
  update: StockTransferUpdateWithoutApprovedByInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferUpsertWithWhereUniqueWithoutFromStoreInput = {
  create: StockTransferCreateWithoutFromStoreInput;
  update: StockTransferUpdateWithoutFromStoreInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferUpsertWithWhereUniqueWithoutRequestedByInput = {
  create: StockTransferCreateWithoutRequestedByInput;
  update: StockTransferUpdateWithoutRequestedByInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferUpsertWithWhereUniqueWithoutToStoreInput = {
  create: StockTransferCreateWithoutToStoreInput;
  update: StockTransferUpdateWithoutToStoreInput;
  where: StockTransferWhereUniqueInput;
};

export type StockTransferUpsertWithoutItemsInput = {
  create: StockTransferCreateWithoutItemsInput;
  update: StockTransferUpdateWithoutItemsInput;
  where?: InputMaybe<StockTransferWhereInput>;
};

export type StockTransferWhereInput = {
  AND?: InputMaybe<Array<StockTransferWhereInput>>;
  NOT?: InputMaybe<Array<StockTransferWhereInput>>;
  OR?: InputMaybe<Array<StockTransferWhereInput>>;
  approvedBy?: InputMaybe<UserScalarRelationFilter>;
  approvedById?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  fromStore?: InputMaybe<StoreScalarRelationFilter>;
  fromStoreId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  items?: InputMaybe<StockTransferItemListRelationFilter>;
  requestedBy?: InputMaybe<UserScalarRelationFilter>;
  requestedById?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumTransferStatusFilter>;
  toStore?: InputMaybe<StoreScalarRelationFilter>;
  toStoreId?: InputMaybe<StringFilter>;
};

export type StockTransferWhereUniqueInput = {
  AND?: InputMaybe<Array<StockTransferWhereInput>>;
  NOT?: InputMaybe<Array<StockTransferWhereInput>>;
  OR?: InputMaybe<Array<StockTransferWhereInput>>;
  approvedBy?: InputMaybe<UserScalarRelationFilter>;
  approvedById?: InputMaybe<StringFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  fromStore?: InputMaybe<StoreScalarRelationFilter>;
  fromStoreId?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<StockTransferItemListRelationFilter>;
  requestedBy?: InputMaybe<UserScalarRelationFilter>;
  requestedById?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumTransferStatusFilter>;
  toStore?: InputMaybe<StoreScalarRelationFilter>;
  toStoreId?: InputMaybe<StringFilter>;
};

export type StockUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  reorderPoint?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  reorderQty?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  reserved?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StockUpdateManyWithWhereWithoutProductVariantInput = {
  data: StockUpdateManyMutationInput;
  where: StockScalarWhereInput;
};

export type StockUpdateManyWithWhereWithoutStoreInput = {
  data: StockUpdateManyMutationInput;
  where: StockScalarWhereInput;
};

export type StockUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<StockWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<StockCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<StockCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<StockWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockWhereUniqueInput>>;
  set?: InputMaybe<Array<StockWhereUniqueInput>>;
  update?: InputMaybe<Array<StockUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<StockUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<StockUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type StockUpdateManyWithoutStoreNestedInput = {
  connect?: InputMaybe<Array<StockWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StockCreateOrConnectWithoutStoreInput>>;
  create?: InputMaybe<Array<StockCreateWithoutStoreInput>>;
  createMany?: InputMaybe<StockCreateManyStoreInputEnvelope>;
  delete?: InputMaybe<Array<StockWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StockScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StockWhereUniqueInput>>;
  set?: InputMaybe<Array<StockWhereUniqueInput>>;
  update?: InputMaybe<Array<StockUpdateWithWhereUniqueWithoutStoreInput>>;
  updateMany?: InputMaybe<Array<StockUpdateManyWithWhereWithoutStoreInput>>;
  upsert?: InputMaybe<Array<StockUpsertWithWhereUniqueWithoutStoreInput>>;
};

export type StockUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: StockUpdateWithoutProductVariantInput;
  where: StockWhereUniqueInput;
};

export type StockUpdateWithWhereUniqueWithoutStoreInput = {
  data: StockUpdateWithoutStoreInput;
  where: StockWhereUniqueInput;
};

export type StockUpdateWithoutProductVariantInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  reorderPoint?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  reorderQty?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  reserved?: InputMaybe<IntFieldUpdateOperationsInput>;
  store?: InputMaybe<StoreUpdateOneRequiredWithoutStocksNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StockUpdateWithoutStoreInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutStockItemsNestedInput>;
  quantity?: InputMaybe<IntFieldUpdateOperationsInput>;
  reorderPoint?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  reorderQty?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  reserved?: InputMaybe<IntFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StockUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: StockCreateWithoutProductVariantInput;
  update: StockUpdateWithoutProductVariantInput;
  where: StockWhereUniqueInput;
};

export type StockUpsertWithWhereUniqueWithoutStoreInput = {
  create: StockCreateWithoutStoreInput;
  update: StockUpdateWithoutStoreInput;
  where: StockWhereUniqueInput;
};

export type StockWhereInput = {
  AND?: InputMaybe<Array<StockWhereInput>>;
  NOT?: InputMaybe<Array<StockWhereInput>>;
  OR?: InputMaybe<Array<StockWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  reorderPoint?: InputMaybe<IntNullableFilter>;
  reorderQty?: InputMaybe<IntNullableFilter>;
  reserved?: InputMaybe<IntFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type StockWhereUniqueInput = {
  AND?: InputMaybe<Array<StockWhereInput>>;
  NOT?: InputMaybe<Array<StockWhereInput>>;
  OR?: InputMaybe<Array<StockWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quantity?: InputMaybe<IntFilter>;
  reorderPoint?: InputMaybe<IntNullableFilter>;
  reorderQty?: InputMaybe<IntNullableFilter>;
  reserved?: InputMaybe<IntFilter>;
  store?: InputMaybe<StoreScalarRelationFilter>;
  storeId?: InputMaybe<StringFilter>;
  storeId_productVariantId?: InputMaybe<StockStoreIdProductVariantIdCompoundUniqueInput>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type Store = {
  __typename?: 'Store';
  Customer?: Maybe<Array<Customer>>;
  CustomerProfile?: Maybe<Array<CustomerProfile>>;
  InvoiceImport?: Maybe<Array<InvoiceImport>>;
  PurchaseRequisition?: Maybe<Array<PurchaseRequisition>>;
  Quotation?: Maybe<Array<Quotation>>;
  _count: StoreCount;
  createdAt: Scalars['DateTime']['output'];
  customerSales?: Maybe<Array<ConsumerSale>>;
  id: Scalars['ID']['output'];
  isMain: Scalars['Boolean']['output'];
  legacyMappings?: Maybe<Array<LegacyStoreMapping>>;
  location?: Maybe<Scalars['String']['output']>;
  manager: User;
  managerId: Scalars['String']['output'];
  movements?: Maybe<Array<StockMovement>>;
  name: Scalars['String']['output'];
  purchaseOrders?: Maybe<Array<PurchaseOrder>>;
  receipts?: Maybe<Array<StockReceiptBatch>>;
  resellerSales?: Maybe<Array<ResellerSale>>;
  salesReturns?: Maybe<Array<SalesReturn>>;
  stocks?: Maybe<Array<Stock>>;
  transfersIn?: Maybe<Array<StockTransfer>>;
  transfersOut?: Maybe<Array<StockTransfer>>;
  updatedAt: Scalars['DateTime']['output'];
};

export type StoreCount = {
  __typename?: 'StoreCount';
  Customer: Scalars['Int']['output'];
  CustomerProfile: Scalars['Int']['output'];
  InvoiceImport: Scalars['Int']['output'];
  PurchaseRequisition: Scalars['Int']['output'];
  Quotation: Scalars['Int']['output'];
  customerSales: Scalars['Int']['output'];
  legacyMappings: Scalars['Int']['output'];
  movements: Scalars['Int']['output'];
  purchaseOrders: Scalars['Int']['output'];
  receipts: Scalars['Int']['output'];
  resellerSales: Scalars['Int']['output'];
  salesReturns: Scalars['Int']['output'];
  stocks: Scalars['Int']['output'];
  transfersIn: Scalars['Int']['output'];
  transfersOut: Scalars['Int']['output'];
};

export type StoreCountAggregate = {
  __typename?: 'StoreCountAggregate';
  _all: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isMain: Scalars['Int']['output'];
  location: Scalars['Int']['output'];
  managerId: Scalars['Int']['output'];
  name: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
};

export type StoreCountAggregateInput = {
  _all?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  location?: InputMaybe<Scalars['Boolean']['input']>;
  managerId?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StoreCountOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isMain?: InputMaybe<SortOrder>;
  location?: InputMaybe<SortOrder>;
  managerId?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StoreCreateInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateManyInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  location?: InputMaybe<Scalars['String']['input']>;
  managerId: Scalars['String']['input'];
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateManyManagerInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  location?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateManyManagerInputEnvelope = {
  data: Array<StoreCreateManyManagerInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StoreCreateNestedManyWithoutManagerInput = {
  connect?: InputMaybe<Array<StoreWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StoreCreateOrConnectWithoutManagerInput>>;
  create?: InputMaybe<Array<StoreCreateWithoutManagerInput>>;
  createMany?: InputMaybe<StoreCreateManyManagerInputEnvelope>;
};

export type StoreCreateNestedOneWithoutCustomerInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutCustomerInput>;
  create?: InputMaybe<StoreCreateWithoutCustomerInput>;
};

export type StoreCreateNestedOneWithoutCustomerProfileInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutCustomerProfileInput>;
  create?: InputMaybe<StoreCreateWithoutCustomerProfileInput>;
};

export type StoreCreateNestedOneWithoutCustomerSalesInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutCustomerSalesInput>;
  create?: InputMaybe<StoreCreateWithoutCustomerSalesInput>;
};

export type StoreCreateNestedOneWithoutMovementsInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutMovementsInput>;
  create?: InputMaybe<StoreCreateWithoutMovementsInput>;
};

export type StoreCreateNestedOneWithoutPurchaseOrdersInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutPurchaseOrdersInput>;
  create?: InputMaybe<StoreCreateWithoutPurchaseOrdersInput>;
};

export type StoreCreateNestedOneWithoutPurchaseRequisitionInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutPurchaseRequisitionInput>;
  create?: InputMaybe<StoreCreateWithoutPurchaseRequisitionInput>;
};

export type StoreCreateNestedOneWithoutQuotationInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutQuotationInput>;
  create?: InputMaybe<StoreCreateWithoutQuotationInput>;
};

export type StoreCreateNestedOneWithoutReceiptsInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutReceiptsInput>;
  create?: InputMaybe<StoreCreateWithoutReceiptsInput>;
};

export type StoreCreateNestedOneWithoutResellerSalesInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutResellerSalesInput>;
  create?: InputMaybe<StoreCreateWithoutResellerSalesInput>;
};

export type StoreCreateNestedOneWithoutSalesReturnsInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutSalesReturnsInput>;
  create?: InputMaybe<StoreCreateWithoutSalesReturnsInput>;
};

export type StoreCreateNestedOneWithoutStocksInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutStocksInput>;
  create?: InputMaybe<StoreCreateWithoutStocksInput>;
};

export type StoreCreateNestedOneWithoutTransfersInInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutTransfersInInput>;
  create?: InputMaybe<StoreCreateWithoutTransfersInInput>;
};

export type StoreCreateNestedOneWithoutTransfersOutInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutTransfersOutInput>;
  create?: InputMaybe<StoreCreateWithoutTransfersOutInput>;
};

export type StoreCreateOrConnectWithoutCustomerInput = {
  create: StoreCreateWithoutCustomerInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutCustomerProfileInput = {
  create: StoreCreateWithoutCustomerProfileInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutCustomerSalesInput = {
  create: StoreCreateWithoutCustomerSalesInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutManagerInput = {
  create: StoreCreateWithoutManagerInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutMovementsInput = {
  create: StoreCreateWithoutMovementsInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutPurchaseOrdersInput = {
  create: StoreCreateWithoutPurchaseOrdersInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutPurchaseRequisitionInput = {
  create: StoreCreateWithoutPurchaseRequisitionInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutQuotationInput = {
  create: StoreCreateWithoutQuotationInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutReceiptsInput = {
  create: StoreCreateWithoutReceiptsInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutResellerSalesInput = {
  create: StoreCreateWithoutResellerSalesInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutSalesReturnsInput = {
  create: StoreCreateWithoutSalesReturnsInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutStocksInput = {
  create: StoreCreateWithoutStocksInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutTransfersInInput = {
  create: StoreCreateWithoutTransfersInInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateOrConnectWithoutTransfersOutInput = {
  create: StoreCreateWithoutTransfersOutInput;
  where: StoreWhereUniqueInput;
};

export type StoreCreateWithoutCustomerInput = {
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutCustomerProfileInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutCustomerSalesInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutManagerInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutMovementsInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutPurchaseOrdersInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutPurchaseRequisitionInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutQuotationInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutReceiptsInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutResellerSalesInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutSalesReturnsInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutStocksInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutTransfersInInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersOut?: InputMaybe<StockTransferCreateNestedManyWithoutFromStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreCreateWithoutTransfersOutInput = {
  Customer?: InputMaybe<CustomerCreateNestedManyWithoutPreferredStoreInput>;
  CustomerProfile?: InputMaybe<CustomerProfileCreateNestedManyWithoutPreferredStoreInput>;
  InvoiceImport?: InputMaybe<InvoiceImportCreateNestedManyWithoutStoreInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutStoreInput>;
  Quotation?: InputMaybe<QuotationCreateNestedManyWithoutStoreInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerSales?: InputMaybe<ConsumerSaleCreateNestedManyWithoutStoreInput>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  legacyMappings?: InputMaybe<LegacyStoreMappingCreateNestedManyWithoutStoreInput>;
  location?: InputMaybe<Scalars['String']['input']>;
  manager: UserCreateNestedOneWithoutStoreInput;
  movements?: InputMaybe<StockMovementCreateNestedManyWithoutStoreInput>;
  name: Scalars['String']['input'];
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutStoreInput>;
  receipts?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutStoreInput>;
  resellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutStoreInput>;
  salesReturns?: InputMaybe<SalesReturnCreateNestedManyWithoutStoreInput>;
  stocks?: InputMaybe<StockCreateNestedManyWithoutStoreInput>;
  transfersIn?: InputMaybe<StockTransferCreateNestedManyWithoutToStoreInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type StoreGroupBy = {
  __typename?: 'StoreGroupBy';
  _count?: Maybe<StoreCountAggregate>;
  _max?: Maybe<StoreMaxAggregate>;
  _min?: Maybe<StoreMinAggregate>;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['String']['output'];
  isMain: Scalars['Boolean']['output'];
  location?: Maybe<Scalars['String']['output']>;
  managerId: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
};

export type StoreListRelationFilter = {
  every?: InputMaybe<StoreWhereInput>;
  none?: InputMaybe<StoreWhereInput>;
  some?: InputMaybe<StoreWhereInput>;
};

export type StoreManagerDiagnostic = {
  __typename?: 'StoreManagerDiagnostic';
  id: Scalars['String']['output'];
  managerEmail?: Maybe<Scalars['String']['output']>;
  managerId: Scalars['String']['output'];
  name: Scalars['String']['output'];
  validManager: Scalars['Boolean']['output'];
};

export type StoreMaxAggregate = {
  __typename?: 'StoreMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  isMain?: Maybe<Scalars['Boolean']['output']>;
  location?: Maybe<Scalars['String']['output']>;
  managerId?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type StoreMaxAggregateInput = {
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  location?: InputMaybe<Scalars['Boolean']['input']>;
  managerId?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StoreMaxOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isMain?: InputMaybe<SortOrder>;
  location?: InputMaybe<SortOrder>;
  managerId?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StoreMinAggregate = {
  __typename?: 'StoreMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  isMain?: Maybe<Scalars['Boolean']['output']>;
  location?: Maybe<Scalars['String']['output']>;
  managerId?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type StoreMinAggregateInput = {
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  isMain?: InputMaybe<Scalars['Boolean']['input']>;
  location?: InputMaybe<Scalars['Boolean']['input']>;
  managerId?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StoreMinOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isMain?: InputMaybe<SortOrder>;
  location?: InputMaybe<SortOrder>;
  managerId?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StoreNullableScalarRelationFilter = {
  is?: InputMaybe<StoreWhereInput>;
  isNot?: InputMaybe<StoreWhereInput>;
};

export type StoreOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type StoreOrderByWithAggregationInput = {
  _count?: InputMaybe<StoreCountOrderByAggregateInput>;
  _max?: InputMaybe<StoreMaxOrderByAggregateInput>;
  _min?: InputMaybe<StoreMinOrderByAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isMain?: InputMaybe<SortOrder>;
  location?: InputMaybe<SortOrderInput>;
  managerId?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StoreOrderByWithRelationInput = {
  Customer?: InputMaybe<CustomerOrderByRelationAggregateInput>;
  CustomerProfile?: InputMaybe<CustomerProfileOrderByRelationAggregateInput>;
  InvoiceImport?: InputMaybe<InvoiceImportOrderByRelationAggregateInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionOrderByRelationAggregateInput>;
  Quotation?: InputMaybe<QuotationOrderByRelationAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  customerSales?: InputMaybe<ConsumerSaleOrderByRelationAggregateInput>;
  id?: InputMaybe<SortOrder>;
  isMain?: InputMaybe<SortOrder>;
  legacyMappings?: InputMaybe<LegacyStoreMappingOrderByRelationAggregateInput>;
  location?: InputMaybe<SortOrderInput>;
  manager?: InputMaybe<UserOrderByWithRelationInput>;
  managerId?: InputMaybe<SortOrder>;
  movements?: InputMaybe<StockMovementOrderByRelationAggregateInput>;
  name?: InputMaybe<SortOrder>;
  purchaseOrders?: InputMaybe<PurchaseOrderOrderByRelationAggregateInput>;
  receipts?: InputMaybe<StockReceiptBatchOrderByRelationAggregateInput>;
  resellerSales?: InputMaybe<ResellerSaleOrderByRelationAggregateInput>;
  salesReturns?: InputMaybe<SalesReturnOrderByRelationAggregateInput>;
  stocks?: InputMaybe<StockOrderByRelationAggregateInput>;
  transfersIn?: InputMaybe<StockTransferOrderByRelationAggregateInput>;
  transfersOut?: InputMaybe<StockTransferOrderByRelationAggregateInput>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type StorePaymentsSummary = {
  __typename?: 'StorePaymentsSummary';
  consumerPaid: Scalars['Float']['output'];
  month: Scalars['String']['output'];
  resellerPaid: Scalars['Float']['output'];
  storeId: Scalars['String']['output'];
  totalPaid: Scalars['Float']['output'];
};

export enum StoreScalarFieldEnum {
  CreatedAt = 'createdAt',
  Id = 'id',
  IsMain = 'isMain',
  Location = 'location',
  ManagerId = 'managerId',
  Name = 'name',
  UpdatedAt = 'updatedAt'
}

export type StoreScalarRelationFilter = {
  is?: InputMaybe<StoreWhereInput>;
  isNot?: InputMaybe<StoreWhereInput>;
};

export type StoreScalarWhereInput = {
  AND?: InputMaybe<Array<StoreScalarWhereInput>>;
  NOT?: InputMaybe<Array<StoreScalarWhereInput>>;
  OR?: InputMaybe<Array<StoreScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  isMain?: InputMaybe<BoolFilter>;
  location?: InputMaybe<StringNullableFilter>;
  managerId?: InputMaybe<StringFilter>;
  name?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type StoreScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<StoreScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<StoreScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<StoreScalarWhereWithAggregatesInput>>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  id?: InputMaybe<StringWithAggregatesFilter>;
  isMain?: InputMaybe<BoolWithAggregatesFilter>;
  location?: InputMaybe<StringNullableWithAggregatesFilter>;
  managerId?: InputMaybe<StringWithAggregatesFilter>;
  name?: InputMaybe<StringWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export type StoreUpdateInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateManyWithWhereWithoutManagerInput = {
  data: StoreUpdateManyMutationInput;
  where: StoreScalarWhereInput;
};

export type StoreUpdateManyWithoutManagerNestedInput = {
  connect?: InputMaybe<Array<StoreWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<StoreCreateOrConnectWithoutManagerInput>>;
  create?: InputMaybe<Array<StoreCreateWithoutManagerInput>>;
  createMany?: InputMaybe<StoreCreateManyManagerInputEnvelope>;
  delete?: InputMaybe<Array<StoreWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<StoreScalarWhereInput>>;
  disconnect?: InputMaybe<Array<StoreWhereUniqueInput>>;
  set?: InputMaybe<Array<StoreWhereUniqueInput>>;
  update?: InputMaybe<Array<StoreUpdateWithWhereUniqueWithoutManagerInput>>;
  updateMany?: InputMaybe<Array<StoreUpdateManyWithWhereWithoutManagerInput>>;
  upsert?: InputMaybe<Array<StoreUpsertWithWhereUniqueWithoutManagerInput>>;
};

export type StoreUpdateOneRequiredWithoutCustomerSalesNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutCustomerSalesInput>;
  create?: InputMaybe<StoreCreateWithoutCustomerSalesInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutCustomerSalesInput>;
  upsert?: InputMaybe<StoreUpsertWithoutCustomerSalesInput>;
};

export type StoreUpdateOneRequiredWithoutMovementsNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutMovementsInput>;
  create?: InputMaybe<StoreCreateWithoutMovementsInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutMovementsInput>;
  upsert?: InputMaybe<StoreUpsertWithoutMovementsInput>;
};

export type StoreUpdateOneRequiredWithoutPurchaseRequisitionNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutPurchaseRequisitionInput>;
  create?: InputMaybe<StoreCreateWithoutPurchaseRequisitionInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutPurchaseRequisitionInput>;
  upsert?: InputMaybe<StoreUpsertWithoutPurchaseRequisitionInput>;
};

export type StoreUpdateOneRequiredWithoutQuotationNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutQuotationInput>;
  create?: InputMaybe<StoreCreateWithoutQuotationInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutQuotationInput>;
  upsert?: InputMaybe<StoreUpsertWithoutQuotationInput>;
};

export type StoreUpdateOneRequiredWithoutReceiptsNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutReceiptsInput>;
  create?: InputMaybe<StoreCreateWithoutReceiptsInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutReceiptsInput>;
  upsert?: InputMaybe<StoreUpsertWithoutReceiptsInput>;
};

export type StoreUpdateOneRequiredWithoutResellerSalesNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutResellerSalesInput>;
  create?: InputMaybe<StoreCreateWithoutResellerSalesInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutResellerSalesInput>;
  upsert?: InputMaybe<StoreUpsertWithoutResellerSalesInput>;
};

export type StoreUpdateOneRequiredWithoutSalesReturnsNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutSalesReturnsInput>;
  create?: InputMaybe<StoreCreateWithoutSalesReturnsInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutSalesReturnsInput>;
  upsert?: InputMaybe<StoreUpsertWithoutSalesReturnsInput>;
};

export type StoreUpdateOneRequiredWithoutStocksNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutStocksInput>;
  create?: InputMaybe<StoreCreateWithoutStocksInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutStocksInput>;
  upsert?: InputMaybe<StoreUpsertWithoutStocksInput>;
};

export type StoreUpdateOneRequiredWithoutTransfersInNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutTransfersInInput>;
  create?: InputMaybe<StoreCreateWithoutTransfersInInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutTransfersInInput>;
  upsert?: InputMaybe<StoreUpsertWithoutTransfersInInput>;
};

export type StoreUpdateOneRequiredWithoutTransfersOutNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutTransfersOutInput>;
  create?: InputMaybe<StoreCreateWithoutTransfersOutInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutTransfersOutInput>;
  upsert?: InputMaybe<StoreUpsertWithoutTransfersOutInput>;
};

export type StoreUpdateOneWithoutCustomerNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutCustomerInput>;
  create?: InputMaybe<StoreCreateWithoutCustomerInput>;
  delete?: InputMaybe<StoreWhereInput>;
  disconnect?: InputMaybe<StoreWhereInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutCustomerInput>;
  upsert?: InputMaybe<StoreUpsertWithoutCustomerInput>;
};

export type StoreUpdateOneWithoutCustomerProfileNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutCustomerProfileInput>;
  create?: InputMaybe<StoreCreateWithoutCustomerProfileInput>;
  delete?: InputMaybe<StoreWhereInput>;
  disconnect?: InputMaybe<StoreWhereInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutCustomerProfileInput>;
  upsert?: InputMaybe<StoreUpsertWithoutCustomerProfileInput>;
};

export type StoreUpdateOneWithoutPurchaseOrdersNestedInput = {
  connect?: InputMaybe<StoreWhereUniqueInput>;
  connectOrCreate?: InputMaybe<StoreCreateOrConnectWithoutPurchaseOrdersInput>;
  create?: InputMaybe<StoreCreateWithoutPurchaseOrdersInput>;
  delete?: InputMaybe<StoreWhereInput>;
  disconnect?: InputMaybe<StoreWhereInput>;
  update?: InputMaybe<StoreUpdateToOneWithWhereWithoutPurchaseOrdersInput>;
  upsert?: InputMaybe<StoreUpsertWithoutPurchaseOrdersInput>;
};

export type StoreUpdateToOneWithWhereWithoutCustomerInput = {
  data: StoreUpdateWithoutCustomerInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutCustomerProfileInput = {
  data: StoreUpdateWithoutCustomerProfileInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutCustomerSalesInput = {
  data: StoreUpdateWithoutCustomerSalesInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutMovementsInput = {
  data: StoreUpdateWithoutMovementsInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
  data: StoreUpdateWithoutPurchaseOrdersInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutPurchaseRequisitionInput = {
  data: StoreUpdateWithoutPurchaseRequisitionInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutQuotationInput = {
  data: StoreUpdateWithoutQuotationInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutReceiptsInput = {
  data: StoreUpdateWithoutReceiptsInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutResellerSalesInput = {
  data: StoreUpdateWithoutResellerSalesInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutSalesReturnsInput = {
  data: StoreUpdateWithoutSalesReturnsInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutStocksInput = {
  data: StoreUpdateWithoutStocksInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutTransfersInInput = {
  data: StoreUpdateWithoutTransfersInInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateToOneWithWhereWithoutTransfersOutInput = {
  data: StoreUpdateWithoutTransfersOutInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpdateWithWhereUniqueWithoutManagerInput = {
  data: StoreUpdateWithoutManagerInput;
  where: StoreWhereUniqueInput;
};

export type StoreUpdateWithoutCustomerInput = {
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutCustomerProfileInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutCustomerSalesInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutManagerInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutMovementsInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutPurchaseOrdersInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutPurchaseRequisitionInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutQuotationInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutReceiptsInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutResellerSalesInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutSalesReturnsInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutStocksInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutTransfersInInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersOut?: InputMaybe<StockTransferUpdateManyWithoutFromStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpdateWithoutTransfersOutInput = {
  Customer?: InputMaybe<CustomerUpdateManyWithoutPreferredStoreNestedInput>;
  CustomerProfile?: InputMaybe<CustomerProfileUpdateManyWithoutPreferredStoreNestedInput>;
  InvoiceImport?: InputMaybe<InvoiceImportUpdateManyWithoutStoreNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutStoreNestedInput>;
  Quotation?: InputMaybe<QuotationUpdateManyWithoutStoreNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerSales?: InputMaybe<ConsumerSaleUpdateManyWithoutStoreNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isMain?: InputMaybe<BoolFieldUpdateOperationsInput>;
  legacyMappings?: InputMaybe<LegacyStoreMappingUpdateManyWithoutStoreNestedInput>;
  location?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  manager?: InputMaybe<UserUpdateOneRequiredWithoutStoreNestedInput>;
  movements?: InputMaybe<StockMovementUpdateManyWithoutStoreNestedInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutStoreNestedInput>;
  receipts?: InputMaybe<StockReceiptBatchUpdateManyWithoutStoreNestedInput>;
  resellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutStoreNestedInput>;
  salesReturns?: InputMaybe<SalesReturnUpdateManyWithoutStoreNestedInput>;
  stocks?: InputMaybe<StockUpdateManyWithoutStoreNestedInput>;
  transfersIn?: InputMaybe<StockTransferUpdateManyWithoutToStoreNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type StoreUpsertWithWhereUniqueWithoutManagerInput = {
  create: StoreCreateWithoutManagerInput;
  update: StoreUpdateWithoutManagerInput;
  where: StoreWhereUniqueInput;
};

export type StoreUpsertWithoutCustomerInput = {
  create: StoreCreateWithoutCustomerInput;
  update: StoreUpdateWithoutCustomerInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutCustomerProfileInput = {
  create: StoreCreateWithoutCustomerProfileInput;
  update: StoreUpdateWithoutCustomerProfileInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutCustomerSalesInput = {
  create: StoreCreateWithoutCustomerSalesInput;
  update: StoreUpdateWithoutCustomerSalesInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutMovementsInput = {
  create: StoreCreateWithoutMovementsInput;
  update: StoreUpdateWithoutMovementsInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutPurchaseOrdersInput = {
  create: StoreCreateWithoutPurchaseOrdersInput;
  update: StoreUpdateWithoutPurchaseOrdersInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutPurchaseRequisitionInput = {
  create: StoreCreateWithoutPurchaseRequisitionInput;
  update: StoreUpdateWithoutPurchaseRequisitionInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutQuotationInput = {
  create: StoreCreateWithoutQuotationInput;
  update: StoreUpdateWithoutQuotationInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutReceiptsInput = {
  create: StoreCreateWithoutReceiptsInput;
  update: StoreUpdateWithoutReceiptsInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutResellerSalesInput = {
  create: StoreCreateWithoutResellerSalesInput;
  update: StoreUpdateWithoutResellerSalesInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutSalesReturnsInput = {
  create: StoreCreateWithoutSalesReturnsInput;
  update: StoreUpdateWithoutSalesReturnsInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutStocksInput = {
  create: StoreCreateWithoutStocksInput;
  update: StoreUpdateWithoutStocksInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutTransfersInInput = {
  create: StoreCreateWithoutTransfersInInput;
  update: StoreUpdateWithoutTransfersInInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreUpsertWithoutTransfersOutInput = {
  create: StoreCreateWithoutTransfersOutInput;
  update: StoreUpdateWithoutTransfersOutInput;
  where?: InputMaybe<StoreWhereInput>;
};

export type StoreWhereInput = {
  AND?: InputMaybe<Array<StoreWhereInput>>;
  Customer?: InputMaybe<CustomerListRelationFilter>;
  CustomerProfile?: InputMaybe<CustomerProfileListRelationFilter>;
  InvoiceImport?: InputMaybe<InvoiceImportListRelationFilter>;
  NOT?: InputMaybe<Array<StoreWhereInput>>;
  OR?: InputMaybe<Array<StoreWhereInput>>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionListRelationFilter>;
  Quotation?: InputMaybe<QuotationListRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  customerSales?: InputMaybe<ConsumerSaleListRelationFilter>;
  id?: InputMaybe<StringFilter>;
  isMain?: InputMaybe<BoolFilter>;
  legacyMappings?: InputMaybe<LegacyStoreMappingListRelationFilter>;
  location?: InputMaybe<StringNullableFilter>;
  manager?: InputMaybe<UserScalarRelationFilter>;
  managerId?: InputMaybe<StringFilter>;
  movements?: InputMaybe<StockMovementListRelationFilter>;
  name?: InputMaybe<StringFilter>;
  purchaseOrders?: InputMaybe<PurchaseOrderListRelationFilter>;
  receipts?: InputMaybe<StockReceiptBatchListRelationFilter>;
  resellerSales?: InputMaybe<ResellerSaleListRelationFilter>;
  salesReturns?: InputMaybe<SalesReturnListRelationFilter>;
  stocks?: InputMaybe<StockListRelationFilter>;
  transfersIn?: InputMaybe<StockTransferListRelationFilter>;
  transfersOut?: InputMaybe<StockTransferListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type StoreWhereUniqueInput = {
  AND?: InputMaybe<Array<StoreWhereInput>>;
  Customer?: InputMaybe<CustomerListRelationFilter>;
  CustomerProfile?: InputMaybe<CustomerProfileListRelationFilter>;
  InvoiceImport?: InputMaybe<InvoiceImportListRelationFilter>;
  NOT?: InputMaybe<Array<StoreWhereInput>>;
  OR?: InputMaybe<Array<StoreWhereInput>>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionListRelationFilter>;
  Quotation?: InputMaybe<QuotationListRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  customerSales?: InputMaybe<ConsumerSaleListRelationFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  isMain?: InputMaybe<BoolFilter>;
  legacyMappings?: InputMaybe<LegacyStoreMappingListRelationFilter>;
  location?: InputMaybe<StringNullableFilter>;
  manager?: InputMaybe<UserScalarRelationFilter>;
  managerId?: InputMaybe<StringFilter>;
  movements?: InputMaybe<StockMovementListRelationFilter>;
  name?: InputMaybe<StringFilter>;
  purchaseOrders?: InputMaybe<PurchaseOrderListRelationFilter>;
  receipts?: InputMaybe<StockReceiptBatchListRelationFilter>;
  resellerSales?: InputMaybe<ResellerSaleListRelationFilter>;
  salesReturns?: InputMaybe<SalesReturnListRelationFilter>;
  stocks?: InputMaybe<StockListRelationFilter>;
  transfersIn?: InputMaybe<StockTransferListRelationFilter>;
  transfersOut?: InputMaybe<StockTransferListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type StringFieldUpdateOperationsInput = {
  set?: InputMaybe<Scalars['String']['input']>;
};

export type StringFilter = {
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type StringNullableFilter = {
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type StringNullableListFilter = {
  equals?: InputMaybe<Array<Scalars['String']['input']>>;
  has?: InputMaybe<Scalars['String']['input']>;
  hasEvery?: InputMaybe<Array<Scalars['String']['input']>>;
  hasSome?: InputMaybe<Array<Scalars['String']['input']>>;
  isEmpty?: InputMaybe<Scalars['Boolean']['input']>;
};

export type StringNullableWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntNullableFilter>;
  _max?: InputMaybe<NestedStringNullableFilter>;
  _min?: InputMaybe<NestedStringNullableFilter>;
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringNullableWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type StringWithAggregatesFilter = {
  _count?: InputMaybe<NestedIntFilter>;
  _max?: InputMaybe<NestedStringFilter>;
  _min?: InputMaybe<NestedStringFilter>;
  contains?: InputMaybe<Scalars['String']['input']>;
  endsWith?: InputMaybe<Scalars['String']['input']>;
  equals?: InputMaybe<Scalars['String']['input']>;
  gt?: InputMaybe<Scalars['String']['input']>;
  gte?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  lt?: InputMaybe<Scalars['String']['input']>;
  lte?: InputMaybe<Scalars['String']['input']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringWithAggregatesFilter>;
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  startsWith?: InputMaybe<Scalars['String']['input']>;
};

export type SubmitSupplierQuoteInput = {
  items: Array<SupplierQuoteItemInput>;
  notes?: InputMaybe<Scalars['String']['input']>;
  requisitionId: Scalars['String']['input'];
  supplierId: Scalars['String']['input'];
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type Supplier = {
  __typename?: 'Supplier';
  _count: SupplierCount;
  catalogs?: Maybe<Array<SupplierCatalog>>;
  contactInfo?: Maybe<Scalars['JSON']['output']>;
  createdAt: Scalars['DateTime']['output'];
  creditLimit: Scalars['Float']['output'];
  currentBalance: Scalars['Float']['output'];
  id: Scalars['ID']['output'];
  isFrequent: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  paymentTerms?: Maybe<Scalars['String']['output']>;
  payments?: Maybe<Array<SupplierPayment>>;
  purchaseOrders?: Maybe<Array<PurchaseOrder>>;
  quotes?: Maybe<Array<SupplierQuote>>;
  returns?: Maybe<Array<PurchaseReturn>>;
  updatedAt: Scalars['DateTime']['output'];
  user?: Maybe<User>;
  userId?: Maybe<Scalars['String']['output']>;
};

export type SupplierAvgAggregate = {
  __typename?: 'SupplierAvgAggregate';
  creditLimit?: Maybe<Scalars['Float']['output']>;
  currentBalance?: Maybe<Scalars['Float']['output']>;
};

export type SupplierCatalog = {
  __typename?: 'SupplierCatalog';
  defaultCost: Scalars['Float']['output'];
  id: Scalars['ID']['output'];
  isPreferred: Scalars['Boolean']['output'];
  leadTimeDays?: Maybe<Scalars['Int']['output']>;
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  supplier: Supplier;
  supplierId: Scalars['String']['output'];
};

export type SupplierCatalogCreateManyProductVariantInput = {
  defaultCost: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  isPreferred?: InputMaybe<Scalars['Boolean']['input']>;
  leadTimeDays?: InputMaybe<Scalars['Int']['input']>;
  supplierId: Scalars['String']['input'];
};

export type SupplierCatalogCreateManyProductVariantInputEnvelope = {
  data: Array<SupplierCatalogCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SupplierCatalogCreateManySupplierInput = {
  defaultCost: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  isPreferred?: InputMaybe<Scalars['Boolean']['input']>;
  leadTimeDays?: InputMaybe<Scalars['Int']['input']>;
  productVariantId: Scalars['String']['input'];
};

export type SupplierCatalogCreateManySupplierInputEnvelope = {
  data: Array<SupplierCatalogCreateManySupplierInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SupplierCatalogCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<SupplierCatalogWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierCatalogCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<SupplierCatalogCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<SupplierCatalogCreateManyProductVariantInputEnvelope>;
};

export type SupplierCatalogCreateNestedManyWithoutSupplierInput = {
  connect?: InputMaybe<Array<SupplierCatalogWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierCatalogCreateOrConnectWithoutSupplierInput>>;
  create?: InputMaybe<Array<SupplierCatalogCreateWithoutSupplierInput>>;
  createMany?: InputMaybe<SupplierCatalogCreateManySupplierInputEnvelope>;
};

export type SupplierCatalogCreateOrConnectWithoutProductVariantInput = {
  create: SupplierCatalogCreateWithoutProductVariantInput;
  where: SupplierCatalogWhereUniqueInput;
};

export type SupplierCatalogCreateOrConnectWithoutSupplierInput = {
  create: SupplierCatalogCreateWithoutSupplierInput;
  where: SupplierCatalogWhereUniqueInput;
};

export type SupplierCatalogCreateWithoutProductVariantInput = {
  defaultCost: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  isPreferred?: InputMaybe<Scalars['Boolean']['input']>;
  leadTimeDays?: InputMaybe<Scalars['Int']['input']>;
  supplier: SupplierCreateNestedOneWithoutCatalogsInput;
};

export type SupplierCatalogCreateWithoutSupplierInput = {
  defaultCost: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  isPreferred?: InputMaybe<Scalars['Boolean']['input']>;
  leadTimeDays?: InputMaybe<Scalars['Int']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutSupplierCatalogInput;
};

export type SupplierCatalogEntry = {
  __typename?: 'SupplierCatalogEntry';
  defaultCost: Scalars['Float']['output'];
  isPreferred?: Maybe<Scalars['Boolean']['output']>;
  leadTimeDays?: Maybe<Scalars['Int']['output']>;
  productVariantId: Scalars['String']['output'];
  supplierId: Scalars['String']['output'];
};

export type SupplierCatalogListRelationFilter = {
  every?: InputMaybe<SupplierCatalogWhereInput>;
  none?: InputMaybe<SupplierCatalogWhereInput>;
  some?: InputMaybe<SupplierCatalogWhereInput>;
};

export type SupplierCatalogOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SupplierCatalogScalarWhereInput = {
  AND?: InputMaybe<Array<SupplierCatalogScalarWhereInput>>;
  NOT?: InputMaybe<Array<SupplierCatalogScalarWhereInput>>;
  OR?: InputMaybe<Array<SupplierCatalogScalarWhereInput>>;
  defaultCost?: InputMaybe<FloatFilter>;
  id?: InputMaybe<StringFilter>;
  isPreferred?: InputMaybe<BoolFilter>;
  leadTimeDays?: InputMaybe<IntNullableFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  supplierId?: InputMaybe<StringFilter>;
};

export type SupplierCatalogSupplierIdProductVariantIdCompoundUniqueInput = {
  productVariantId: Scalars['String']['input'];
  supplierId: Scalars['String']['input'];
};

export type SupplierCatalogUpdateManyMutationInput = {
  defaultCost?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isPreferred?: InputMaybe<BoolFieldUpdateOperationsInput>;
  leadTimeDays?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
};

export type SupplierCatalogUpdateManyWithWhereWithoutProductVariantInput = {
  data: SupplierCatalogUpdateManyMutationInput;
  where: SupplierCatalogScalarWhereInput;
};

export type SupplierCatalogUpdateManyWithWhereWithoutSupplierInput = {
  data: SupplierCatalogUpdateManyMutationInput;
  where: SupplierCatalogScalarWhereInput;
};

export type SupplierCatalogUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<SupplierCatalogWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierCatalogCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<SupplierCatalogCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<SupplierCatalogCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<SupplierCatalogWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SupplierCatalogScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SupplierCatalogWhereUniqueInput>>;
  set?: InputMaybe<Array<SupplierCatalogWhereUniqueInput>>;
  update?: InputMaybe<Array<SupplierCatalogUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<SupplierCatalogUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<SupplierCatalogUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type SupplierCatalogUpdateManyWithoutSupplierNestedInput = {
  connect?: InputMaybe<Array<SupplierCatalogWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierCatalogCreateOrConnectWithoutSupplierInput>>;
  create?: InputMaybe<Array<SupplierCatalogCreateWithoutSupplierInput>>;
  createMany?: InputMaybe<SupplierCatalogCreateManySupplierInputEnvelope>;
  delete?: InputMaybe<Array<SupplierCatalogWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SupplierCatalogScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SupplierCatalogWhereUniqueInput>>;
  set?: InputMaybe<Array<SupplierCatalogWhereUniqueInput>>;
  update?: InputMaybe<Array<SupplierCatalogUpdateWithWhereUniqueWithoutSupplierInput>>;
  updateMany?: InputMaybe<Array<SupplierCatalogUpdateManyWithWhereWithoutSupplierInput>>;
  upsert?: InputMaybe<Array<SupplierCatalogUpsertWithWhereUniqueWithoutSupplierInput>>;
};

export type SupplierCatalogUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: SupplierCatalogUpdateWithoutProductVariantInput;
  where: SupplierCatalogWhereUniqueInput;
};

export type SupplierCatalogUpdateWithWhereUniqueWithoutSupplierInput = {
  data: SupplierCatalogUpdateWithoutSupplierInput;
  where: SupplierCatalogWhereUniqueInput;
};

export type SupplierCatalogUpdateWithoutProductVariantInput = {
  defaultCost?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isPreferred?: InputMaybe<BoolFieldUpdateOperationsInput>;
  leadTimeDays?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  supplier?: InputMaybe<SupplierUpdateOneRequiredWithoutCatalogsNestedInput>;
};

export type SupplierCatalogUpdateWithoutSupplierInput = {
  defaultCost?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isPreferred?: InputMaybe<BoolFieldUpdateOperationsInput>;
  leadTimeDays?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutSupplierCatalogNestedInput>;
};

export type SupplierCatalogUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: SupplierCatalogCreateWithoutProductVariantInput;
  update: SupplierCatalogUpdateWithoutProductVariantInput;
  where: SupplierCatalogWhereUniqueInput;
};

export type SupplierCatalogUpsertWithWhereUniqueWithoutSupplierInput = {
  create: SupplierCatalogCreateWithoutSupplierInput;
  update: SupplierCatalogUpdateWithoutSupplierInput;
  where: SupplierCatalogWhereUniqueInput;
};

export type SupplierCatalogWhereInput = {
  AND?: InputMaybe<Array<SupplierCatalogWhereInput>>;
  NOT?: InputMaybe<Array<SupplierCatalogWhereInput>>;
  OR?: InputMaybe<Array<SupplierCatalogWhereInput>>;
  defaultCost?: InputMaybe<FloatFilter>;
  id?: InputMaybe<StringFilter>;
  isPreferred?: InputMaybe<BoolFilter>;
  leadTimeDays?: InputMaybe<IntNullableFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  supplier?: InputMaybe<SupplierScalarRelationFilter>;
  supplierId?: InputMaybe<StringFilter>;
};

export type SupplierCatalogWhereUniqueInput = {
  AND?: InputMaybe<Array<SupplierCatalogWhereInput>>;
  NOT?: InputMaybe<Array<SupplierCatalogWhereInput>>;
  OR?: InputMaybe<Array<SupplierCatalogWhereInput>>;
  defaultCost?: InputMaybe<FloatFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  isPreferred?: InputMaybe<BoolFilter>;
  leadTimeDays?: InputMaybe<IntNullableFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  supplier?: InputMaybe<SupplierScalarRelationFilter>;
  supplierId?: InputMaybe<StringFilter>;
  supplierId_productVariantId?: InputMaybe<SupplierCatalogSupplierIdProductVariantIdCompoundUniqueInput>;
};

export type SupplierCount = {
  __typename?: 'SupplierCount';
  catalogs: Scalars['Int']['output'];
  payments: Scalars['Int']['output'];
  purchaseOrders: Scalars['Int']['output'];
  quotes: Scalars['Int']['output'];
  returns: Scalars['Int']['output'];
};

export type SupplierCountAggregate = {
  __typename?: 'SupplierCountAggregate';
  _all: Scalars['Int']['output'];
  contactInfo: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  creditLimit: Scalars['Int']['output'];
  currentBalance: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isFrequent: Scalars['Int']['output'];
  name: Scalars['Int']['output'];
  notes: Scalars['Int']['output'];
  paymentTerms: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
  userId: Scalars['Int']['output'];
};

export type SupplierCreateManyUserInput = {
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  creditLimit: Scalars['Float']['input'];
  currentBalance?: InputMaybe<Scalars['Float']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isFrequent?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentTerms?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SupplierCreateManyUserInputEnvelope = {
  data: Array<SupplierCreateManyUserInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SupplierCreateNestedManyWithoutUserInput = {
  connect?: InputMaybe<Array<SupplierWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<SupplierCreateWithoutUserInput>>;
  createMany?: InputMaybe<SupplierCreateManyUserInputEnvelope>;
};

export type SupplierCreateNestedOneWithoutCatalogsInput = {
  connect?: InputMaybe<SupplierWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierCreateOrConnectWithoutCatalogsInput>;
  create?: InputMaybe<SupplierCreateWithoutCatalogsInput>;
};

export type SupplierCreateNestedOneWithoutPaymentsInput = {
  connect?: InputMaybe<SupplierWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierCreateOrConnectWithoutPaymentsInput>;
  create?: InputMaybe<SupplierCreateWithoutPaymentsInput>;
};

export type SupplierCreateNestedOneWithoutPurchaseOrdersInput = {
  connect?: InputMaybe<SupplierWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierCreateOrConnectWithoutPurchaseOrdersInput>;
  create?: InputMaybe<SupplierCreateWithoutPurchaseOrdersInput>;
};

export type SupplierCreateNestedOneWithoutQuotesInput = {
  connect?: InputMaybe<SupplierWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierCreateOrConnectWithoutQuotesInput>;
  create?: InputMaybe<SupplierCreateWithoutQuotesInput>;
};

export type SupplierCreateNestedOneWithoutReturnsInput = {
  connect?: InputMaybe<SupplierWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierCreateOrConnectWithoutReturnsInput>;
  create?: InputMaybe<SupplierCreateWithoutReturnsInput>;
};

export type SupplierCreateOrConnectWithoutCatalogsInput = {
  create: SupplierCreateWithoutCatalogsInput;
  where: SupplierWhereUniqueInput;
};

export type SupplierCreateOrConnectWithoutPaymentsInput = {
  create: SupplierCreateWithoutPaymentsInput;
  where: SupplierWhereUniqueInput;
};

export type SupplierCreateOrConnectWithoutPurchaseOrdersInput = {
  create: SupplierCreateWithoutPurchaseOrdersInput;
  where: SupplierWhereUniqueInput;
};

export type SupplierCreateOrConnectWithoutQuotesInput = {
  create: SupplierCreateWithoutQuotesInput;
  where: SupplierWhereUniqueInput;
};

export type SupplierCreateOrConnectWithoutReturnsInput = {
  create: SupplierCreateWithoutReturnsInput;
  where: SupplierWhereUniqueInput;
};

export type SupplierCreateOrConnectWithoutUserInput = {
  create: SupplierCreateWithoutUserInput;
  where: SupplierWhereUniqueInput;
};

export type SupplierCreateWithoutCatalogsInput = {
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  creditLimit: Scalars['Float']['input'];
  currentBalance?: InputMaybe<Scalars['Float']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isFrequent?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentTerms?: InputMaybe<Scalars['String']['input']>;
  payments?: InputMaybe<SupplierPaymentCreateNestedManyWithoutSupplierInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutSupplierInput>;
  quotes?: InputMaybe<SupplierQuoteCreateNestedManyWithoutSupplierInput>;
  returns?: InputMaybe<PurchaseReturnCreateNestedManyWithoutSupplierInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  user?: InputMaybe<UserCreateNestedOneWithoutSupplierInput>;
};

export type SupplierCreateWithoutPaymentsInput = {
  catalogs?: InputMaybe<SupplierCatalogCreateNestedManyWithoutSupplierInput>;
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  creditLimit: Scalars['Float']['input'];
  currentBalance?: InputMaybe<Scalars['Float']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isFrequent?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentTerms?: InputMaybe<Scalars['String']['input']>;
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutSupplierInput>;
  quotes?: InputMaybe<SupplierQuoteCreateNestedManyWithoutSupplierInput>;
  returns?: InputMaybe<PurchaseReturnCreateNestedManyWithoutSupplierInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  user?: InputMaybe<UserCreateNestedOneWithoutSupplierInput>;
};

export type SupplierCreateWithoutPurchaseOrdersInput = {
  catalogs?: InputMaybe<SupplierCatalogCreateNestedManyWithoutSupplierInput>;
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  creditLimit: Scalars['Float']['input'];
  currentBalance?: InputMaybe<Scalars['Float']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isFrequent?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentTerms?: InputMaybe<Scalars['String']['input']>;
  payments?: InputMaybe<SupplierPaymentCreateNestedManyWithoutSupplierInput>;
  quotes?: InputMaybe<SupplierQuoteCreateNestedManyWithoutSupplierInput>;
  returns?: InputMaybe<PurchaseReturnCreateNestedManyWithoutSupplierInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  user?: InputMaybe<UserCreateNestedOneWithoutSupplierInput>;
};

export type SupplierCreateWithoutQuotesInput = {
  catalogs?: InputMaybe<SupplierCatalogCreateNestedManyWithoutSupplierInput>;
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  creditLimit: Scalars['Float']['input'];
  currentBalance?: InputMaybe<Scalars['Float']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isFrequent?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentTerms?: InputMaybe<Scalars['String']['input']>;
  payments?: InputMaybe<SupplierPaymentCreateNestedManyWithoutSupplierInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutSupplierInput>;
  returns?: InputMaybe<PurchaseReturnCreateNestedManyWithoutSupplierInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  user?: InputMaybe<UserCreateNestedOneWithoutSupplierInput>;
};

export type SupplierCreateWithoutReturnsInput = {
  catalogs?: InputMaybe<SupplierCatalogCreateNestedManyWithoutSupplierInput>;
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  creditLimit: Scalars['Float']['input'];
  currentBalance?: InputMaybe<Scalars['Float']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isFrequent?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentTerms?: InputMaybe<Scalars['String']['input']>;
  payments?: InputMaybe<SupplierPaymentCreateNestedManyWithoutSupplierInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutSupplierInput>;
  quotes?: InputMaybe<SupplierQuoteCreateNestedManyWithoutSupplierInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  user?: InputMaybe<UserCreateNestedOneWithoutSupplierInput>;
};

export type SupplierCreateWithoutUserInput = {
  catalogs?: InputMaybe<SupplierCatalogCreateNestedManyWithoutSupplierInput>;
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  creditLimit: Scalars['Float']['input'];
  currentBalance?: InputMaybe<Scalars['Float']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isFrequent?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentTerms?: InputMaybe<Scalars['String']['input']>;
  payments?: InputMaybe<SupplierPaymentCreateNestedManyWithoutSupplierInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderCreateNestedManyWithoutSupplierInput>;
  quotes?: InputMaybe<SupplierQuoteCreateNestedManyWithoutSupplierInput>;
  returns?: InputMaybe<PurchaseReturnCreateNestedManyWithoutSupplierInput>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SupplierCreditStatus = {
  __typename?: 'SupplierCreditStatus';
  creditLimit: Scalars['Float']['output'];
  currentBalance: Scalars['Float']['output'];
  name: Scalars['String']['output'];
  supplierId: Scalars['String']['output'];
};

export type SupplierListRelationFilter = {
  every?: InputMaybe<SupplierWhereInput>;
  none?: InputMaybe<SupplierWhereInput>;
  some?: InputMaybe<SupplierWhereInput>;
};

export type SupplierMaxAggregate = {
  __typename?: 'SupplierMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  creditLimit?: Maybe<Scalars['Float']['output']>;
  currentBalance?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  isFrequent?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  paymentTerms?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  userId?: Maybe<Scalars['String']['output']>;
};

export type SupplierMinAggregate = {
  __typename?: 'SupplierMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  creditLimit?: Maybe<Scalars['Float']['output']>;
  currentBalance?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  isFrequent?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  paymentTerms?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
  userId?: Maybe<Scalars['String']['output']>;
};

export type SupplierOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SupplierOrderByWithRelationInput = {
  catalogs?: InputMaybe<SupplierCatalogOrderByRelationAggregateInput>;
  contactInfo?: InputMaybe<SortOrderInput>;
  createdAt?: InputMaybe<SortOrder>;
  creditLimit?: InputMaybe<SortOrder>;
  currentBalance?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isFrequent?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  notes?: InputMaybe<SortOrderInput>;
  paymentTerms?: InputMaybe<SortOrderInput>;
  payments?: InputMaybe<SupplierPaymentOrderByRelationAggregateInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderOrderByRelationAggregateInput>;
  quotes?: InputMaybe<SupplierQuoteOrderByRelationAggregateInput>;
  returns?: InputMaybe<PurchaseReturnOrderByRelationAggregateInput>;
  updatedAt?: InputMaybe<SortOrder>;
  user?: InputMaybe<UserOrderByWithRelationInput>;
  userId?: InputMaybe<SortOrderInput>;
};

export type SupplierPayment = {
  __typename?: 'SupplierPayment';
  amount: Scalars['Float']['output'];
  id: Scalars['ID']['output'];
  method: Scalars['String']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  paymentDate: Scalars['DateTime']['output'];
  purchaseOrder?: Maybe<PurchaseOrder>;
  purchaseOrderId?: Maybe<Scalars['String']['output']>;
  supplier: Supplier;
  supplierId: Scalars['String']['output'];
};

export type SupplierPaymentAvgAggregate = {
  __typename?: 'SupplierPaymentAvgAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
};

export type SupplierPaymentCountAggregate = {
  __typename?: 'SupplierPaymentCountAggregate';
  _all: Scalars['Int']['output'];
  amount: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  method: Scalars['Int']['output'];
  notes: Scalars['Int']['output'];
  paymentDate: Scalars['Int']['output'];
  purchaseOrderId: Scalars['Int']['output'];
  supplierId: Scalars['Int']['output'];
};

export type SupplierPaymentCreateManyPurchaseOrderInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentDate: Scalars['DateTime']['input'];
  supplierId: Scalars['String']['input'];
};

export type SupplierPaymentCreateManyPurchaseOrderInputEnvelope = {
  data: Array<SupplierPaymentCreateManyPurchaseOrderInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SupplierPaymentCreateManySupplierInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentDate: Scalars['DateTime']['input'];
  purchaseOrderId?: InputMaybe<Scalars['String']['input']>;
};

export type SupplierPaymentCreateManySupplierInputEnvelope = {
  data: Array<SupplierPaymentCreateManySupplierInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SupplierPaymentCreateNestedManyWithoutPurchaseOrderInput = {
  connect?: InputMaybe<Array<SupplierPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierPaymentCreateOrConnectWithoutPurchaseOrderInput>>;
  create?: InputMaybe<Array<SupplierPaymentCreateWithoutPurchaseOrderInput>>;
  createMany?: InputMaybe<SupplierPaymentCreateManyPurchaseOrderInputEnvelope>;
};

export type SupplierPaymentCreateNestedManyWithoutSupplierInput = {
  connect?: InputMaybe<Array<SupplierPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierPaymentCreateOrConnectWithoutSupplierInput>>;
  create?: InputMaybe<Array<SupplierPaymentCreateWithoutSupplierInput>>;
  createMany?: InputMaybe<SupplierPaymentCreateManySupplierInputEnvelope>;
};

export type SupplierPaymentCreateOrConnectWithoutPurchaseOrderInput = {
  create: SupplierPaymentCreateWithoutPurchaseOrderInput;
  where: SupplierPaymentWhereUniqueInput;
};

export type SupplierPaymentCreateOrConnectWithoutSupplierInput = {
  create: SupplierPaymentCreateWithoutSupplierInput;
  where: SupplierPaymentWhereUniqueInput;
};

export type SupplierPaymentCreateWithoutPurchaseOrderInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentDate: Scalars['DateTime']['input'];
  supplier: SupplierCreateNestedOneWithoutPaymentsInput;
};

export type SupplierPaymentCreateWithoutSupplierInput = {
  amount: Scalars['Float']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  method: Scalars['String']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentDate: Scalars['DateTime']['input'];
  purchaseOrder?: InputMaybe<PurchaseOrderCreateNestedOneWithoutPaymentsInput>;
};

export type SupplierPaymentListRelationFilter = {
  every?: InputMaybe<SupplierPaymentWhereInput>;
  none?: InputMaybe<SupplierPaymentWhereInput>;
  some?: InputMaybe<SupplierPaymentWhereInput>;
};

export type SupplierPaymentMaxAggregate = {
  __typename?: 'SupplierPaymentMaxAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  method?: Maybe<Scalars['String']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  paymentDate?: Maybe<Scalars['DateTime']['output']>;
  purchaseOrderId?: Maybe<Scalars['String']['output']>;
  supplierId?: Maybe<Scalars['String']['output']>;
};

export type SupplierPaymentMethodBreakdownEntry = {
  __typename?: 'SupplierPaymentMethodBreakdownEntry';
  count: Scalars['Int']['output'];
  method: Scalars['String']['output'];
  totalPaid: Scalars['Float']['output'];
};

export type SupplierPaymentMinAggregate = {
  __typename?: 'SupplierPaymentMinAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  method?: Maybe<Scalars['String']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  paymentDate?: Maybe<Scalars['DateTime']['output']>;
  purchaseOrderId?: Maybe<Scalars['String']['output']>;
  supplierId?: Maybe<Scalars['String']['output']>;
};

export type SupplierPaymentOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SupplierPaymentScalarWhereInput = {
  AND?: InputMaybe<Array<SupplierPaymentScalarWhereInput>>;
  NOT?: InputMaybe<Array<SupplierPaymentScalarWhereInput>>;
  OR?: InputMaybe<Array<SupplierPaymentScalarWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  id?: InputMaybe<StringFilter>;
  method?: InputMaybe<StringFilter>;
  notes?: InputMaybe<StringNullableFilter>;
  paymentDate?: InputMaybe<DateTimeFilter>;
  purchaseOrderId?: InputMaybe<StringNullableFilter>;
  supplierId?: InputMaybe<StringFilter>;
};

export type SupplierPaymentSumAggregate = {
  __typename?: 'SupplierPaymentSumAggregate';
  amount?: Maybe<Scalars['Float']['output']>;
};

export type SupplierPaymentUpdateManyMutationInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  paymentDate?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SupplierPaymentUpdateManyWithWhereWithoutPurchaseOrderInput = {
  data: SupplierPaymentUpdateManyMutationInput;
  where: SupplierPaymentScalarWhereInput;
};

export type SupplierPaymentUpdateManyWithWhereWithoutSupplierInput = {
  data: SupplierPaymentUpdateManyMutationInput;
  where: SupplierPaymentScalarWhereInput;
};

export type SupplierPaymentUpdateManyWithoutPurchaseOrderNestedInput = {
  connect?: InputMaybe<Array<SupplierPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierPaymentCreateOrConnectWithoutPurchaseOrderInput>>;
  create?: InputMaybe<Array<SupplierPaymentCreateWithoutPurchaseOrderInput>>;
  createMany?: InputMaybe<SupplierPaymentCreateManyPurchaseOrderInputEnvelope>;
  delete?: InputMaybe<Array<SupplierPaymentWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SupplierPaymentScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SupplierPaymentWhereUniqueInput>>;
  set?: InputMaybe<Array<SupplierPaymentWhereUniqueInput>>;
  update?: InputMaybe<Array<SupplierPaymentUpdateWithWhereUniqueWithoutPurchaseOrderInput>>;
  updateMany?: InputMaybe<Array<SupplierPaymentUpdateManyWithWhereWithoutPurchaseOrderInput>>;
  upsert?: InputMaybe<Array<SupplierPaymentUpsertWithWhereUniqueWithoutPurchaseOrderInput>>;
};

export type SupplierPaymentUpdateManyWithoutSupplierNestedInput = {
  connect?: InputMaybe<Array<SupplierPaymentWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierPaymentCreateOrConnectWithoutSupplierInput>>;
  create?: InputMaybe<Array<SupplierPaymentCreateWithoutSupplierInput>>;
  createMany?: InputMaybe<SupplierPaymentCreateManySupplierInputEnvelope>;
  delete?: InputMaybe<Array<SupplierPaymentWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SupplierPaymentScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SupplierPaymentWhereUniqueInput>>;
  set?: InputMaybe<Array<SupplierPaymentWhereUniqueInput>>;
  update?: InputMaybe<Array<SupplierPaymentUpdateWithWhereUniqueWithoutSupplierInput>>;
  updateMany?: InputMaybe<Array<SupplierPaymentUpdateManyWithWhereWithoutSupplierInput>>;
  upsert?: InputMaybe<Array<SupplierPaymentUpsertWithWhereUniqueWithoutSupplierInput>>;
};

export type SupplierPaymentUpdateWithWhereUniqueWithoutPurchaseOrderInput = {
  data: SupplierPaymentUpdateWithoutPurchaseOrderInput;
  where: SupplierPaymentWhereUniqueInput;
};

export type SupplierPaymentUpdateWithWhereUniqueWithoutSupplierInput = {
  data: SupplierPaymentUpdateWithoutSupplierInput;
  where: SupplierPaymentWhereUniqueInput;
};

export type SupplierPaymentUpdateWithoutPurchaseOrderInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  paymentDate?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  supplier?: InputMaybe<SupplierUpdateOneRequiredWithoutPaymentsNestedInput>;
};

export type SupplierPaymentUpdateWithoutSupplierInput = {
  amount?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  method?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  paymentDate?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  purchaseOrder?: InputMaybe<PurchaseOrderUpdateOneWithoutPaymentsNestedInput>;
};

export type SupplierPaymentUpsertWithWhereUniqueWithoutPurchaseOrderInput = {
  create: SupplierPaymentCreateWithoutPurchaseOrderInput;
  update: SupplierPaymentUpdateWithoutPurchaseOrderInput;
  where: SupplierPaymentWhereUniqueInput;
};

export type SupplierPaymentUpsertWithWhereUniqueWithoutSupplierInput = {
  create: SupplierPaymentCreateWithoutSupplierInput;
  update: SupplierPaymentUpdateWithoutSupplierInput;
  where: SupplierPaymentWhereUniqueInput;
};

export type SupplierPaymentWhereInput = {
  AND?: InputMaybe<Array<SupplierPaymentWhereInput>>;
  NOT?: InputMaybe<Array<SupplierPaymentWhereInput>>;
  OR?: InputMaybe<Array<SupplierPaymentWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  id?: InputMaybe<StringFilter>;
  method?: InputMaybe<StringFilter>;
  notes?: InputMaybe<StringNullableFilter>;
  paymentDate?: InputMaybe<DateTimeFilter>;
  purchaseOrder?: InputMaybe<PurchaseOrderNullableScalarRelationFilter>;
  purchaseOrderId?: InputMaybe<StringNullableFilter>;
  supplier?: InputMaybe<SupplierScalarRelationFilter>;
  supplierId?: InputMaybe<StringFilter>;
};

export type SupplierPaymentWhereUniqueInput = {
  AND?: InputMaybe<Array<SupplierPaymentWhereInput>>;
  NOT?: InputMaybe<Array<SupplierPaymentWhereInput>>;
  OR?: InputMaybe<Array<SupplierPaymentWhereInput>>;
  amount?: InputMaybe<FloatFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  method?: InputMaybe<StringFilter>;
  notes?: InputMaybe<StringNullableFilter>;
  paymentDate?: InputMaybe<DateTimeFilter>;
  purchaseOrder?: InputMaybe<PurchaseOrderNullableScalarRelationFilter>;
  purchaseOrderId?: InputMaybe<StringNullableFilter>;
  supplier?: InputMaybe<SupplierScalarRelationFilter>;
  supplierId?: InputMaybe<StringFilter>;
};

export type SupplierPaymentsSummary = {
  __typename?: 'SupplierPaymentsSummary';
  count: Scalars['Float']['output'];
  lastPaymentDate?: Maybe<Scalars['DateTime']['output']>;
  month?: Maybe<Scalars['String']['output']>;
  supplierId: Scalars['String']['output'];
  totalPaid: Scalars['Float']['output'];
};

export type SupplierQuote = {
  __typename?: 'SupplierQuote';
  _count: SupplierQuoteCount;
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  items?: Maybe<Array<SupplierQuoteItem>>;
  notes?: Maybe<Scalars['String']['output']>;
  requisition: PurchaseRequisition;
  requisitionId: Scalars['String']['output'];
  status: SupplierQuoteStatus;
  supplier: Supplier;
  supplierId: Scalars['String']['output'];
  updatedAt: Scalars['DateTime']['output'];
  validUntil?: Maybe<Scalars['DateTime']['output']>;
};

export type SupplierQuoteCount = {
  __typename?: 'SupplierQuoteCount';
  items: Scalars['Int']['output'];
};

export type SupplierQuoteCreateManyRequisitionInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<SupplierQuoteStatus>;
  supplierId: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SupplierQuoteCreateManyRequisitionInputEnvelope = {
  data: Array<SupplierQuoteCreateManyRequisitionInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SupplierQuoteCreateManySupplierInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  requisitionId: Scalars['String']['input'];
  status?: InputMaybe<SupplierQuoteStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SupplierQuoteCreateManySupplierInputEnvelope = {
  data: Array<SupplierQuoteCreateManySupplierInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SupplierQuoteCreateNestedManyWithoutRequisitionInput = {
  connect?: InputMaybe<Array<SupplierQuoteWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierQuoteCreateOrConnectWithoutRequisitionInput>>;
  create?: InputMaybe<Array<SupplierQuoteCreateWithoutRequisitionInput>>;
  createMany?: InputMaybe<SupplierQuoteCreateManyRequisitionInputEnvelope>;
};

export type SupplierQuoteCreateNestedManyWithoutSupplierInput = {
  connect?: InputMaybe<Array<SupplierQuoteWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierQuoteCreateOrConnectWithoutSupplierInput>>;
  create?: InputMaybe<Array<SupplierQuoteCreateWithoutSupplierInput>>;
  createMany?: InputMaybe<SupplierQuoteCreateManySupplierInputEnvelope>;
};

export type SupplierQuoteCreateNestedOneWithoutItemsInput = {
  connect?: InputMaybe<SupplierQuoteWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierQuoteCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<SupplierQuoteCreateWithoutItemsInput>;
};

export type SupplierQuoteCreateOrConnectWithoutItemsInput = {
  create: SupplierQuoteCreateWithoutItemsInput;
  where: SupplierQuoteWhereUniqueInput;
};

export type SupplierQuoteCreateOrConnectWithoutRequisitionInput = {
  create: SupplierQuoteCreateWithoutRequisitionInput;
  where: SupplierQuoteWhereUniqueInput;
};

export type SupplierQuoteCreateOrConnectWithoutSupplierInput = {
  create: SupplierQuoteCreateWithoutSupplierInput;
  where: SupplierQuoteWhereUniqueInput;
};

export type SupplierQuoteCreateWithoutItemsInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  requisition: PurchaseRequisitionCreateNestedOneWithoutQuotesInput;
  status?: InputMaybe<SupplierQuoteStatus>;
  supplier: SupplierCreateNestedOneWithoutQuotesInput;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SupplierQuoteCreateWithoutRequisitionInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutQuoteInput>;
  notes?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<SupplierQuoteStatus>;
  supplier: SupplierCreateNestedOneWithoutQuotesInput;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SupplierQuoteCreateWithoutSupplierInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<SupplierQuoteItemCreateNestedManyWithoutQuoteInput>;
  notes?: InputMaybe<Scalars['String']['input']>;
  requisition: PurchaseRequisitionCreateNestedOneWithoutQuotesInput;
  status?: InputMaybe<SupplierQuoteStatus>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
  validUntil?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SupplierQuoteItem = {
  __typename?: 'SupplierQuoteItem';
  id: Scalars['ID']['output'];
  leadTimeDays?: Maybe<Scalars['Int']['output']>;
  minQty?: Maybe<Scalars['Int']['output']>;
  productVariant: ProductVariant;
  productVariantId: Scalars['String']['output'];
  quote: SupplierQuote;
  quoteId: Scalars['String']['output'];
  unitCost: Scalars['Float']['output'];
};

export type SupplierQuoteItemCreateManyProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  leadTimeDays?: InputMaybe<Scalars['Int']['input']>;
  minQty?: InputMaybe<Scalars['Int']['input']>;
  quoteId: Scalars['String']['input'];
  unitCost: Scalars['Float']['input'];
};

export type SupplierQuoteItemCreateManyProductVariantInputEnvelope = {
  data: Array<SupplierQuoteItemCreateManyProductVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SupplierQuoteItemCreateManyQuoteInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  leadTimeDays?: InputMaybe<Scalars['Int']['input']>;
  minQty?: InputMaybe<Scalars['Int']['input']>;
  productVariantId: Scalars['String']['input'];
  unitCost: Scalars['Float']['input'];
};

export type SupplierQuoteItemCreateManyQuoteInputEnvelope = {
  data: Array<SupplierQuoteItemCreateManyQuoteInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SupplierQuoteItemCreateNestedManyWithoutProductVariantInput = {
  connect?: InputMaybe<Array<SupplierQuoteItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierQuoteItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<SupplierQuoteItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<SupplierQuoteItemCreateManyProductVariantInputEnvelope>;
};

export type SupplierQuoteItemCreateNestedManyWithoutQuoteInput = {
  connect?: InputMaybe<Array<SupplierQuoteItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierQuoteItemCreateOrConnectWithoutQuoteInput>>;
  create?: InputMaybe<Array<SupplierQuoteItemCreateWithoutQuoteInput>>;
  createMany?: InputMaybe<SupplierQuoteItemCreateManyQuoteInputEnvelope>;
};

export type SupplierQuoteItemCreateOrConnectWithoutProductVariantInput = {
  create: SupplierQuoteItemCreateWithoutProductVariantInput;
  where: SupplierQuoteItemWhereUniqueInput;
};

export type SupplierQuoteItemCreateOrConnectWithoutQuoteInput = {
  create: SupplierQuoteItemCreateWithoutQuoteInput;
  where: SupplierQuoteItemWhereUniqueInput;
};

export type SupplierQuoteItemCreateWithoutProductVariantInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  leadTimeDays?: InputMaybe<Scalars['Int']['input']>;
  minQty?: InputMaybe<Scalars['Int']['input']>;
  quote: SupplierQuoteCreateNestedOneWithoutItemsInput;
  unitCost: Scalars['Float']['input'];
};

export type SupplierQuoteItemCreateWithoutQuoteInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  leadTimeDays?: InputMaybe<Scalars['Int']['input']>;
  minQty?: InputMaybe<Scalars['Int']['input']>;
  productVariant: ProductVariantCreateNestedOneWithoutSupplierQuoteItemInput;
  unitCost: Scalars['Float']['input'];
};

export type SupplierQuoteItemInput = {
  leadTimeDays?: InputMaybe<Scalars['Float']['input']>;
  minQty?: InputMaybe<Scalars['Float']['input']>;
  productVariantId: Scalars['String']['input'];
  unitCost: Scalars['Float']['input'];
};

export type SupplierQuoteItemListRelationFilter = {
  every?: InputMaybe<SupplierQuoteItemWhereInput>;
  none?: InputMaybe<SupplierQuoteItemWhereInput>;
  some?: InputMaybe<SupplierQuoteItemWhereInput>;
};

export type SupplierQuoteItemOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SupplierQuoteItemScalarWhereInput = {
  AND?: InputMaybe<Array<SupplierQuoteItemScalarWhereInput>>;
  NOT?: InputMaybe<Array<SupplierQuoteItemScalarWhereInput>>;
  OR?: InputMaybe<Array<SupplierQuoteItemScalarWhereInput>>;
  id?: InputMaybe<StringFilter>;
  leadTimeDays?: InputMaybe<IntNullableFilter>;
  minQty?: InputMaybe<IntNullableFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quoteId?: InputMaybe<StringFilter>;
  unitCost?: InputMaybe<FloatFilter>;
};

export type SupplierQuoteItemUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  leadTimeDays?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  minQty?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  unitCost?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type SupplierQuoteItemUpdateManyWithWhereWithoutProductVariantInput = {
  data: SupplierQuoteItemUpdateManyMutationInput;
  where: SupplierQuoteItemScalarWhereInput;
};

export type SupplierQuoteItemUpdateManyWithWhereWithoutQuoteInput = {
  data: SupplierQuoteItemUpdateManyMutationInput;
  where: SupplierQuoteItemScalarWhereInput;
};

export type SupplierQuoteItemUpdateManyWithoutProductVariantNestedInput = {
  connect?: InputMaybe<Array<SupplierQuoteItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierQuoteItemCreateOrConnectWithoutProductVariantInput>>;
  create?: InputMaybe<Array<SupplierQuoteItemCreateWithoutProductVariantInput>>;
  createMany?: InputMaybe<SupplierQuoteItemCreateManyProductVariantInputEnvelope>;
  delete?: InputMaybe<Array<SupplierQuoteItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SupplierQuoteItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SupplierQuoteItemWhereUniqueInput>>;
  set?: InputMaybe<Array<SupplierQuoteItemWhereUniqueInput>>;
  update?: InputMaybe<Array<SupplierQuoteItemUpdateWithWhereUniqueWithoutProductVariantInput>>;
  updateMany?: InputMaybe<Array<SupplierQuoteItemUpdateManyWithWhereWithoutProductVariantInput>>;
  upsert?: InputMaybe<Array<SupplierQuoteItemUpsertWithWhereUniqueWithoutProductVariantInput>>;
};

export type SupplierQuoteItemUpdateManyWithoutQuoteNestedInput = {
  connect?: InputMaybe<Array<SupplierQuoteItemWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierQuoteItemCreateOrConnectWithoutQuoteInput>>;
  create?: InputMaybe<Array<SupplierQuoteItemCreateWithoutQuoteInput>>;
  createMany?: InputMaybe<SupplierQuoteItemCreateManyQuoteInputEnvelope>;
  delete?: InputMaybe<Array<SupplierQuoteItemWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SupplierQuoteItemScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SupplierQuoteItemWhereUniqueInput>>;
  set?: InputMaybe<Array<SupplierQuoteItemWhereUniqueInput>>;
  update?: InputMaybe<Array<SupplierQuoteItemUpdateWithWhereUniqueWithoutQuoteInput>>;
  updateMany?: InputMaybe<Array<SupplierQuoteItemUpdateManyWithWhereWithoutQuoteInput>>;
  upsert?: InputMaybe<Array<SupplierQuoteItemUpsertWithWhereUniqueWithoutQuoteInput>>;
};

export type SupplierQuoteItemUpdateWithWhereUniqueWithoutProductVariantInput = {
  data: SupplierQuoteItemUpdateWithoutProductVariantInput;
  where: SupplierQuoteItemWhereUniqueInput;
};

export type SupplierQuoteItemUpdateWithWhereUniqueWithoutQuoteInput = {
  data: SupplierQuoteItemUpdateWithoutQuoteInput;
  where: SupplierQuoteItemWhereUniqueInput;
};

export type SupplierQuoteItemUpdateWithoutProductVariantInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  leadTimeDays?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  minQty?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  quote?: InputMaybe<SupplierQuoteUpdateOneRequiredWithoutItemsNestedInput>;
  unitCost?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type SupplierQuoteItemUpdateWithoutQuoteInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  leadTimeDays?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  minQty?: InputMaybe<NullableIntFieldUpdateOperationsInput>;
  productVariant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutSupplierQuoteItemNestedInput>;
  unitCost?: InputMaybe<FloatFieldUpdateOperationsInput>;
};

export type SupplierQuoteItemUpsertWithWhereUniqueWithoutProductVariantInput = {
  create: SupplierQuoteItemCreateWithoutProductVariantInput;
  update: SupplierQuoteItemUpdateWithoutProductVariantInput;
  where: SupplierQuoteItemWhereUniqueInput;
};

export type SupplierQuoteItemUpsertWithWhereUniqueWithoutQuoteInput = {
  create: SupplierQuoteItemCreateWithoutQuoteInput;
  update: SupplierQuoteItemUpdateWithoutQuoteInput;
  where: SupplierQuoteItemWhereUniqueInput;
};

export type SupplierQuoteItemWhereInput = {
  AND?: InputMaybe<Array<SupplierQuoteItemWhereInput>>;
  NOT?: InputMaybe<Array<SupplierQuoteItemWhereInput>>;
  OR?: InputMaybe<Array<SupplierQuoteItemWhereInput>>;
  id?: InputMaybe<StringFilter>;
  leadTimeDays?: InputMaybe<IntNullableFilter>;
  minQty?: InputMaybe<IntNullableFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quote?: InputMaybe<SupplierQuoteScalarRelationFilter>;
  quoteId?: InputMaybe<StringFilter>;
  unitCost?: InputMaybe<FloatFilter>;
};

export type SupplierQuoteItemWhereUniqueInput = {
  AND?: InputMaybe<Array<SupplierQuoteItemWhereInput>>;
  NOT?: InputMaybe<Array<SupplierQuoteItemWhereInput>>;
  OR?: InputMaybe<Array<SupplierQuoteItemWhereInput>>;
  id?: InputMaybe<Scalars['String']['input']>;
  leadTimeDays?: InputMaybe<IntNullableFilter>;
  minQty?: InputMaybe<IntNullableFilter>;
  productVariant?: InputMaybe<ProductVariantScalarRelationFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  quote?: InputMaybe<SupplierQuoteScalarRelationFilter>;
  quoteId?: InputMaybe<StringFilter>;
  unitCost?: InputMaybe<FloatFilter>;
};

export type SupplierQuoteListRelationFilter = {
  every?: InputMaybe<SupplierQuoteWhereInput>;
  none?: InputMaybe<SupplierQuoteWhereInput>;
  some?: InputMaybe<SupplierQuoteWhereInput>;
};

export type SupplierQuoteOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SupplierQuoteRequisitionIdSupplierIdCompoundUniqueInput = {
  requisitionId: Scalars['String']['input'];
  supplierId: Scalars['String']['input'];
};

export type SupplierQuoteScalarRelationFilter = {
  is?: InputMaybe<SupplierQuoteWhereInput>;
  isNot?: InputMaybe<SupplierQuoteWhereInput>;
};

export type SupplierQuoteScalarWhereInput = {
  AND?: InputMaybe<Array<SupplierQuoteScalarWhereInput>>;
  NOT?: InputMaybe<Array<SupplierQuoteScalarWhereInput>>;
  OR?: InputMaybe<Array<SupplierQuoteScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  notes?: InputMaybe<StringNullableFilter>;
  requisitionId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumSupplierQuoteStatusFilter>;
  supplierId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  validUntil?: InputMaybe<DateTimeNullableFilter>;
};

export enum SupplierQuoteStatus {
  Draft = 'DRAFT',
  Rejected = 'REJECTED',
  Selected = 'SELECTED',
  Submitted = 'SUBMITTED'
}

export type SupplierQuoteSummary = {
  __typename?: 'SupplierQuoteSummary';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  requisitionId: Scalars['String']['output'];
  status: Scalars['String']['output'];
  supplierId: Scalars['String']['output'];
  validUntil?: Maybe<Scalars['DateTime']['output']>;
};

export type SupplierQuoteUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSupplierQuoteStatusFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  validUntil?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
};

export type SupplierQuoteUpdateManyWithWhereWithoutRequisitionInput = {
  data: SupplierQuoteUpdateManyMutationInput;
  where: SupplierQuoteScalarWhereInput;
};

export type SupplierQuoteUpdateManyWithWhereWithoutSupplierInput = {
  data: SupplierQuoteUpdateManyMutationInput;
  where: SupplierQuoteScalarWhereInput;
};

export type SupplierQuoteUpdateManyWithoutRequisitionNestedInput = {
  connect?: InputMaybe<Array<SupplierQuoteWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierQuoteCreateOrConnectWithoutRequisitionInput>>;
  create?: InputMaybe<Array<SupplierQuoteCreateWithoutRequisitionInput>>;
  createMany?: InputMaybe<SupplierQuoteCreateManyRequisitionInputEnvelope>;
  delete?: InputMaybe<Array<SupplierQuoteWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SupplierQuoteScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SupplierQuoteWhereUniqueInput>>;
  set?: InputMaybe<Array<SupplierQuoteWhereUniqueInput>>;
  update?: InputMaybe<Array<SupplierQuoteUpdateWithWhereUniqueWithoutRequisitionInput>>;
  updateMany?: InputMaybe<Array<SupplierQuoteUpdateManyWithWhereWithoutRequisitionInput>>;
  upsert?: InputMaybe<Array<SupplierQuoteUpsertWithWhereUniqueWithoutRequisitionInput>>;
};

export type SupplierQuoteUpdateManyWithoutSupplierNestedInput = {
  connect?: InputMaybe<Array<SupplierQuoteWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierQuoteCreateOrConnectWithoutSupplierInput>>;
  create?: InputMaybe<Array<SupplierQuoteCreateWithoutSupplierInput>>;
  createMany?: InputMaybe<SupplierQuoteCreateManySupplierInputEnvelope>;
  delete?: InputMaybe<Array<SupplierQuoteWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SupplierQuoteScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SupplierQuoteWhereUniqueInput>>;
  set?: InputMaybe<Array<SupplierQuoteWhereUniqueInput>>;
  update?: InputMaybe<Array<SupplierQuoteUpdateWithWhereUniqueWithoutSupplierInput>>;
  updateMany?: InputMaybe<Array<SupplierQuoteUpdateManyWithWhereWithoutSupplierInput>>;
  upsert?: InputMaybe<Array<SupplierQuoteUpsertWithWhereUniqueWithoutSupplierInput>>;
};

export type SupplierQuoteUpdateOneRequiredWithoutItemsNestedInput = {
  connect?: InputMaybe<SupplierQuoteWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierQuoteCreateOrConnectWithoutItemsInput>;
  create?: InputMaybe<SupplierQuoteCreateWithoutItemsInput>;
  update?: InputMaybe<SupplierQuoteUpdateToOneWithWhereWithoutItemsInput>;
  upsert?: InputMaybe<SupplierQuoteUpsertWithoutItemsInput>;
};

export type SupplierQuoteUpdateToOneWithWhereWithoutItemsInput = {
  data: SupplierQuoteUpdateWithoutItemsInput;
  where?: InputMaybe<SupplierQuoteWhereInput>;
};

export type SupplierQuoteUpdateWithWhereUniqueWithoutRequisitionInput = {
  data: SupplierQuoteUpdateWithoutRequisitionInput;
  where: SupplierQuoteWhereUniqueInput;
};

export type SupplierQuoteUpdateWithWhereUniqueWithoutSupplierInput = {
  data: SupplierQuoteUpdateWithoutSupplierInput;
  where: SupplierQuoteWhereUniqueInput;
};

export type SupplierQuoteUpdateWithoutItemsInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  requisition?: InputMaybe<PurchaseRequisitionUpdateOneRequiredWithoutQuotesNestedInput>;
  status?: InputMaybe<EnumSupplierQuoteStatusFieldUpdateOperationsInput>;
  supplier?: InputMaybe<SupplierUpdateOneRequiredWithoutQuotesNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  validUntil?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
};

export type SupplierQuoteUpdateWithoutRequisitionInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<SupplierQuoteItemUpdateManyWithoutQuoteNestedInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  status?: InputMaybe<EnumSupplierQuoteStatusFieldUpdateOperationsInput>;
  supplier?: InputMaybe<SupplierUpdateOneRequiredWithoutQuotesNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  validUntil?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
};

export type SupplierQuoteUpdateWithoutSupplierInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  items?: InputMaybe<SupplierQuoteItemUpdateManyWithoutQuoteNestedInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  requisition?: InputMaybe<PurchaseRequisitionUpdateOneRequiredWithoutQuotesNestedInput>;
  status?: InputMaybe<EnumSupplierQuoteStatusFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  validUntil?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
};

export type SupplierQuoteUpsertWithWhereUniqueWithoutRequisitionInput = {
  create: SupplierQuoteCreateWithoutRequisitionInput;
  update: SupplierQuoteUpdateWithoutRequisitionInput;
  where: SupplierQuoteWhereUniqueInput;
};

export type SupplierQuoteUpsertWithWhereUniqueWithoutSupplierInput = {
  create: SupplierQuoteCreateWithoutSupplierInput;
  update: SupplierQuoteUpdateWithoutSupplierInput;
  where: SupplierQuoteWhereUniqueInput;
};

export type SupplierQuoteUpsertWithoutItemsInput = {
  create: SupplierQuoteCreateWithoutItemsInput;
  update: SupplierQuoteUpdateWithoutItemsInput;
  where?: InputMaybe<SupplierQuoteWhereInput>;
};

export type SupplierQuoteWhereInput = {
  AND?: InputMaybe<Array<SupplierQuoteWhereInput>>;
  NOT?: InputMaybe<Array<SupplierQuoteWhereInput>>;
  OR?: InputMaybe<Array<SupplierQuoteWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  items?: InputMaybe<SupplierQuoteItemListRelationFilter>;
  notes?: InputMaybe<StringNullableFilter>;
  requisition?: InputMaybe<PurchaseRequisitionScalarRelationFilter>;
  requisitionId?: InputMaybe<StringFilter>;
  status?: InputMaybe<EnumSupplierQuoteStatusFilter>;
  supplier?: InputMaybe<SupplierScalarRelationFilter>;
  supplierId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  validUntil?: InputMaybe<DateTimeNullableFilter>;
};

export type SupplierQuoteWhereUniqueInput = {
  AND?: InputMaybe<Array<SupplierQuoteWhereInput>>;
  NOT?: InputMaybe<Array<SupplierQuoteWhereInput>>;
  OR?: InputMaybe<Array<SupplierQuoteWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  items?: InputMaybe<SupplierQuoteItemListRelationFilter>;
  notes?: InputMaybe<StringNullableFilter>;
  requisition?: InputMaybe<PurchaseRequisitionScalarRelationFilter>;
  requisitionId?: InputMaybe<StringFilter>;
  requisitionId_supplierId?: InputMaybe<SupplierQuoteRequisitionIdSupplierIdCompoundUniqueInput>;
  status?: InputMaybe<EnumSupplierQuoteStatusFilter>;
  supplier?: InputMaybe<SupplierScalarRelationFilter>;
  supplierId?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  validUntil?: InputMaybe<DateTimeNullableFilter>;
};

export enum SupplierScalarFieldEnum {
  ContactInfo = 'contactInfo',
  CreatedAt = 'createdAt',
  CreditLimit = 'creditLimit',
  CurrentBalance = 'currentBalance',
  Id = 'id',
  IsFrequent = 'isFrequent',
  Name = 'name',
  Notes = 'notes',
  PaymentTerms = 'paymentTerms',
  UpdatedAt = 'updatedAt',
  UserId = 'userId'
}

export type SupplierScalarRelationFilter = {
  is?: InputMaybe<SupplierWhereInput>;
  isNot?: InputMaybe<SupplierWhereInput>;
};

export type SupplierScalarWhereInput = {
  AND?: InputMaybe<Array<SupplierScalarWhereInput>>;
  NOT?: InputMaybe<Array<SupplierScalarWhereInput>>;
  OR?: InputMaybe<Array<SupplierScalarWhereInput>>;
  contactInfo?: InputMaybe<JsonNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  creditLimit?: InputMaybe<FloatFilter>;
  currentBalance?: InputMaybe<FloatFilter>;
  id?: InputMaybe<StringFilter>;
  isFrequent?: InputMaybe<BoolFilter>;
  name?: InputMaybe<StringFilter>;
  notes?: InputMaybe<StringNullableFilter>;
  paymentTerms?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  userId?: InputMaybe<StringNullableFilter>;
};

export type SupplierSumAggregate = {
  __typename?: 'SupplierSumAggregate';
  creditLimit?: Maybe<Scalars['Float']['output']>;
  currentBalance?: Maybe<Scalars['Float']['output']>;
};

export type SupplierUpdateManyMutationInput = {
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  creditLimit?: InputMaybe<FloatFieldUpdateOperationsInput>;
  currentBalance?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isFrequent?: InputMaybe<BoolFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  paymentTerms?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SupplierUpdateManyWithWhereWithoutUserInput = {
  data: SupplierUpdateManyMutationInput;
  where: SupplierScalarWhereInput;
};

export type SupplierUpdateManyWithoutUserNestedInput = {
  connect?: InputMaybe<Array<SupplierWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupplierCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<SupplierCreateWithoutUserInput>>;
  createMany?: InputMaybe<SupplierCreateManyUserInputEnvelope>;
  delete?: InputMaybe<Array<SupplierWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SupplierScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SupplierWhereUniqueInput>>;
  set?: InputMaybe<Array<SupplierWhereUniqueInput>>;
  update?: InputMaybe<Array<SupplierUpdateWithWhereUniqueWithoutUserInput>>;
  updateMany?: InputMaybe<Array<SupplierUpdateManyWithWhereWithoutUserInput>>;
  upsert?: InputMaybe<Array<SupplierUpsertWithWhereUniqueWithoutUserInput>>;
};

export type SupplierUpdateOneRequiredWithoutCatalogsNestedInput = {
  connect?: InputMaybe<SupplierWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierCreateOrConnectWithoutCatalogsInput>;
  create?: InputMaybe<SupplierCreateWithoutCatalogsInput>;
  update?: InputMaybe<SupplierUpdateToOneWithWhereWithoutCatalogsInput>;
  upsert?: InputMaybe<SupplierUpsertWithoutCatalogsInput>;
};

export type SupplierUpdateOneRequiredWithoutPaymentsNestedInput = {
  connect?: InputMaybe<SupplierWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierCreateOrConnectWithoutPaymentsInput>;
  create?: InputMaybe<SupplierCreateWithoutPaymentsInput>;
  update?: InputMaybe<SupplierUpdateToOneWithWhereWithoutPaymentsInput>;
  upsert?: InputMaybe<SupplierUpsertWithoutPaymentsInput>;
};

export type SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
  connect?: InputMaybe<SupplierWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierCreateOrConnectWithoutPurchaseOrdersInput>;
  create?: InputMaybe<SupplierCreateWithoutPurchaseOrdersInput>;
  update?: InputMaybe<SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput>;
  upsert?: InputMaybe<SupplierUpsertWithoutPurchaseOrdersInput>;
};

export type SupplierUpdateOneRequiredWithoutQuotesNestedInput = {
  connect?: InputMaybe<SupplierWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierCreateOrConnectWithoutQuotesInput>;
  create?: InputMaybe<SupplierCreateWithoutQuotesInput>;
  update?: InputMaybe<SupplierUpdateToOneWithWhereWithoutQuotesInput>;
  upsert?: InputMaybe<SupplierUpsertWithoutQuotesInput>;
};

export type SupplierUpdateOneRequiredWithoutReturnsNestedInput = {
  connect?: InputMaybe<SupplierWhereUniqueInput>;
  connectOrCreate?: InputMaybe<SupplierCreateOrConnectWithoutReturnsInput>;
  create?: InputMaybe<SupplierCreateWithoutReturnsInput>;
  update?: InputMaybe<SupplierUpdateToOneWithWhereWithoutReturnsInput>;
  upsert?: InputMaybe<SupplierUpsertWithoutReturnsInput>;
};

export type SupplierUpdateToOneWithWhereWithoutCatalogsInput = {
  data: SupplierUpdateWithoutCatalogsInput;
  where?: InputMaybe<SupplierWhereInput>;
};

export type SupplierUpdateToOneWithWhereWithoutPaymentsInput = {
  data: SupplierUpdateWithoutPaymentsInput;
  where?: InputMaybe<SupplierWhereInput>;
};

export type SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
  data: SupplierUpdateWithoutPurchaseOrdersInput;
  where?: InputMaybe<SupplierWhereInput>;
};

export type SupplierUpdateToOneWithWhereWithoutQuotesInput = {
  data: SupplierUpdateWithoutQuotesInput;
  where?: InputMaybe<SupplierWhereInput>;
};

export type SupplierUpdateToOneWithWhereWithoutReturnsInput = {
  data: SupplierUpdateWithoutReturnsInput;
  where?: InputMaybe<SupplierWhereInput>;
};

export type SupplierUpdateWithWhereUniqueWithoutUserInput = {
  data: SupplierUpdateWithoutUserInput;
  where: SupplierWhereUniqueInput;
};

export type SupplierUpdateWithoutCatalogsInput = {
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  creditLimit?: InputMaybe<FloatFieldUpdateOperationsInput>;
  currentBalance?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isFrequent?: InputMaybe<BoolFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  paymentTerms?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  payments?: InputMaybe<SupplierPaymentUpdateManyWithoutSupplierNestedInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutSupplierNestedInput>;
  quotes?: InputMaybe<SupplierQuoteUpdateManyWithoutSupplierNestedInput>;
  returns?: InputMaybe<PurchaseReturnUpdateManyWithoutSupplierNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneWithoutSupplierNestedInput>;
};

export type SupplierUpdateWithoutPaymentsInput = {
  catalogs?: InputMaybe<SupplierCatalogUpdateManyWithoutSupplierNestedInput>;
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  creditLimit?: InputMaybe<FloatFieldUpdateOperationsInput>;
  currentBalance?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isFrequent?: InputMaybe<BoolFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  paymentTerms?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutSupplierNestedInput>;
  quotes?: InputMaybe<SupplierQuoteUpdateManyWithoutSupplierNestedInput>;
  returns?: InputMaybe<PurchaseReturnUpdateManyWithoutSupplierNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneWithoutSupplierNestedInput>;
};

export type SupplierUpdateWithoutPurchaseOrdersInput = {
  catalogs?: InputMaybe<SupplierCatalogUpdateManyWithoutSupplierNestedInput>;
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  creditLimit?: InputMaybe<FloatFieldUpdateOperationsInput>;
  currentBalance?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isFrequent?: InputMaybe<BoolFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  paymentTerms?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  payments?: InputMaybe<SupplierPaymentUpdateManyWithoutSupplierNestedInput>;
  quotes?: InputMaybe<SupplierQuoteUpdateManyWithoutSupplierNestedInput>;
  returns?: InputMaybe<PurchaseReturnUpdateManyWithoutSupplierNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneWithoutSupplierNestedInput>;
};

export type SupplierUpdateWithoutQuotesInput = {
  catalogs?: InputMaybe<SupplierCatalogUpdateManyWithoutSupplierNestedInput>;
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  creditLimit?: InputMaybe<FloatFieldUpdateOperationsInput>;
  currentBalance?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isFrequent?: InputMaybe<BoolFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  paymentTerms?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  payments?: InputMaybe<SupplierPaymentUpdateManyWithoutSupplierNestedInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutSupplierNestedInput>;
  returns?: InputMaybe<PurchaseReturnUpdateManyWithoutSupplierNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneWithoutSupplierNestedInput>;
};

export type SupplierUpdateWithoutReturnsInput = {
  catalogs?: InputMaybe<SupplierCatalogUpdateManyWithoutSupplierNestedInput>;
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  creditLimit?: InputMaybe<FloatFieldUpdateOperationsInput>;
  currentBalance?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isFrequent?: InputMaybe<BoolFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  paymentTerms?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  payments?: InputMaybe<SupplierPaymentUpdateManyWithoutSupplierNestedInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutSupplierNestedInput>;
  quotes?: InputMaybe<SupplierQuoteUpdateManyWithoutSupplierNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  user?: InputMaybe<UserUpdateOneWithoutSupplierNestedInput>;
};

export type SupplierUpdateWithoutUserInput = {
  catalogs?: InputMaybe<SupplierCatalogUpdateManyWithoutSupplierNestedInput>;
  contactInfo?: InputMaybe<Scalars['JSON']['input']>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  creditLimit?: InputMaybe<FloatFieldUpdateOperationsInput>;
  currentBalance?: InputMaybe<FloatFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isFrequent?: InputMaybe<BoolFieldUpdateOperationsInput>;
  name?: InputMaybe<StringFieldUpdateOperationsInput>;
  notes?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  paymentTerms?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  payments?: InputMaybe<SupplierPaymentUpdateManyWithoutSupplierNestedInput>;
  purchaseOrders?: InputMaybe<PurchaseOrderUpdateManyWithoutSupplierNestedInput>;
  quotes?: InputMaybe<SupplierQuoteUpdateManyWithoutSupplierNestedInput>;
  returns?: InputMaybe<PurchaseReturnUpdateManyWithoutSupplierNestedInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type SupplierUpsertWithWhereUniqueWithoutUserInput = {
  create: SupplierCreateWithoutUserInput;
  update: SupplierUpdateWithoutUserInput;
  where: SupplierWhereUniqueInput;
};

export type SupplierUpsertWithoutCatalogsInput = {
  create: SupplierCreateWithoutCatalogsInput;
  update: SupplierUpdateWithoutCatalogsInput;
  where?: InputMaybe<SupplierWhereInput>;
};

export type SupplierUpsertWithoutPaymentsInput = {
  create: SupplierCreateWithoutPaymentsInput;
  update: SupplierUpdateWithoutPaymentsInput;
  where?: InputMaybe<SupplierWhereInput>;
};

export type SupplierUpsertWithoutPurchaseOrdersInput = {
  create: SupplierCreateWithoutPurchaseOrdersInput;
  update: SupplierUpdateWithoutPurchaseOrdersInput;
  where?: InputMaybe<SupplierWhereInput>;
};

export type SupplierUpsertWithoutQuotesInput = {
  create: SupplierCreateWithoutQuotesInput;
  update: SupplierUpdateWithoutQuotesInput;
  where?: InputMaybe<SupplierWhereInput>;
};

export type SupplierUpsertWithoutReturnsInput = {
  create: SupplierCreateWithoutReturnsInput;
  update: SupplierUpdateWithoutReturnsInput;
  where?: InputMaybe<SupplierWhereInput>;
};

export type SupplierWhereInput = {
  AND?: InputMaybe<Array<SupplierWhereInput>>;
  NOT?: InputMaybe<Array<SupplierWhereInput>>;
  OR?: InputMaybe<Array<SupplierWhereInput>>;
  catalogs?: InputMaybe<SupplierCatalogListRelationFilter>;
  contactInfo?: InputMaybe<JsonNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  creditLimit?: InputMaybe<FloatFilter>;
  currentBalance?: InputMaybe<FloatFilter>;
  id?: InputMaybe<StringFilter>;
  isFrequent?: InputMaybe<BoolFilter>;
  name?: InputMaybe<StringFilter>;
  notes?: InputMaybe<StringNullableFilter>;
  paymentTerms?: InputMaybe<StringNullableFilter>;
  payments?: InputMaybe<SupplierPaymentListRelationFilter>;
  purchaseOrders?: InputMaybe<PurchaseOrderListRelationFilter>;
  quotes?: InputMaybe<SupplierQuoteListRelationFilter>;
  returns?: InputMaybe<PurchaseReturnListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserNullableScalarRelationFilter>;
  userId?: InputMaybe<StringNullableFilter>;
};

export type SupplierWhereUniqueInput = {
  AND?: InputMaybe<Array<SupplierWhereInput>>;
  NOT?: InputMaybe<Array<SupplierWhereInput>>;
  OR?: InputMaybe<Array<SupplierWhereInput>>;
  catalogs?: InputMaybe<SupplierCatalogListRelationFilter>;
  contactInfo?: InputMaybe<JsonNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  creditLimit?: InputMaybe<FloatFilter>;
  currentBalance?: InputMaybe<FloatFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  isFrequent?: InputMaybe<BoolFilter>;
  name?: InputMaybe<StringFilter>;
  notes?: InputMaybe<StringNullableFilter>;
  paymentTerms?: InputMaybe<StringNullableFilter>;
  payments?: InputMaybe<SupplierPaymentListRelationFilter>;
  purchaseOrders?: InputMaybe<PurchaseOrderListRelationFilter>;
  quotes?: InputMaybe<SupplierQuoteListRelationFilter>;
  returns?: InputMaybe<PurchaseReturnListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserNullableScalarRelationFilter>;
  userId?: InputMaybe<StringNullableFilter>;
};

export type SupportMessage = {
  __typename?: 'SupportMessage';
  createdAt: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  isAdmin: Scalars['Boolean']['output'];
  message: Scalars['String']['output'];
  user: User;
  userId: Scalars['String']['output'];
};

export type SupportMessageCreateManyUserInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  message: Scalars['String']['input'];
};

export type SupportMessageCreateManyUserInputEnvelope = {
  data: Array<SupportMessageCreateManyUserInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type SupportMessageCreateNestedManyWithoutUserInput = {
  connect?: InputMaybe<Array<SupportMessageWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupportMessageCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<SupportMessageCreateWithoutUserInput>>;
  createMany?: InputMaybe<SupportMessageCreateManyUserInputEnvelope>;
};

export type SupportMessageCreateOrConnectWithoutUserInput = {
  create: SupportMessageCreateWithoutUserInput;
  where: SupportMessageWhereUniqueInput;
};

export type SupportMessageCreateWithoutUserInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  message: Scalars['String']['input'];
};

export type SupportMessageListRelationFilter = {
  every?: InputMaybe<SupportMessageWhereInput>;
  none?: InputMaybe<SupportMessageWhereInput>;
  some?: InputMaybe<SupportMessageWhereInput>;
};

export type SupportMessageOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type SupportMessageScalarWhereInput = {
  AND?: InputMaybe<Array<SupportMessageScalarWhereInput>>;
  NOT?: InputMaybe<Array<SupportMessageScalarWhereInput>>;
  OR?: InputMaybe<Array<SupportMessageScalarWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  isAdmin?: InputMaybe<BoolFilter>;
  message?: InputMaybe<StringFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type SupportMessageUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isAdmin?: InputMaybe<BoolFieldUpdateOperationsInput>;
  message?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type SupportMessageUpdateManyWithWhereWithoutUserInput = {
  data: SupportMessageUpdateManyMutationInput;
  where: SupportMessageScalarWhereInput;
};

export type SupportMessageUpdateManyWithoutUserNestedInput = {
  connect?: InputMaybe<Array<SupportMessageWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<SupportMessageCreateOrConnectWithoutUserInput>>;
  create?: InputMaybe<Array<SupportMessageCreateWithoutUserInput>>;
  createMany?: InputMaybe<SupportMessageCreateManyUserInputEnvelope>;
  delete?: InputMaybe<Array<SupportMessageWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<SupportMessageScalarWhereInput>>;
  disconnect?: InputMaybe<Array<SupportMessageWhereUniqueInput>>;
  set?: InputMaybe<Array<SupportMessageWhereUniqueInput>>;
  update?: InputMaybe<Array<SupportMessageUpdateWithWhereUniqueWithoutUserInput>>;
  updateMany?: InputMaybe<Array<SupportMessageUpdateManyWithWhereWithoutUserInput>>;
  upsert?: InputMaybe<Array<SupportMessageUpsertWithWhereUniqueWithoutUserInput>>;
};

export type SupportMessageUpdateWithWhereUniqueWithoutUserInput = {
  data: SupportMessageUpdateWithoutUserInput;
  where: SupportMessageWhereUniqueInput;
};

export type SupportMessageUpdateWithoutUserInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isAdmin?: InputMaybe<BoolFieldUpdateOperationsInput>;
  message?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type SupportMessageUpsertWithWhereUniqueWithoutUserInput = {
  create: SupportMessageCreateWithoutUserInput;
  update: SupportMessageUpdateWithoutUserInput;
  where: SupportMessageWhereUniqueInput;
};

export type SupportMessageWhereInput = {
  AND?: InputMaybe<Array<SupportMessageWhereInput>>;
  NOT?: InputMaybe<Array<SupportMessageWhereInput>>;
  OR?: InputMaybe<Array<SupportMessageWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<StringFilter>;
  isAdmin?: InputMaybe<BoolFilter>;
  message?: InputMaybe<StringFilter>;
  user?: InputMaybe<UserScalarRelationFilter>;
  userId?: InputMaybe<StringFilter>;
};

export type SupportMessageWhereUniqueInput = {
  AND?: InputMaybe<Array<SupportMessageWhereInput>>;
  NOT?: InputMaybe<Array<SupportMessageWhereInput>>;
  OR?: InputMaybe<Array<SupportMessageWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  isAdmin?: InputMaybe<BoolFilter>;
  message?: InputMaybe<StringFilter>;
  user?: InputMaybe<UserScalarRelationFilter>;
  userId?: InputMaybe<StringFilter>;
};

export enum TransferStatus {
  Approved = 'APPROVED',
  Completed = 'COMPLETED',
  Pending = 'PENDING',
  Rejected = 'REJECTED'
}

export type TransferStockInput = {
  approvedById: Scalars['ID']['input'];
  fromStoreId: Scalars['ID']['input'];
  items: Array<TransferStockItemInput>;
  requestedById: Scalars['ID']['input'];
  toStoreId: Scalars['ID']['input'];
};

export type TransferStockItemInput = {
  productVariantId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
};

export type UnlinkVariantFromProductInput = {
  variantId: Scalars['ID']['input'];
};

export type UpdateCollectionInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  filters?: InputMaybe<Array<FacetFilterInput>>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateCustomerProfileInput = {
  birthday?: InputMaybe<Scalars['DateTime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  gender?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  preferredStoreId?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateFacetInput = {
  id: Scalars['ID']['input'];
  isPrivate?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type UpdateFulfillmentStatusInput = {
  confirmationPin?: InputMaybe<Scalars['String']['input']>;
  saleOrderId: Scalars['String']['input'];
  status: FulfillmentStatus;
};

export type UpdateInvoiceImportInput = {
  id: Scalars['String']['input'];
  invoiceNumber?: InputMaybe<Scalars['String']['input']>;
  storeId?: InputMaybe<Scalars['String']['input']>;
  supplierName?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type UpdatePurchaseOrderPhaseInput = {
  id: Scalars['String']['input'];
  phase: Scalars['String']['input'];
};

export type UpdatePurchaseOrderStatusInput = {
  id: Scalars['String']['input'];
  status: PurchaseOrderStatus;
};

export type UpdateQuotationStatusInput = {
  id: Scalars['String']['input'];
  status: QuotationStatus;
};

export type UpdateSalesReturnStatusInput = {
  approvedById?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['String']['input'];
  status: ReturnStatus;
};

export type UpdateSupplierInput = {
  contactInfo?: InputMaybe<Scalars['String']['input']>;
  creditLimit?: InputMaybe<Scalars['Float']['input']>;
  id: Scalars['ID']['input'];
  isFrequent?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  paymentTerms?: InputMaybe<Scalars['String']['input']>;
};

export type UpsertSupplierCatalogBulkInput = {
  items: Array<UpsertSupplierCatalogInput>;
};

export type UpsertSupplierCatalogInput = {
  defaultCost: Scalars['Float']['input'];
  isPreferred?: InputMaybe<Scalars['Boolean']['input']>;
  leadTimeDays?: InputMaybe<Scalars['Float']['input']>;
  productVariantId: Scalars['String']['input'];
  supplierId: Scalars['String']['input'];
};

export type UpsertVariantSupplierCatalogInput = {
  defaultCost: Scalars['Float']['input'];
  isPreferred?: InputMaybe<Scalars['Boolean']['input']>;
  leadTimeDays?: InputMaybe<Scalars['Float']['input']>;
  productVariantId: Scalars['String']['input'];
  supplierId: Scalars['String']['input'];
};

export type UpsertVariantTierPriceInput = {
  price: Scalars['Float']['input'];
  productVariantId: Scalars['String']['input'];
  tier: UserTier;
};

export type User = {
  __typename?: 'User';
  BillerQuotation?: Maybe<Array<Quotation>>;
  BillerResellerSale?: Maybe<Array<ResellerSale>>;
  ConsumerReceipt?: Maybe<Array<ConsumerReceipt>>;
  ConsumerSale?: Maybe<Array<ConsumerSale>>;
  ConsumerSaleAdjustedBys?: Maybe<Array<ConsumerSale>>;
  Fulfillment?: Maybe<Array<Fulfillment>>;
  Notification?: Maybe<Array<Notification>>;
  Payment?: Maybe<Array<Payment>>;
  PurchaseRequisition?: Maybe<Array<PurchaseRequisition>>;
  PurchaseReturnApprovers?: Maybe<Array<PurchaseReturn>>;
  PurchaseReturnInitiators?: Maybe<Array<PurchaseReturn>>;
  RequestedResellers?: Maybe<Array<ResellerProfile>>;
  ResellerProfile?: Maybe<Array<ResellerProfile>>;
  ResellerQuotation?: Maybe<Array<Quotation>>;
  ResellerSale?: Maybe<Array<ResellerSale>>;
  ResellerSales?: Maybe<Array<ResellerSale>>;
  ResellerTierHistory?: Maybe<Array<ResellerTierHistory>>;
  ResellerTierHistoryChangedBys?: Maybe<Array<ResellerTierHistory>>;
  SalesReturn?: Maybe<Array<SalesReturn>>;
  SalesReturnReceivers?: Maybe<Array<SalesReturn>>;
  SalesReturnRequesters?: Maybe<Array<SalesReturn>>;
  StockReceiptBatchConfirmedBys?: Maybe<Array<StockReceiptBatch>>;
  StockReceiptBatchReceivedBys?: Maybe<Array<StockReceiptBatch>>;
  StockTransferApprovals?: Maybe<Array<StockTransfer>>;
  StockTransferRequests?: Maybe<Array<StockTransfer>>;
  Store?: Maybe<Array<Store>>;
  Supplier?: Maybe<Array<Supplier>>;
  _count: UserCount;
  adminLogs?: Maybe<Array<AdminActionLog>>;
  createdAt: Scalars['DateTime']['output'];
  customerProfile?: Maybe<CustomerProfile>;
  email: Scalars['String']['output'];
  emailVerificationToken?: Maybe<Scalars['String']['output']>;
  emailVerificationTokenExpiry?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  isEmailVerified: Scalars['Boolean']['output'];
  passwordHash: Scalars['String']['output'];
  referralCode?: Maybe<Scalars['String']['output']>;
  referredBy?: Maybe<Scalars['String']['output']>;
  resellerPaymentsMade?: Maybe<Array<ResellerPayment>>;
  resellerPaymentsReceived?: Maybe<Array<ResellerPayment>>;
  resellerProfile?: Maybe<ResellerProfile>;
  role: Role;
  roleId: Scalars['String']['output'];
  supportMessages?: Maybe<Array<SupportMessage>>;
  tier?: Maybe<UserTier>;
  updatedAt: Scalars['DateTime']['output'];
};

export type UserCount = {
  __typename?: 'UserCount';
  BillerQuotation: Scalars['Int']['output'];
  BillerResellerSale: Scalars['Int']['output'];
  ConsumerReceipt: Scalars['Int']['output'];
  ConsumerSale: Scalars['Int']['output'];
  ConsumerSaleAdjustedBys: Scalars['Int']['output'];
  Fulfillment: Scalars['Int']['output'];
  Notification: Scalars['Int']['output'];
  Payment: Scalars['Int']['output'];
  PurchaseRequisition: Scalars['Int']['output'];
  PurchaseReturnApprovers: Scalars['Int']['output'];
  PurchaseReturnInitiators: Scalars['Int']['output'];
  RequestedResellers: Scalars['Int']['output'];
  ResellerProfile: Scalars['Int']['output'];
  ResellerQuotation: Scalars['Int']['output'];
  ResellerSale: Scalars['Int']['output'];
  ResellerSales: Scalars['Int']['output'];
  ResellerTierHistory: Scalars['Int']['output'];
  ResellerTierHistoryChangedBys: Scalars['Int']['output'];
  SalesReturn: Scalars['Int']['output'];
  SalesReturnReceivers: Scalars['Int']['output'];
  SalesReturnRequesters: Scalars['Int']['output'];
  StockReceiptBatchConfirmedBys: Scalars['Int']['output'];
  StockReceiptBatchReceivedBys: Scalars['Int']['output'];
  StockTransferApprovals: Scalars['Int']['output'];
  StockTransferRequests: Scalars['Int']['output'];
  Store: Scalars['Int']['output'];
  Supplier: Scalars['Int']['output'];
  adminLogs: Scalars['Int']['output'];
  resellerPaymentsMade: Scalars['Int']['output'];
  resellerPaymentsReceived: Scalars['Int']['output'];
  supportMessages: Scalars['Int']['output'];
};

export type UserCountAggregate = {
  __typename?: 'UserCountAggregate';
  _all: Scalars['Int']['output'];
  createdAt: Scalars['Int']['output'];
  email: Scalars['Int']['output'];
  emailVerificationToken: Scalars['Int']['output'];
  emailVerificationTokenExpiry: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isEmailVerified: Scalars['Int']['output'];
  passwordHash: Scalars['Int']['output'];
  referralCode: Scalars['Int']['output'];
  referredBy: Scalars['Int']['output'];
  roleId: Scalars['Int']['output'];
  tier: Scalars['Int']['output'];
  updatedAt: Scalars['Int']['output'];
};

export type UserCountAggregateInput = {
  _all?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  email?: InputMaybe<Scalars['Boolean']['input']>;
  emailVerificationToken?: InputMaybe<Scalars['Boolean']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash?: InputMaybe<Scalars['Boolean']['input']>;
  referralCode?: InputMaybe<Scalars['Boolean']['input']>;
  referredBy?: InputMaybe<Scalars['Boolean']['input']>;
  roleId?: InputMaybe<Scalars['Boolean']['input']>;
  tier?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UserCountOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerificationToken?: InputMaybe<SortOrder>;
  emailVerificationTokenExpiry?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isEmailVerified?: InputMaybe<SortOrder>;
  passwordHash?: InputMaybe<SortOrder>;
  referralCode?: InputMaybe<SortOrder>;
  referredBy?: InputMaybe<SortOrder>;
  roleId?: InputMaybe<SortOrder>;
  tier?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type UserCreateInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateManyInput = {
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  roleId: Scalars['String']['input'];
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateNestedOneWithoutBillerQuotationInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutBillerQuotationInput>;
  create?: InputMaybe<UserCreateWithoutBillerQuotationInput>;
};

export type UserCreateNestedOneWithoutBillerResellerSaleInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutBillerResellerSaleInput>;
  create?: InputMaybe<UserCreateWithoutBillerResellerSaleInput>;
};

export type UserCreateNestedOneWithoutConsumerReceiptInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutConsumerReceiptInput>;
  create?: InputMaybe<UserCreateWithoutConsumerReceiptInput>;
};

export type UserCreateNestedOneWithoutConsumerSaleAdjustedBysInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutConsumerSaleAdjustedBysInput>;
  create?: InputMaybe<UserCreateWithoutConsumerSaleAdjustedBysInput>;
};

export type UserCreateNestedOneWithoutConsumerSaleInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutConsumerSaleInput>;
  create?: InputMaybe<UserCreateWithoutConsumerSaleInput>;
};

export type UserCreateNestedOneWithoutCustomerProfileInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutCustomerProfileInput>;
  create?: InputMaybe<UserCreateWithoutCustomerProfileInput>;
};

export type UserCreateNestedOneWithoutFulfillmentInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutFulfillmentInput>;
  create?: InputMaybe<UserCreateWithoutFulfillmentInput>;
};

export type UserCreateNestedOneWithoutPurchaseRequisitionInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutPurchaseRequisitionInput>;
  create?: InputMaybe<UserCreateWithoutPurchaseRequisitionInput>;
};

export type UserCreateNestedOneWithoutPurchaseReturnApproversInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutPurchaseReturnApproversInput>;
  create?: InputMaybe<UserCreateWithoutPurchaseReturnApproversInput>;
};

export type UserCreateNestedOneWithoutPurchaseReturnInitiatorsInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutPurchaseReturnInitiatorsInput>;
  create?: InputMaybe<UserCreateWithoutPurchaseReturnInitiatorsInput>;
};

export type UserCreateNestedOneWithoutRequestedResellersInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutRequestedResellersInput>;
  create?: InputMaybe<UserCreateWithoutRequestedResellersInput>;
};

export type UserCreateNestedOneWithoutResellerPaymentsMadeInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerPaymentsMadeInput>;
  create?: InputMaybe<UserCreateWithoutResellerPaymentsMadeInput>;
};

export type UserCreateNestedOneWithoutResellerPaymentsReceivedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerPaymentsReceivedInput>;
  create?: InputMaybe<UserCreateWithoutResellerPaymentsReceivedInput>;
};

export type UserCreateNestedOneWithoutResellerProfileInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerProfileInput>;
  create?: InputMaybe<UserCreateWithoutResellerProfileInput>;
};

export type UserCreateNestedOneWithoutResellerQuotationInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerQuotationInput>;
  create?: InputMaybe<UserCreateWithoutResellerQuotationInput>;
};

export type UserCreateNestedOneWithoutResellerSaleInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerSaleInput>;
  create?: InputMaybe<UserCreateWithoutResellerSaleInput>;
};

export type UserCreateNestedOneWithoutResellerSalesInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerSalesInput>;
  create?: InputMaybe<UserCreateWithoutResellerSalesInput>;
};

export type UserCreateNestedOneWithoutResellerTierHistoryChangedBysInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerTierHistoryChangedBysInput>;
  create?: InputMaybe<UserCreateWithoutResellerTierHistoryChangedBysInput>;
};

export type UserCreateNestedOneWithoutResellerTierHistoryInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerTierHistoryInput>;
  create?: InputMaybe<UserCreateWithoutResellerTierHistoryInput>;
};

export type UserCreateNestedOneWithoutSalesReturnInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSalesReturnInput>;
  create?: InputMaybe<UserCreateWithoutSalesReturnInput>;
};

export type UserCreateNestedOneWithoutSalesReturnReceiversInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSalesReturnReceiversInput>;
  create?: InputMaybe<UserCreateWithoutSalesReturnReceiversInput>;
};

export type UserCreateNestedOneWithoutSalesReturnRequestersInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSalesReturnRequestersInput>;
  create?: InputMaybe<UserCreateWithoutSalesReturnRequestersInput>;
};

export type UserCreateNestedOneWithoutStockReceiptBatchConfirmedBysInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutStockReceiptBatchConfirmedBysInput>;
  create?: InputMaybe<UserCreateWithoutStockReceiptBatchConfirmedBysInput>;
};

export type UserCreateNestedOneWithoutStockReceiptBatchReceivedBysInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutStockReceiptBatchReceivedBysInput>;
  create?: InputMaybe<UserCreateWithoutStockReceiptBatchReceivedBysInput>;
};

export type UserCreateNestedOneWithoutStockTransferApprovalsInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutStockTransferApprovalsInput>;
  create?: InputMaybe<UserCreateWithoutStockTransferApprovalsInput>;
};

export type UserCreateNestedOneWithoutStockTransferRequestsInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutStockTransferRequestsInput>;
  create?: InputMaybe<UserCreateWithoutStockTransferRequestsInput>;
};

export type UserCreateNestedOneWithoutStoreInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutStoreInput>;
  create?: InputMaybe<UserCreateWithoutStoreInput>;
};

export type UserCreateNestedOneWithoutSupplierInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSupplierInput>;
  create?: InputMaybe<UserCreateWithoutSupplierInput>;
};

export type UserCreateOrConnectWithoutBillerQuotationInput = {
  create: UserCreateWithoutBillerQuotationInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutBillerResellerSaleInput = {
  create: UserCreateWithoutBillerResellerSaleInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutConsumerReceiptInput = {
  create: UserCreateWithoutConsumerReceiptInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutConsumerSaleAdjustedBysInput = {
  create: UserCreateWithoutConsumerSaleAdjustedBysInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutConsumerSaleInput = {
  create: UserCreateWithoutConsumerSaleInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutCustomerProfileInput = {
  create: UserCreateWithoutCustomerProfileInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutFulfillmentInput = {
  create: UserCreateWithoutFulfillmentInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutPurchaseRequisitionInput = {
  create: UserCreateWithoutPurchaseRequisitionInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutPurchaseReturnApproversInput = {
  create: UserCreateWithoutPurchaseReturnApproversInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutPurchaseReturnInitiatorsInput = {
  create: UserCreateWithoutPurchaseReturnInitiatorsInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutRequestedResellersInput = {
  create: UserCreateWithoutRequestedResellersInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutResellerPaymentsMadeInput = {
  create: UserCreateWithoutResellerPaymentsMadeInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutResellerPaymentsReceivedInput = {
  create: UserCreateWithoutResellerPaymentsReceivedInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutResellerProfileInput = {
  create: UserCreateWithoutResellerProfileInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutResellerQuotationInput = {
  create: UserCreateWithoutResellerQuotationInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutResellerSaleInput = {
  create: UserCreateWithoutResellerSaleInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutResellerSalesInput = {
  create: UserCreateWithoutResellerSalesInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutResellerTierHistoryChangedBysInput = {
  create: UserCreateWithoutResellerTierHistoryChangedBysInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutResellerTierHistoryInput = {
  create: UserCreateWithoutResellerTierHistoryInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutSalesReturnInput = {
  create: UserCreateWithoutSalesReturnInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutSalesReturnReceiversInput = {
  create: UserCreateWithoutSalesReturnReceiversInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutSalesReturnRequestersInput = {
  create: UserCreateWithoutSalesReturnRequestersInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutStockReceiptBatchConfirmedBysInput = {
  create: UserCreateWithoutStockReceiptBatchConfirmedBysInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutStockReceiptBatchReceivedBysInput = {
  create: UserCreateWithoutStockReceiptBatchReceivedBysInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutStockTransferApprovalsInput = {
  create: UserCreateWithoutStockTransferApprovalsInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutStockTransferRequestsInput = {
  create: UserCreateWithoutStockTransferRequestsInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutStoreInput = {
  create: UserCreateWithoutStoreInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutSupplierInput = {
  create: UserCreateWithoutSupplierInput;
  where: UserWhereUniqueInput;
};

export type UserCreateWithoutBillerQuotationInput = {
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutBillerResellerSaleInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutConsumerReceiptInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutConsumerSaleAdjustedBysInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutConsumerSaleInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutCustomerProfileInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutFulfillmentInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutPurchaseRequisitionInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutPurchaseReturnApproversInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutPurchaseReturnInitiatorsInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutRequestedResellersInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutResellerPaymentsMadeInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutResellerPaymentsReceivedInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutResellerProfileInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutResellerQuotationInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutResellerSaleInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutResellerSalesInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutResellerTierHistoryChangedBysInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutResellerTierHistoryInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutSalesReturnInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutSalesReturnReceiversInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutSalesReturnRequestersInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutStockReceiptBatchConfirmedBysInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutStockReceiptBatchReceivedBysInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutStockTransferApprovalsInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutStockTransferRequestsInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutStoreInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Supplier?: InputMaybe<SupplierCreateNestedManyWithoutUserInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserCreateWithoutSupplierInput = {
  BillerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutBillerInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptCreateNestedManyWithoutIssuedByInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleCreateNestedManyWithoutBillerInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleCreateNestedManyWithoutAdjustedByInput>;
  Fulfillment?: InputMaybe<FulfillmentCreateNestedManyWithoutDeliveryPersonnelInput>;
  Notification?: InputMaybe<NotificationCreateNestedManyWithoutUserInput>;
  Payment?: InputMaybe<PaymentCreateNestedManyWithoutReceivedByInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionCreateNestedManyWithoutRequestedByInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnCreateNestedManyWithoutApprovedByInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnCreateNestedManyWithoutInitiatedByInput>;
  RequestedResellers?: InputMaybe<ResellerProfileCreateNestedManyWithoutRequestedBillerInput>;
  ResellerProfile?: InputMaybe<ResellerProfileCreateNestedManyWithoutBillerInput>;
  ResellerQuotation?: InputMaybe<QuotationCreateNestedManyWithoutResellerInput>;
  ResellerSale?: InputMaybe<ResellerSaleCreateNestedManyWithoutApprovedByInput>;
  ResellerSales?: InputMaybe<ResellerSaleCreateNestedManyWithoutResellerInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutUserInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryCreateNestedManyWithoutAdminInput>;
  SalesReturn?: InputMaybe<SalesReturnCreateNestedManyWithoutApprovedByInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnCreateNestedManyWithoutReceivedByInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnCreateNestedManyWithoutReturnedByInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutConfirmedByInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchCreateNestedManyWithoutReceivedByInput>;
  StockTransferApprovals?: InputMaybe<StockTransferCreateNestedManyWithoutApprovedByInput>;
  StockTransferRequests?: InputMaybe<StockTransferCreateNestedManyWithoutRequestedByInput>;
  Store?: InputMaybe<StoreCreateNestedManyWithoutManagerInput>;
  adminLogs?: InputMaybe<AdminActionLogCreateNestedManyWithoutAdminInput>;
  createdAt?: InputMaybe<Scalars['DateTime']['input']>;
  customerProfile?: InputMaybe<CustomerProfileCreateNestedOneWithoutUserInput>;
  email: Scalars['String']['input'];
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['DateTime']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash: Scalars['String']['input'];
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<Scalars['String']['input']>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentCreateNestedManyWithoutResellerInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentCreateNestedManyWithoutReceivedByInput>;
  resellerProfile?: InputMaybe<ResellerProfileCreateNestedOneWithoutUserInput>;
  role: RoleCreateNestedOneWithoutUsersInput;
  supportMessages?: InputMaybe<SupportMessageCreateNestedManyWithoutUserInput>;
  tier?: InputMaybe<UserTier>;
  updatedAt?: InputMaybe<Scalars['DateTime']['input']>;
};

export type UserGroupBy = {
  __typename?: 'UserGroupBy';
  _count?: Maybe<UserCountAggregate>;
  _max?: Maybe<UserMaxAggregate>;
  _min?: Maybe<UserMinAggregate>;
  createdAt: Scalars['DateTime']['output'];
  email: Scalars['String']['output'];
  emailVerificationToken?: Maybe<Scalars['String']['output']>;
  emailVerificationTokenExpiry?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['String']['output'];
  isEmailVerified: Scalars['Boolean']['output'];
  passwordHash: Scalars['String']['output'];
  referralCode?: Maybe<Scalars['String']['output']>;
  referredBy?: Maybe<Scalars['String']['output']>;
  roleId: Scalars['String']['output'];
  tier?: Maybe<UserTier>;
  updatedAt: Scalars['DateTime']['output'];
};

export type UserListRelationFilter = {
  every?: InputMaybe<UserWhereInput>;
  none?: InputMaybe<UserWhereInput>;
  some?: InputMaybe<UserWhereInput>;
};

export type UserMaxAggregate = {
  __typename?: 'UserMaxAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  emailVerificationToken?: Maybe<Scalars['String']['output']>;
  emailVerificationTokenExpiry?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  isEmailVerified?: Maybe<Scalars['Boolean']['output']>;
  passwordHash?: Maybe<Scalars['String']['output']>;
  referralCode?: Maybe<Scalars['String']['output']>;
  referredBy?: Maybe<Scalars['String']['output']>;
  roleId?: Maybe<Scalars['String']['output']>;
  tier?: Maybe<UserTier>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type UserMaxAggregateInput = {
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  email?: InputMaybe<Scalars['Boolean']['input']>;
  emailVerificationToken?: InputMaybe<Scalars['Boolean']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash?: InputMaybe<Scalars['Boolean']['input']>;
  referralCode?: InputMaybe<Scalars['Boolean']['input']>;
  referredBy?: InputMaybe<Scalars['Boolean']['input']>;
  roleId?: InputMaybe<Scalars['Boolean']['input']>;
  tier?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UserMaxOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerificationToken?: InputMaybe<SortOrder>;
  emailVerificationTokenExpiry?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isEmailVerified?: InputMaybe<SortOrder>;
  passwordHash?: InputMaybe<SortOrder>;
  referralCode?: InputMaybe<SortOrder>;
  referredBy?: InputMaybe<SortOrder>;
  roleId?: InputMaybe<SortOrder>;
  tier?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type UserMinAggregate = {
  __typename?: 'UserMinAggregate';
  createdAt?: Maybe<Scalars['DateTime']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  emailVerificationToken?: Maybe<Scalars['String']['output']>;
  emailVerificationTokenExpiry?: Maybe<Scalars['DateTime']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  isEmailVerified?: Maybe<Scalars['Boolean']['output']>;
  passwordHash?: Maybe<Scalars['String']['output']>;
  referralCode?: Maybe<Scalars['String']['output']>;
  referredBy?: Maybe<Scalars['String']['output']>;
  roleId?: Maybe<Scalars['String']['output']>;
  tier?: Maybe<UserTier>;
  updatedAt?: Maybe<Scalars['DateTime']['output']>;
};

export type UserMinAggregateInput = {
  createdAt?: InputMaybe<Scalars['Boolean']['input']>;
  email?: InputMaybe<Scalars['Boolean']['input']>;
  emailVerificationToken?: InputMaybe<Scalars['Boolean']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Boolean']['input']>;
  isEmailVerified?: InputMaybe<Scalars['Boolean']['input']>;
  passwordHash?: InputMaybe<Scalars['Boolean']['input']>;
  referralCode?: InputMaybe<Scalars['Boolean']['input']>;
  referredBy?: InputMaybe<Scalars['Boolean']['input']>;
  roleId?: InputMaybe<Scalars['Boolean']['input']>;
  tier?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UserMinOrderByAggregateInput = {
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerificationToken?: InputMaybe<SortOrder>;
  emailVerificationTokenExpiry?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  isEmailVerified?: InputMaybe<SortOrder>;
  passwordHash?: InputMaybe<SortOrder>;
  referralCode?: InputMaybe<SortOrder>;
  referredBy?: InputMaybe<SortOrder>;
  roleId?: InputMaybe<SortOrder>;
  tier?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type UserNullableScalarRelationFilter = {
  is?: InputMaybe<UserWhereInput>;
  isNot?: InputMaybe<UserWhereInput>;
};

export type UserOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type UserOrderByWithAggregationInput = {
  _count?: InputMaybe<UserCountOrderByAggregateInput>;
  _max?: InputMaybe<UserMaxOrderByAggregateInput>;
  _min?: InputMaybe<UserMinOrderByAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerificationToken?: InputMaybe<SortOrderInput>;
  emailVerificationTokenExpiry?: InputMaybe<SortOrderInput>;
  id?: InputMaybe<SortOrder>;
  isEmailVerified?: InputMaybe<SortOrder>;
  passwordHash?: InputMaybe<SortOrder>;
  referralCode?: InputMaybe<SortOrderInput>;
  referredBy?: InputMaybe<SortOrderInput>;
  roleId?: InputMaybe<SortOrder>;
  tier?: InputMaybe<SortOrderInput>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type UserOrderByWithRelationInput = {
  BillerQuotation?: InputMaybe<QuotationOrderByRelationAggregateInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleOrderByRelationAggregateInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptOrderByRelationAggregateInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleOrderByRelationAggregateInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleOrderByRelationAggregateInput>;
  Fulfillment?: InputMaybe<FulfillmentOrderByRelationAggregateInput>;
  Notification?: InputMaybe<NotificationOrderByRelationAggregateInput>;
  Payment?: InputMaybe<PaymentOrderByRelationAggregateInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionOrderByRelationAggregateInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnOrderByRelationAggregateInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnOrderByRelationAggregateInput>;
  RequestedResellers?: InputMaybe<ResellerProfileOrderByRelationAggregateInput>;
  ResellerProfile?: InputMaybe<ResellerProfileOrderByRelationAggregateInput>;
  ResellerQuotation?: InputMaybe<QuotationOrderByRelationAggregateInput>;
  ResellerSale?: InputMaybe<ResellerSaleOrderByRelationAggregateInput>;
  ResellerSales?: InputMaybe<ResellerSaleOrderByRelationAggregateInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryOrderByRelationAggregateInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryOrderByRelationAggregateInput>;
  SalesReturn?: InputMaybe<SalesReturnOrderByRelationAggregateInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnOrderByRelationAggregateInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnOrderByRelationAggregateInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchOrderByRelationAggregateInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchOrderByRelationAggregateInput>;
  StockTransferApprovals?: InputMaybe<StockTransferOrderByRelationAggregateInput>;
  StockTransferRequests?: InputMaybe<StockTransferOrderByRelationAggregateInput>;
  Store?: InputMaybe<StoreOrderByRelationAggregateInput>;
  Supplier?: InputMaybe<SupplierOrderByRelationAggregateInput>;
  adminLogs?: InputMaybe<AdminActionLogOrderByRelationAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  customerProfile?: InputMaybe<CustomerProfileOrderByWithRelationInput>;
  email?: InputMaybe<SortOrder>;
  emailVerificationToken?: InputMaybe<SortOrderInput>;
  emailVerificationTokenExpiry?: InputMaybe<SortOrderInput>;
  id?: InputMaybe<SortOrder>;
  isEmailVerified?: InputMaybe<SortOrder>;
  passwordHash?: InputMaybe<SortOrder>;
  referralCode?: InputMaybe<SortOrderInput>;
  referredBy?: InputMaybe<SortOrderInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentOrderByRelationAggregateInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentOrderByRelationAggregateInput>;
  resellerProfile?: InputMaybe<ResellerProfileOrderByWithRelationInput>;
  role?: InputMaybe<RoleOrderByWithRelationInput>;
  roleId?: InputMaybe<SortOrder>;
  supportMessages?: InputMaybe<SupportMessageOrderByRelationAggregateInput>;
  tier?: InputMaybe<SortOrderInput>;
  updatedAt?: InputMaybe<SortOrder>;
};

export enum UserScalarFieldEnum {
  CreatedAt = 'createdAt',
  Email = 'email',
  EmailVerificationToken = 'emailVerificationToken',
  EmailVerificationTokenExpiry = 'emailVerificationTokenExpiry',
  Id = 'id',
  IsEmailVerified = 'isEmailVerified',
  PasswordHash = 'passwordHash',
  ReferralCode = 'referralCode',
  ReferredBy = 'referredBy',
  RoleId = 'roleId',
  Tier = 'tier',
  UpdatedAt = 'updatedAt'
}

export type UserScalarRelationFilter = {
  is?: InputMaybe<UserWhereInput>;
  isNot?: InputMaybe<UserWhereInput>;
};

export type UserScalarWhereWithAggregatesInput = {
  AND?: InputMaybe<Array<UserScalarWhereWithAggregatesInput>>;
  NOT?: InputMaybe<Array<UserScalarWhereWithAggregatesInput>>;
  OR?: InputMaybe<Array<UserScalarWhereWithAggregatesInput>>;
  createdAt?: InputMaybe<DateTimeWithAggregatesFilter>;
  email?: InputMaybe<StringWithAggregatesFilter>;
  emailVerificationToken?: InputMaybe<StringNullableWithAggregatesFilter>;
  emailVerificationTokenExpiry?: InputMaybe<DateTimeNullableWithAggregatesFilter>;
  id?: InputMaybe<StringWithAggregatesFilter>;
  isEmailVerified?: InputMaybe<BoolWithAggregatesFilter>;
  passwordHash?: InputMaybe<StringWithAggregatesFilter>;
  referralCode?: InputMaybe<StringNullableWithAggregatesFilter>;
  referredBy?: InputMaybe<StringNullableWithAggregatesFilter>;
  roleId?: InputMaybe<StringWithAggregatesFilter>;
  tier?: InputMaybe<EnumUserTierNullableWithAggregatesFilter>;
  updatedAt?: InputMaybe<DateTimeWithAggregatesFilter>;
};

export enum UserTier {
  Bronze = 'BRONZE',
  Gold = 'GOLD',
  Platinum = 'PLATINUM',
  Silver = 'SILVER',
  Zero = 'ZERO'
}

export type UserUpdateInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateManyMutationInput = {
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateOneRequiredWithoutBillerResellerSaleNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutBillerResellerSaleInput>;
  create?: InputMaybe<UserCreateWithoutBillerResellerSaleInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutBillerResellerSaleInput>;
  upsert?: InputMaybe<UserUpsertWithoutBillerResellerSaleInput>;
};

export type UserUpdateOneRequiredWithoutConsumerReceiptNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutConsumerReceiptInput>;
  create?: InputMaybe<UserCreateWithoutConsumerReceiptInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutConsumerReceiptInput>;
  upsert?: InputMaybe<UserUpsertWithoutConsumerReceiptInput>;
};

export type UserUpdateOneRequiredWithoutConsumerSaleNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutConsumerSaleInput>;
  create?: InputMaybe<UserCreateWithoutConsumerSaleInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutConsumerSaleInput>;
  upsert?: InputMaybe<UserUpsertWithoutConsumerSaleInput>;
};

export type UserUpdateOneRequiredWithoutCustomerProfileNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutCustomerProfileInput>;
  create?: InputMaybe<UserCreateWithoutCustomerProfileInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutCustomerProfileInput>;
  upsert?: InputMaybe<UserUpsertWithoutCustomerProfileInput>;
};

export type UserUpdateOneRequiredWithoutPurchaseRequisitionNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutPurchaseRequisitionInput>;
  create?: InputMaybe<UserCreateWithoutPurchaseRequisitionInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutPurchaseRequisitionInput>;
  upsert?: InputMaybe<UserUpsertWithoutPurchaseRequisitionInput>;
};

export type UserUpdateOneRequiredWithoutPurchaseReturnApproversNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutPurchaseReturnApproversInput>;
  create?: InputMaybe<UserCreateWithoutPurchaseReturnApproversInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutPurchaseReturnApproversInput>;
  upsert?: InputMaybe<UserUpsertWithoutPurchaseReturnApproversInput>;
};

export type UserUpdateOneRequiredWithoutPurchaseReturnInitiatorsNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutPurchaseReturnInitiatorsInput>;
  create?: InputMaybe<UserCreateWithoutPurchaseReturnInitiatorsInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutPurchaseReturnInitiatorsInput>;
  upsert?: InputMaybe<UserUpsertWithoutPurchaseReturnInitiatorsInput>;
};

export type UserUpdateOneRequiredWithoutResellerPaymentsMadeNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerPaymentsMadeInput>;
  create?: InputMaybe<UserCreateWithoutResellerPaymentsMadeInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutResellerPaymentsMadeInput>;
  upsert?: InputMaybe<UserUpsertWithoutResellerPaymentsMadeInput>;
};

export type UserUpdateOneRequiredWithoutResellerPaymentsReceivedNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerPaymentsReceivedInput>;
  create?: InputMaybe<UserCreateWithoutResellerPaymentsReceivedInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutResellerPaymentsReceivedInput>;
  upsert?: InputMaybe<UserUpsertWithoutResellerPaymentsReceivedInput>;
};

export type UserUpdateOneRequiredWithoutResellerProfileNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerProfileInput>;
  create?: InputMaybe<UserCreateWithoutResellerProfileInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutResellerProfileInput>;
  upsert?: InputMaybe<UserUpsertWithoutResellerProfileInput>;
};

export type UserUpdateOneRequiredWithoutResellerSalesNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerSalesInput>;
  create?: InputMaybe<UserCreateWithoutResellerSalesInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutResellerSalesInput>;
  upsert?: InputMaybe<UserUpsertWithoutResellerSalesInput>;
};

export type UserUpdateOneRequiredWithoutResellerTierHistoryChangedBysNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerTierHistoryChangedBysInput>;
  create?: InputMaybe<UserCreateWithoutResellerTierHistoryChangedBysInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutResellerTierHistoryChangedBysInput>;
  upsert?: InputMaybe<UserUpsertWithoutResellerTierHistoryChangedBysInput>;
};

export type UserUpdateOneRequiredWithoutResellerTierHistoryNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerTierHistoryInput>;
  create?: InputMaybe<UserCreateWithoutResellerTierHistoryInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutResellerTierHistoryInput>;
  upsert?: InputMaybe<UserUpsertWithoutResellerTierHistoryInput>;
};

export type UserUpdateOneRequiredWithoutSalesReturnReceiversNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSalesReturnReceiversInput>;
  create?: InputMaybe<UserCreateWithoutSalesReturnReceiversInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutSalesReturnReceiversInput>;
  upsert?: InputMaybe<UserUpsertWithoutSalesReturnReceiversInput>;
};

export type UserUpdateOneRequiredWithoutSalesReturnRequestersNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSalesReturnRequestersInput>;
  create?: InputMaybe<UserCreateWithoutSalesReturnRequestersInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutSalesReturnRequestersInput>;
  upsert?: InputMaybe<UserUpsertWithoutSalesReturnRequestersInput>;
};

export type UserUpdateOneRequiredWithoutStockReceiptBatchConfirmedBysNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutStockReceiptBatchConfirmedBysInput>;
  create?: InputMaybe<UserCreateWithoutStockReceiptBatchConfirmedBysInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutStockReceiptBatchConfirmedBysInput>;
  upsert?: InputMaybe<UserUpsertWithoutStockReceiptBatchConfirmedBysInput>;
};

export type UserUpdateOneRequiredWithoutStockReceiptBatchReceivedBysNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutStockReceiptBatchReceivedBysInput>;
  create?: InputMaybe<UserCreateWithoutStockReceiptBatchReceivedBysInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutStockReceiptBatchReceivedBysInput>;
  upsert?: InputMaybe<UserUpsertWithoutStockReceiptBatchReceivedBysInput>;
};

export type UserUpdateOneRequiredWithoutStockTransferApprovalsNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutStockTransferApprovalsInput>;
  create?: InputMaybe<UserCreateWithoutStockTransferApprovalsInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutStockTransferApprovalsInput>;
  upsert?: InputMaybe<UserUpsertWithoutStockTransferApprovalsInput>;
};

export type UserUpdateOneRequiredWithoutStockTransferRequestsNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutStockTransferRequestsInput>;
  create?: InputMaybe<UserCreateWithoutStockTransferRequestsInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutStockTransferRequestsInput>;
  upsert?: InputMaybe<UserUpsertWithoutStockTransferRequestsInput>;
};

export type UserUpdateOneRequiredWithoutStoreNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutStoreInput>;
  create?: InputMaybe<UserCreateWithoutStoreInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutStoreInput>;
  upsert?: InputMaybe<UserUpsertWithoutStoreInput>;
};

export type UserUpdateOneWithoutBillerQuotationNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutBillerQuotationInput>;
  create?: InputMaybe<UserCreateWithoutBillerQuotationInput>;
  delete?: InputMaybe<UserWhereInput>;
  disconnect?: InputMaybe<UserWhereInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutBillerQuotationInput>;
  upsert?: InputMaybe<UserUpsertWithoutBillerQuotationInput>;
};

export type UserUpdateOneWithoutConsumerSaleAdjustedBysNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutConsumerSaleAdjustedBysInput>;
  create?: InputMaybe<UserCreateWithoutConsumerSaleAdjustedBysInput>;
  delete?: InputMaybe<UserWhereInput>;
  disconnect?: InputMaybe<UserWhereInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutConsumerSaleAdjustedBysInput>;
  upsert?: InputMaybe<UserUpsertWithoutConsumerSaleAdjustedBysInput>;
};

export type UserUpdateOneWithoutFulfillmentNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutFulfillmentInput>;
  create?: InputMaybe<UserCreateWithoutFulfillmentInput>;
  delete?: InputMaybe<UserWhereInput>;
  disconnect?: InputMaybe<UserWhereInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutFulfillmentInput>;
  upsert?: InputMaybe<UserUpsertWithoutFulfillmentInput>;
};

export type UserUpdateOneWithoutRequestedResellersNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutRequestedResellersInput>;
  create?: InputMaybe<UserCreateWithoutRequestedResellersInput>;
  delete?: InputMaybe<UserWhereInput>;
  disconnect?: InputMaybe<UserWhereInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutRequestedResellersInput>;
  upsert?: InputMaybe<UserUpsertWithoutRequestedResellersInput>;
};

export type UserUpdateOneWithoutResellerProfileNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerProfileInput>;
  create?: InputMaybe<UserCreateWithoutResellerProfileInput>;
  delete?: InputMaybe<UserWhereInput>;
  disconnect?: InputMaybe<UserWhereInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutResellerProfileInput>;
  upsert?: InputMaybe<UserUpsertWithoutResellerProfileInput>;
};

export type UserUpdateOneWithoutResellerQuotationNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerQuotationInput>;
  create?: InputMaybe<UserCreateWithoutResellerQuotationInput>;
  delete?: InputMaybe<UserWhereInput>;
  disconnect?: InputMaybe<UserWhereInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutResellerQuotationInput>;
  upsert?: InputMaybe<UserUpsertWithoutResellerQuotationInput>;
};

export type UserUpdateOneWithoutResellerSaleNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutResellerSaleInput>;
  create?: InputMaybe<UserCreateWithoutResellerSaleInput>;
  delete?: InputMaybe<UserWhereInput>;
  disconnect?: InputMaybe<UserWhereInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutResellerSaleInput>;
  upsert?: InputMaybe<UserUpsertWithoutResellerSaleInput>;
};

export type UserUpdateOneWithoutSalesReturnNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSalesReturnInput>;
  create?: InputMaybe<UserCreateWithoutSalesReturnInput>;
  delete?: InputMaybe<UserWhereInput>;
  disconnect?: InputMaybe<UserWhereInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutSalesReturnInput>;
  upsert?: InputMaybe<UserUpsertWithoutSalesReturnInput>;
};

export type UserUpdateOneWithoutSupplierNestedInput = {
  connect?: InputMaybe<UserWhereUniqueInput>;
  connectOrCreate?: InputMaybe<UserCreateOrConnectWithoutSupplierInput>;
  create?: InputMaybe<UserCreateWithoutSupplierInput>;
  delete?: InputMaybe<UserWhereInput>;
  disconnect?: InputMaybe<UserWhereInput>;
  update?: InputMaybe<UserUpdateToOneWithWhereWithoutSupplierInput>;
  upsert?: InputMaybe<UserUpsertWithoutSupplierInput>;
};

export type UserUpdateToOneWithWhereWithoutBillerQuotationInput = {
  data: UserUpdateWithoutBillerQuotationInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutBillerResellerSaleInput = {
  data: UserUpdateWithoutBillerResellerSaleInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutConsumerReceiptInput = {
  data: UserUpdateWithoutConsumerReceiptInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutConsumerSaleAdjustedBysInput = {
  data: UserUpdateWithoutConsumerSaleAdjustedBysInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutConsumerSaleInput = {
  data: UserUpdateWithoutConsumerSaleInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutCustomerProfileInput = {
  data: UserUpdateWithoutCustomerProfileInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutFulfillmentInput = {
  data: UserUpdateWithoutFulfillmentInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutPurchaseRequisitionInput = {
  data: UserUpdateWithoutPurchaseRequisitionInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutPurchaseReturnApproversInput = {
  data: UserUpdateWithoutPurchaseReturnApproversInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutPurchaseReturnInitiatorsInput = {
  data: UserUpdateWithoutPurchaseReturnInitiatorsInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutRequestedResellersInput = {
  data: UserUpdateWithoutRequestedResellersInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutResellerPaymentsMadeInput = {
  data: UserUpdateWithoutResellerPaymentsMadeInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutResellerPaymentsReceivedInput = {
  data: UserUpdateWithoutResellerPaymentsReceivedInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutResellerProfileInput = {
  data: UserUpdateWithoutResellerProfileInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutResellerQuotationInput = {
  data: UserUpdateWithoutResellerQuotationInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutResellerSaleInput = {
  data: UserUpdateWithoutResellerSaleInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutResellerSalesInput = {
  data: UserUpdateWithoutResellerSalesInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutResellerTierHistoryChangedBysInput = {
  data: UserUpdateWithoutResellerTierHistoryChangedBysInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutResellerTierHistoryInput = {
  data: UserUpdateWithoutResellerTierHistoryInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutSalesReturnInput = {
  data: UserUpdateWithoutSalesReturnInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutSalesReturnReceiversInput = {
  data: UserUpdateWithoutSalesReturnReceiversInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutSalesReturnRequestersInput = {
  data: UserUpdateWithoutSalesReturnRequestersInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutStockReceiptBatchConfirmedBysInput = {
  data: UserUpdateWithoutStockReceiptBatchConfirmedBysInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutStockReceiptBatchReceivedBysInput = {
  data: UserUpdateWithoutStockReceiptBatchReceivedBysInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutStockTransferApprovalsInput = {
  data: UserUpdateWithoutStockTransferApprovalsInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutStockTransferRequestsInput = {
  data: UserUpdateWithoutStockTransferRequestsInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutStoreInput = {
  data: UserUpdateWithoutStoreInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateToOneWithWhereWithoutSupplierInput = {
  data: UserUpdateWithoutSupplierInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpdateWithoutBillerQuotationInput = {
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutBillerResellerSaleInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutConsumerReceiptInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutConsumerSaleAdjustedBysInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutConsumerSaleInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutCustomerProfileInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutFulfillmentInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutPurchaseRequisitionInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutPurchaseReturnApproversInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutPurchaseReturnInitiatorsInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutRequestedResellersInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutResellerPaymentsMadeInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutResellerPaymentsReceivedInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutResellerProfileInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutResellerQuotationInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutResellerSaleInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutResellerSalesInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutResellerTierHistoryChangedBysInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutResellerTierHistoryInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutSalesReturnInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutSalesReturnReceiversInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutSalesReturnRequestersInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutStockReceiptBatchConfirmedBysInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutStockReceiptBatchReceivedBysInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutStockTransferApprovalsInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutStockTransferRequestsInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutStoreInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Supplier?: InputMaybe<SupplierUpdateManyWithoutUserNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutSupplierInput = {
  BillerQuotation?: InputMaybe<QuotationUpdateManyWithoutBillerNestedInput>;
  BillerResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptUpdateManyWithoutIssuedByNestedInput>;
  ConsumerSale?: InputMaybe<ConsumerSaleUpdateManyWithoutBillerNestedInput>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleUpdateManyWithoutAdjustedByNestedInput>;
  Fulfillment?: InputMaybe<FulfillmentUpdateManyWithoutDeliveryPersonnelNestedInput>;
  Notification?: InputMaybe<NotificationUpdateManyWithoutUserNestedInput>;
  Payment?: InputMaybe<PaymentUpdateManyWithoutReceivedByNestedInput>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionUpdateManyWithoutRequestedByNestedInput>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnUpdateManyWithoutApprovedByNestedInput>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnUpdateManyWithoutInitiatedByNestedInput>;
  RequestedResellers?: InputMaybe<ResellerProfileUpdateManyWithoutRequestedBillerNestedInput>;
  ResellerProfile?: InputMaybe<ResellerProfileUpdateManyWithoutBillerNestedInput>;
  ResellerQuotation?: InputMaybe<QuotationUpdateManyWithoutResellerNestedInput>;
  ResellerSale?: InputMaybe<ResellerSaleUpdateManyWithoutApprovedByNestedInput>;
  ResellerSales?: InputMaybe<ResellerSaleUpdateManyWithoutResellerNestedInput>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryUpdateManyWithoutUserNestedInput>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryUpdateManyWithoutAdminNestedInput>;
  SalesReturn?: InputMaybe<SalesReturnUpdateManyWithoutApprovedByNestedInput>;
  SalesReturnReceivers?: InputMaybe<SalesReturnUpdateManyWithoutReceivedByNestedInput>;
  SalesReturnRequesters?: InputMaybe<SalesReturnUpdateManyWithoutReturnedByNestedInput>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutConfirmedByNestedInput>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchUpdateManyWithoutReceivedByNestedInput>;
  StockTransferApprovals?: InputMaybe<StockTransferUpdateManyWithoutApprovedByNestedInput>;
  StockTransferRequests?: InputMaybe<StockTransferUpdateManyWithoutRequestedByNestedInput>;
  Store?: InputMaybe<StoreUpdateManyWithoutManagerNestedInput>;
  adminLogs?: InputMaybe<AdminActionLogUpdateManyWithoutAdminNestedInput>;
  createdAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
  customerProfile?: InputMaybe<CustomerProfileUpdateOneWithoutUserNestedInput>;
  email?: InputMaybe<StringFieldUpdateOperationsInput>;
  emailVerificationToken?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  emailVerificationTokenExpiry?: InputMaybe<NullableDateTimeFieldUpdateOperationsInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  isEmailVerified?: InputMaybe<BoolFieldUpdateOperationsInput>;
  passwordHash?: InputMaybe<StringFieldUpdateOperationsInput>;
  referralCode?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  referredBy?: InputMaybe<NullableStringFieldUpdateOperationsInput>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentUpdateManyWithoutResellerNestedInput>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentUpdateManyWithoutReceivedByNestedInput>;
  resellerProfile?: InputMaybe<ResellerProfileUpdateOneWithoutUserNestedInput>;
  role?: InputMaybe<RoleUpdateOneRequiredWithoutUsersNestedInput>;
  supportMessages?: InputMaybe<SupportMessageUpdateManyWithoutUserNestedInput>;
  tier?: InputMaybe<NullableEnumUserTierFieldUpdateOperationsInput>;
  updatedAt?: InputMaybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpsertWithoutBillerQuotationInput = {
  create: UserCreateWithoutBillerQuotationInput;
  update: UserUpdateWithoutBillerQuotationInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutBillerResellerSaleInput = {
  create: UserCreateWithoutBillerResellerSaleInput;
  update: UserUpdateWithoutBillerResellerSaleInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutConsumerReceiptInput = {
  create: UserCreateWithoutConsumerReceiptInput;
  update: UserUpdateWithoutConsumerReceiptInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutConsumerSaleAdjustedBysInput = {
  create: UserCreateWithoutConsumerSaleAdjustedBysInput;
  update: UserUpdateWithoutConsumerSaleAdjustedBysInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutConsumerSaleInput = {
  create: UserCreateWithoutConsumerSaleInput;
  update: UserUpdateWithoutConsumerSaleInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutCustomerProfileInput = {
  create: UserCreateWithoutCustomerProfileInput;
  update: UserUpdateWithoutCustomerProfileInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutFulfillmentInput = {
  create: UserCreateWithoutFulfillmentInput;
  update: UserUpdateWithoutFulfillmentInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutPurchaseRequisitionInput = {
  create: UserCreateWithoutPurchaseRequisitionInput;
  update: UserUpdateWithoutPurchaseRequisitionInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutPurchaseReturnApproversInput = {
  create: UserCreateWithoutPurchaseReturnApproversInput;
  update: UserUpdateWithoutPurchaseReturnApproversInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutPurchaseReturnInitiatorsInput = {
  create: UserCreateWithoutPurchaseReturnInitiatorsInput;
  update: UserUpdateWithoutPurchaseReturnInitiatorsInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutRequestedResellersInput = {
  create: UserCreateWithoutRequestedResellersInput;
  update: UserUpdateWithoutRequestedResellersInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutResellerPaymentsMadeInput = {
  create: UserCreateWithoutResellerPaymentsMadeInput;
  update: UserUpdateWithoutResellerPaymentsMadeInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutResellerPaymentsReceivedInput = {
  create: UserCreateWithoutResellerPaymentsReceivedInput;
  update: UserUpdateWithoutResellerPaymentsReceivedInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutResellerProfileInput = {
  create: UserCreateWithoutResellerProfileInput;
  update: UserUpdateWithoutResellerProfileInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutResellerQuotationInput = {
  create: UserCreateWithoutResellerQuotationInput;
  update: UserUpdateWithoutResellerQuotationInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutResellerSaleInput = {
  create: UserCreateWithoutResellerSaleInput;
  update: UserUpdateWithoutResellerSaleInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutResellerSalesInput = {
  create: UserCreateWithoutResellerSalesInput;
  update: UserUpdateWithoutResellerSalesInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutResellerTierHistoryChangedBysInput = {
  create: UserCreateWithoutResellerTierHistoryChangedBysInput;
  update: UserUpdateWithoutResellerTierHistoryChangedBysInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutResellerTierHistoryInput = {
  create: UserCreateWithoutResellerTierHistoryInput;
  update: UserUpdateWithoutResellerTierHistoryInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutSalesReturnInput = {
  create: UserCreateWithoutSalesReturnInput;
  update: UserUpdateWithoutSalesReturnInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutSalesReturnReceiversInput = {
  create: UserCreateWithoutSalesReturnReceiversInput;
  update: UserUpdateWithoutSalesReturnReceiversInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutSalesReturnRequestersInput = {
  create: UserCreateWithoutSalesReturnRequestersInput;
  update: UserUpdateWithoutSalesReturnRequestersInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutStockReceiptBatchConfirmedBysInput = {
  create: UserCreateWithoutStockReceiptBatchConfirmedBysInput;
  update: UserUpdateWithoutStockReceiptBatchConfirmedBysInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutStockReceiptBatchReceivedBysInput = {
  create: UserCreateWithoutStockReceiptBatchReceivedBysInput;
  update: UserUpdateWithoutStockReceiptBatchReceivedBysInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutStockTransferApprovalsInput = {
  create: UserCreateWithoutStockTransferApprovalsInput;
  update: UserUpdateWithoutStockTransferApprovalsInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutStockTransferRequestsInput = {
  create: UserCreateWithoutStockTransferRequestsInput;
  update: UserUpdateWithoutStockTransferRequestsInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutStoreInput = {
  create: UserCreateWithoutStoreInput;
  update: UserUpdateWithoutStoreInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserUpsertWithoutSupplierInput = {
  create: UserCreateWithoutSupplierInput;
  update: UserUpdateWithoutSupplierInput;
  where?: InputMaybe<UserWhereInput>;
};

export type UserWhereInput = {
  AND?: InputMaybe<Array<UserWhereInput>>;
  BillerQuotation?: InputMaybe<QuotationListRelationFilter>;
  BillerResellerSale?: InputMaybe<ResellerSaleListRelationFilter>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptListRelationFilter>;
  ConsumerSale?: InputMaybe<ConsumerSaleListRelationFilter>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleListRelationFilter>;
  Fulfillment?: InputMaybe<FulfillmentListRelationFilter>;
  NOT?: InputMaybe<Array<UserWhereInput>>;
  Notification?: InputMaybe<NotificationListRelationFilter>;
  OR?: InputMaybe<Array<UserWhereInput>>;
  Payment?: InputMaybe<PaymentListRelationFilter>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionListRelationFilter>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnListRelationFilter>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnListRelationFilter>;
  RequestedResellers?: InputMaybe<ResellerProfileListRelationFilter>;
  ResellerProfile?: InputMaybe<ResellerProfileListRelationFilter>;
  ResellerQuotation?: InputMaybe<QuotationListRelationFilter>;
  ResellerSale?: InputMaybe<ResellerSaleListRelationFilter>;
  ResellerSales?: InputMaybe<ResellerSaleListRelationFilter>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryListRelationFilter>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryListRelationFilter>;
  SalesReturn?: InputMaybe<SalesReturnListRelationFilter>;
  SalesReturnReceivers?: InputMaybe<SalesReturnListRelationFilter>;
  SalesReturnRequesters?: InputMaybe<SalesReturnListRelationFilter>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchListRelationFilter>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchListRelationFilter>;
  StockTransferApprovals?: InputMaybe<StockTransferListRelationFilter>;
  StockTransferRequests?: InputMaybe<StockTransferListRelationFilter>;
  Store?: InputMaybe<StoreListRelationFilter>;
  Supplier?: InputMaybe<SupplierListRelationFilter>;
  adminLogs?: InputMaybe<AdminActionLogListRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  customerProfile?: InputMaybe<CustomerProfileNullableScalarRelationFilter>;
  email?: InputMaybe<StringFilter>;
  emailVerificationToken?: InputMaybe<StringNullableFilter>;
  emailVerificationTokenExpiry?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<StringFilter>;
  isEmailVerified?: InputMaybe<BoolFilter>;
  passwordHash?: InputMaybe<StringFilter>;
  referralCode?: InputMaybe<StringNullableFilter>;
  referredBy?: InputMaybe<StringNullableFilter>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentListRelationFilter>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentListRelationFilter>;
  resellerProfile?: InputMaybe<ResellerProfileNullableScalarRelationFilter>;
  role?: InputMaybe<RoleScalarRelationFilter>;
  roleId?: InputMaybe<StringFilter>;
  supportMessages?: InputMaybe<SupportMessageListRelationFilter>;
  tier?: InputMaybe<EnumUserTierNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type UserWhereUniqueInput = {
  AND?: InputMaybe<Array<UserWhereInput>>;
  BillerQuotation?: InputMaybe<QuotationListRelationFilter>;
  BillerResellerSale?: InputMaybe<ResellerSaleListRelationFilter>;
  ConsumerReceipt?: InputMaybe<ConsumerReceiptListRelationFilter>;
  ConsumerSale?: InputMaybe<ConsumerSaleListRelationFilter>;
  ConsumerSaleAdjustedBys?: InputMaybe<ConsumerSaleListRelationFilter>;
  Fulfillment?: InputMaybe<FulfillmentListRelationFilter>;
  NOT?: InputMaybe<Array<UserWhereInput>>;
  Notification?: InputMaybe<NotificationListRelationFilter>;
  OR?: InputMaybe<Array<UserWhereInput>>;
  Payment?: InputMaybe<PaymentListRelationFilter>;
  PurchaseRequisition?: InputMaybe<PurchaseRequisitionListRelationFilter>;
  PurchaseReturnApprovers?: InputMaybe<PurchaseReturnListRelationFilter>;
  PurchaseReturnInitiators?: InputMaybe<PurchaseReturnListRelationFilter>;
  RequestedResellers?: InputMaybe<ResellerProfileListRelationFilter>;
  ResellerProfile?: InputMaybe<ResellerProfileListRelationFilter>;
  ResellerQuotation?: InputMaybe<QuotationListRelationFilter>;
  ResellerSale?: InputMaybe<ResellerSaleListRelationFilter>;
  ResellerSales?: InputMaybe<ResellerSaleListRelationFilter>;
  ResellerTierHistory?: InputMaybe<ResellerTierHistoryListRelationFilter>;
  ResellerTierHistoryChangedBys?: InputMaybe<ResellerTierHistoryListRelationFilter>;
  SalesReturn?: InputMaybe<SalesReturnListRelationFilter>;
  SalesReturnReceivers?: InputMaybe<SalesReturnListRelationFilter>;
  SalesReturnRequesters?: InputMaybe<SalesReturnListRelationFilter>;
  StockReceiptBatchConfirmedBys?: InputMaybe<StockReceiptBatchListRelationFilter>;
  StockReceiptBatchReceivedBys?: InputMaybe<StockReceiptBatchListRelationFilter>;
  StockTransferApprovals?: InputMaybe<StockTransferListRelationFilter>;
  StockTransferRequests?: InputMaybe<StockTransferListRelationFilter>;
  Store?: InputMaybe<StoreListRelationFilter>;
  Supplier?: InputMaybe<SupplierListRelationFilter>;
  adminLogs?: InputMaybe<AdminActionLogListRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  customerProfile?: InputMaybe<CustomerProfileNullableScalarRelationFilter>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailVerificationToken?: InputMaybe<Scalars['String']['input']>;
  emailVerificationTokenExpiry?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  isEmailVerified?: InputMaybe<BoolFilter>;
  passwordHash?: InputMaybe<StringFilter>;
  referralCode?: InputMaybe<Scalars['String']['input']>;
  referredBy?: InputMaybe<StringNullableFilter>;
  resellerPaymentsMade?: InputMaybe<ResellerPaymentListRelationFilter>;
  resellerPaymentsReceived?: InputMaybe<ResellerPaymentListRelationFilter>;
  resellerProfile?: InputMaybe<ResellerProfileNullableScalarRelationFilter>;
  role?: InputMaybe<RoleScalarRelationFilter>;
  roleId?: InputMaybe<StringFilter>;
  supportMessages?: InputMaybe<SupportMessageListRelationFilter>;
  tier?: InputMaybe<EnumUserTierNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type VariantFacetValue = {
  __typename?: 'VariantFacetValue';
  facet: Facet;
  facetId: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  productVariantId: Scalars['String']['output'];
  value: Scalars['String']['output'];
  variant: ProductVariant;
};

export type VariantFacetValueCreateManyFacetInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type VariantFacetValueCreateManyFacetInputEnvelope = {
  data: Array<VariantFacetValueCreateManyFacetInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type VariantFacetValueCreateManyVariantInput = {
  facetId: Scalars['String']['input'];
  id?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export type VariantFacetValueCreateManyVariantInputEnvelope = {
  data: Array<VariantFacetValueCreateManyVariantInput>;
  skipDuplicates?: InputMaybe<Scalars['Boolean']['input']>;
};

export type VariantFacetValueCreateNestedManyWithoutFacetInput = {
  connect?: InputMaybe<Array<VariantFacetValueWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<VariantFacetValueCreateOrConnectWithoutFacetInput>>;
  create?: InputMaybe<Array<VariantFacetValueCreateWithoutFacetInput>>;
  createMany?: InputMaybe<VariantFacetValueCreateManyFacetInputEnvelope>;
};

export type VariantFacetValueCreateNestedManyWithoutVariantInput = {
  connect?: InputMaybe<Array<VariantFacetValueWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<VariantFacetValueCreateOrConnectWithoutVariantInput>>;
  create?: InputMaybe<Array<VariantFacetValueCreateWithoutVariantInput>>;
  createMany?: InputMaybe<VariantFacetValueCreateManyVariantInputEnvelope>;
};

export type VariantFacetValueCreateOrConnectWithoutFacetInput = {
  create: VariantFacetValueCreateWithoutFacetInput;
  where: VariantFacetValueWhereUniqueInput;
};

export type VariantFacetValueCreateOrConnectWithoutVariantInput = {
  create: VariantFacetValueCreateWithoutVariantInput;
  where: VariantFacetValueWhereUniqueInput;
};

export type VariantFacetValueCreateWithoutFacetInput = {
  id?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
  variant: ProductVariantCreateNestedOneWithoutFacetsInput;
};

export type VariantFacetValueCreateWithoutVariantInput = {
  facet: FacetCreateNestedOneWithoutVariantsInput;
  id?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

export type VariantFacetValueListRelationFilter = {
  every?: InputMaybe<VariantFacetValueWhereInput>;
  none?: InputMaybe<VariantFacetValueWhereInput>;
  some?: InputMaybe<VariantFacetValueWhereInput>;
};

export type VariantFacetValueOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type VariantFacetValueScalarWhereInput = {
  AND?: InputMaybe<Array<VariantFacetValueScalarWhereInput>>;
  NOT?: InputMaybe<Array<VariantFacetValueScalarWhereInput>>;
  OR?: InputMaybe<Array<VariantFacetValueScalarWhereInput>>;
  facetId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
};

export type VariantFacetValueUpdateManyMutationInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type VariantFacetValueUpdateManyWithWhereWithoutFacetInput = {
  data: VariantFacetValueUpdateManyMutationInput;
  where: VariantFacetValueScalarWhereInput;
};

export type VariantFacetValueUpdateManyWithWhereWithoutVariantInput = {
  data: VariantFacetValueUpdateManyMutationInput;
  where: VariantFacetValueScalarWhereInput;
};

export type VariantFacetValueUpdateManyWithoutFacetNestedInput = {
  connect?: InputMaybe<Array<VariantFacetValueWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<VariantFacetValueCreateOrConnectWithoutFacetInput>>;
  create?: InputMaybe<Array<VariantFacetValueCreateWithoutFacetInput>>;
  createMany?: InputMaybe<VariantFacetValueCreateManyFacetInputEnvelope>;
  delete?: InputMaybe<Array<VariantFacetValueWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<VariantFacetValueScalarWhereInput>>;
  disconnect?: InputMaybe<Array<VariantFacetValueWhereUniqueInput>>;
  set?: InputMaybe<Array<VariantFacetValueWhereUniqueInput>>;
  update?: InputMaybe<Array<VariantFacetValueUpdateWithWhereUniqueWithoutFacetInput>>;
  updateMany?: InputMaybe<Array<VariantFacetValueUpdateManyWithWhereWithoutFacetInput>>;
  upsert?: InputMaybe<Array<VariantFacetValueUpsertWithWhereUniqueWithoutFacetInput>>;
};

export type VariantFacetValueUpdateManyWithoutVariantNestedInput = {
  connect?: InputMaybe<Array<VariantFacetValueWhereUniqueInput>>;
  connectOrCreate?: InputMaybe<Array<VariantFacetValueCreateOrConnectWithoutVariantInput>>;
  create?: InputMaybe<Array<VariantFacetValueCreateWithoutVariantInput>>;
  createMany?: InputMaybe<VariantFacetValueCreateManyVariantInputEnvelope>;
  delete?: InputMaybe<Array<VariantFacetValueWhereUniqueInput>>;
  deleteMany?: InputMaybe<Array<VariantFacetValueScalarWhereInput>>;
  disconnect?: InputMaybe<Array<VariantFacetValueWhereUniqueInput>>;
  set?: InputMaybe<Array<VariantFacetValueWhereUniqueInput>>;
  update?: InputMaybe<Array<VariantFacetValueUpdateWithWhereUniqueWithoutVariantInput>>;
  updateMany?: InputMaybe<Array<VariantFacetValueUpdateManyWithWhereWithoutVariantInput>>;
  upsert?: InputMaybe<Array<VariantFacetValueUpsertWithWhereUniqueWithoutVariantInput>>;
};

export type VariantFacetValueUpdateWithWhereUniqueWithoutFacetInput = {
  data: VariantFacetValueUpdateWithoutFacetInput;
  where: VariantFacetValueWhereUniqueInput;
};

export type VariantFacetValueUpdateWithWhereUniqueWithoutVariantInput = {
  data: VariantFacetValueUpdateWithoutVariantInput;
  where: VariantFacetValueWhereUniqueInput;
};

export type VariantFacetValueUpdateWithoutFacetInput = {
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
  variant?: InputMaybe<ProductVariantUpdateOneRequiredWithoutFacetsNestedInput>;
};

export type VariantFacetValueUpdateWithoutVariantInput = {
  facet?: InputMaybe<FacetUpdateOneRequiredWithoutVariantsNestedInput>;
  id?: InputMaybe<StringFieldUpdateOperationsInput>;
  value?: InputMaybe<StringFieldUpdateOperationsInput>;
};

export type VariantFacetValueUpsertWithWhereUniqueWithoutFacetInput = {
  create: VariantFacetValueCreateWithoutFacetInput;
  update: VariantFacetValueUpdateWithoutFacetInput;
  where: VariantFacetValueWhereUniqueInput;
};

export type VariantFacetValueUpsertWithWhereUniqueWithoutVariantInput = {
  create: VariantFacetValueCreateWithoutVariantInput;
  update: VariantFacetValueUpdateWithoutVariantInput;
  where: VariantFacetValueWhereUniqueInput;
};

export type VariantFacetValueVariant_Facet_Value_UniqueCompoundUniqueInput = {
  facetId: Scalars['String']['input'];
  productVariantId: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

export type VariantFacetValueWhereInput = {
  AND?: InputMaybe<Array<VariantFacetValueWhereInput>>;
  NOT?: InputMaybe<Array<VariantFacetValueWhereInput>>;
  OR?: InputMaybe<Array<VariantFacetValueWhereInput>>;
  facet?: InputMaybe<FacetScalarRelationFilter>;
  facetId?: InputMaybe<StringFilter>;
  id?: InputMaybe<StringFilter>;
  productVariantId?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
  variant?: InputMaybe<ProductVariantScalarRelationFilter>;
};

export type VariantFacetValueWhereUniqueInput = {
  AND?: InputMaybe<Array<VariantFacetValueWhereInput>>;
  NOT?: InputMaybe<Array<VariantFacetValueWhereInput>>;
  OR?: InputMaybe<Array<VariantFacetValueWhereInput>>;
  facet?: InputMaybe<FacetScalarRelationFilter>;
  facetId?: InputMaybe<StringFilter>;
  id?: InputMaybe<Scalars['String']['input']>;
  productVariantId?: InputMaybe<StringFilter>;
  value?: InputMaybe<StringFilter>;
  variant?: InputMaybe<ProductVariantScalarRelationFilter>;
  variant_facet_value_unique?: InputMaybe<VariantFacetValueVariant_Facet_Value_UniqueCompoundUniqueInput>;
};

export type VariantMonthlySales = {
  __typename?: 'VariantMonthlySales';
  productVariantId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
};

export type VariantSalesWithDetails = {
  __typename?: 'VariantSalesWithDetails';
  barcode?: Maybe<Scalars['String']['output']>;
  productId?: Maybe<Scalars['String']['output']>;
  productName?: Maybe<Scalars['String']['output']>;
  productVariantId: Scalars['String']['output'];
  quantity: Scalars['Int']['output'];
};

export type VariantStockTotal = {
  __typename?: 'VariantStockTotal';
  available: Scalars['Float']['output'];
  onHand: Scalars['Float']['output'];
  reserved: Scalars['Float']['output'];
  variantId: Scalars['String']['output'];
};

export type VariantTierPrice = {
  __typename?: 'VariantTierPrice';
  price: Scalars['Float']['output'];
  productVariantId: Scalars['String']['output'];
  tier: UserTier;
};

export type MonthlySalesSummaryQueryVariables = Exact<{
  month?: InputMaybe<Scalars['String']['input']>;
}>;


export type MonthlySalesSummaryQuery = { __typename?: 'Query', monthlySalesSummary: { __typename?: 'MonthlySalesSummary', month: string, totalSold: number, totalReturned: number } };

export type MonthlySalesSummaryByStoreQueryVariables = Exact<{
  storeId: Scalars['String']['input'];
  month?: InputMaybe<Scalars['String']['input']>;
}>;


export type MonthlySalesSummaryByStoreQuery = { __typename?: 'Query', monthlySalesSummaryByStore: { __typename?: 'MonthlySalesSummary', month: string, totalSold: number, totalReturned: number } };

export type TopSellingVariantsDetailedQueryVariables = Exact<{
  month?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type TopSellingVariantsDetailedQuery = { __typename?: 'Query', topSellingVariantsDetailed: Array<{ __typename?: 'VariantSalesWithDetails', productVariantId: string, productName?: string | null, quantity: number }> };

export type TopSellingVariantsByStoreQueryVariables = Exact<{
  storeId: Scalars['String']['input'];
  month?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type TopSellingVariantsByStoreQuery = { __typename?: 'Query', topSellingVariantsByStore: Array<{ __typename?: 'VariantSalesWithDetails', productVariantId: string, productName?: string | null, quantity: number }> };

export type AssetAssignmentsQueryVariables = Exact<{
  entityType: AssetEntityType;
  entityId: Scalars['String']['input'];
}>;


export type AssetAssignmentsQuery = { __typename?: 'Query', assetAssignments: Array<{ __typename?: 'AssetAssignment', id: string, assetId: string, entityType: AssetEntityType, entityId: string, isPrimary: boolean, createdAt: any, updatedAt: any, asset: { __typename?: 'Asset', id: string, kind: AssetKind, url: string, filename?: string | null, mimetype?: string | null, size?: number | null, metadata?: any | null, createdAt: any } }> };

export type PrimaryAssetAssignmentQueryVariables = Exact<{
  entityType: AssetEntityType;
  entityId: Scalars['String']['input'];
}>;


export type PrimaryAssetAssignmentQuery = { __typename?: 'Query', primaryAssetAssignment?: { __typename?: 'AssetAssignment', id: string, assetId: string, entityType: AssetEntityType, entityId: string, isPrimary: boolean, asset: { __typename?: 'Asset', id: string, kind: AssetKind, url: string, filename?: string | null, mimetype?: string | null } } | null };

export type AssignAssetMutationVariables = Exact<{
  assetId: Scalars['String']['input'];
  entityType: AssetEntityType;
  entityId: Scalars['String']['input'];
  isPrimary?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type AssignAssetMutation = { __typename?: 'Mutation', assignAsset: { __typename?: 'AssetAssignment', id: string, assetId: string, entityType: AssetEntityType, entityId: string, isPrimary: boolean } };

export type UnassignAssetMutationVariables = Exact<{
  assetId: Scalars['String']['input'];
  entityType: AssetEntityType;
  entityId: Scalars['String']['input'];
}>;


export type UnassignAssetMutation = { __typename?: 'Mutation', unassignAsset: boolean };

export type RemoveAssetMutationVariables = Exact<{
  assetId: Scalars['String']['input'];
}>;


export type RemoveAssetMutation = { __typename?: 'Mutation', removeAsset: boolean };

export type AssetsQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
}>;


export type AssetsQuery = { __typename?: 'Query', assets: Array<{ __typename?: 'Asset', id: string, kind: AssetKind, bucket: string, key: string, url: string, filename?: string | null, mimetype?: string | null, size?: number | null, createdAt: any, updatedAt: any, assignments?: Array<{ __typename?: 'AssetAssignment', id: string, entityType: AssetEntityType, entityId: string, isPrimary: boolean }> | null }> };

export type LoginMutationVariables = Exact<{
  input: LoginInput;
}>;


export type LoginMutation = { __typename?: 'Mutation', login: { __typename?: 'AuthResponse', accessToken: string, user: { __typename?: 'User', id: string, email: string, role: { __typename?: 'Role', id: string, name: string } } } };

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = { __typename?: 'Query', me: { __typename?: 'User', id: string, email: string, role: { __typename?: 'Role', id: string, name: string, permissions?: Array<{ __typename?: 'Permission', id: string, name: string, module: string, action: string }> | null }, customerProfile?: { __typename?: 'CustomerProfile', fullName: string, email?: string | null, phone?: string | null } | null } };

export type ChangePasswordMutationVariables = Exact<{
  input: ChangePasswordInput;
}>;


export type ChangePasswordMutation = { __typename?: 'Mutation', changePassword: boolean };

export type UpdateMyProfileMutationVariables = Exact<{
  input: UpdateCustomerProfileInput;
}>;


export type UpdateMyProfileMutation = { __typename?: 'Mutation', updateMyProfile: { __typename?: 'CustomerProfile', userId: string, fullName: string, email?: string | null, phone?: string | null, preferredStore?: { __typename?: 'Store', id: string, name: string } | null } };

export type CollectionsQueryVariables = Exact<{ [key: string]: never; }>;


export type CollectionsQuery = { __typename?: 'Query', collections: Array<{ __typename?: 'CollectionGQL', id: string, name: string, code: string, target: CollectionTarget, filters: any, createdAt: any }> };

export type CreateCollectionMutationVariables = Exact<{
  input: CreateCollectionInput;
}>;


export type CreateCollectionMutation = { __typename?: 'Mutation', createCollection: { __typename?: 'CollectionGQL', id: string } };

export type UpdateCollectionMutationVariables = Exact<{
  input: UpdateCollectionInput;
}>;


export type UpdateCollectionMutation = { __typename?: 'Mutation', updateCollection: { __typename?: 'CollectionGQL', id: string } };

export type DeleteCollectionMutationVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type DeleteCollectionMutation = { __typename?: 'Mutation', deleteCollection: boolean };

export type CollectionMembersCountQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type CollectionMembersCountQuery = { __typename?: 'Query', collectionMembersCount: number };

export type CollectionVariantsQueryVariables = Exact<{
  id: Scalars['String']['input'];
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
}>;


export type CollectionVariantsQuery = { __typename?: 'Query', collectionVariants: Array<{ __typename?: 'ProductVariant', id: string, name?: string | null, barcode?: string | null, product?: { __typename?: 'Product', id: string, name: string } | null }> };

export type CollectionProductsQueryVariables = Exact<{
  id: Scalars['String']['input'];
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
}>;


export type CollectionProductsQuery = { __typename?: 'Query', collectionProducts: Array<{ __typename?: 'Product', id: string, name: string, barcode?: string | null }> };

export type CustomersQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserWhereInput>;
}>;


export type CustomersQuery = { __typename?: 'Query', listUsers: Array<{ __typename?: 'User', id: string, email: string, customerProfile?: { __typename?: 'CustomerProfile', fullName: string, email?: string | null, phone?: string | null, profileStatus: ProfileStatus, preferredStore?: { __typename?: 'Store', id: string, name: string } | null } | null }> };

export type CustomerQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type CustomerQuery = { __typename?: 'Query', findUniqueUser: { __typename?: 'User', id: string, email: string, customerProfile?: { __typename?: 'CustomerProfile', fullName: string, email?: string | null, phone?: string | null, profileStatus: ProfileStatus, preferredStore?: { __typename?: 'Store', id: string, name: string } | null, sales?: Array<{ __typename?: 'ConsumerSale', id: string, status: SaleStatus, createdAt: any, totalAmount: number, store: { __typename?: 'Store', id: string, name: string }, receipt?: { __typename?: 'ConsumerReceipt', id: string, issuedAt: any, consumerSaleId: string } | null }> | null } | null } };

export type StoresForCustomersQueryVariables = Exact<{ [key: string]: never; }>;


export type StoresForCustomersQuery = { __typename?: 'Query', listStores: Array<{ __typename?: 'Store', id: string, name: string }> };

export type AdminUpdateCustomerProfileMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  input: AdminUpdateCustomerProfileInput;
}>;


export type AdminUpdateCustomerProfileMutation = { __typename?: 'Mutation', adminUpdateCustomerProfile: { __typename?: 'CustomerProfile', userId: string, profileStatus: ProfileStatus } };

export type AdminCreateCustomerMutationVariables = Exact<{
  input: AdminCreateCustomerInput;
}>;


export type AdminCreateCustomerMutation = { __typename?: 'Mutation', adminCreateCustomer: { __typename?: 'User', id: string, email: string, customerProfile?: { __typename?: 'CustomerProfile', fullName: string } | null } };

export type ConsumerSalesByCustomerQueryVariables = Exact<{
  customerId: Scalars['String']['input'];
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['String']['input']>;
  cursorId?: InputMaybe<Scalars['String']['input']>;
}>;


export type ConsumerSalesByCustomerQuery = { __typename?: 'Query', consumerSalesByCustomer: Array<{ __typename?: 'ConsumerSale', id: string, status: SaleStatus, totalAmount: number, createdAt: any, store: { __typename?: 'Store', id: string, name: string } }> };

export type ConsumerReceiptsByCustomerQueryVariables = Exact<{
  customerId: Scalars['String']['input'];
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  order?: InputMaybe<Scalars['String']['input']>;
  cursorId?: InputMaybe<Scalars['String']['input']>;
}>;


export type ConsumerReceiptsByCustomerQuery = { __typename?: 'Query', consumerReceiptsByCustomer: Array<{ __typename?: 'ConsumerReceipt', id: string, issuedAt: any, consumerSaleId: string }> };

export type CompleteCustomerProfileMutationVariables = Exact<{
  input: UpdateCustomerProfileInput;
}>;


export type CompleteCustomerProfileMutation = { __typename?: 'Mutation', completeCustomerProfile: { __typename?: 'CustomerProfile', userId: string, profileStatus: ProfileStatus, fullName: string, email?: string | null, phone?: string | null } };

export type SignupCustomerMutationVariables = Exact<{
  input: CreateUserInput;
}>;


export type SignupCustomerMutation = { __typename?: 'Mutation', signupCustomer: { __typename?: 'AuthResponse', accessToken: string, user: { __typename?: 'User', id: string, email: string } } };

export type DevCountsQueryVariables = Exact<{ [key: string]: never; }>;


export type DevCountsQuery = { __typename?: 'Query', devCounts: { __typename?: 'DevCounts', invoiceImports: number, purchaseOrders: number, orphanVariants: number } };

export type DevPurgeInvoiceImportsMutationVariables = Exact<{
  filter?: InputMaybe<DevPurgeFilter>;
}>;


export type DevPurgeInvoiceImportsMutation = { __typename?: 'Mutation', devPurgeInvoiceImports: number };

export type DevPurgePurchaseOrdersMutationVariables = Exact<{
  filter?: InputMaybe<DevPurgeFilter>;
}>;


export type DevPurgePurchaseOrdersMutation = { __typename?: 'Mutation', devPurgePurchaseOrders: number };

export type DevPurgeOrphanVariantsMutationVariables = Exact<{
  filter?: InputMaybe<DevPurgeFilter>;
}>;


export type DevPurgeOrphanVariantsMutation = { __typename?: 'Mutation', devPurgeOrphanVariants: number };

export type DevPurgeProductsMutationVariables = Exact<{
  filter?: InputMaybe<DevPurgeFilter>;
}>;


export type DevPurgeProductsMutation = { __typename?: 'Mutation', devPurgeProducts: number };

export type AssignFulfillmentPersonnelMutationVariables = Exact<{
  input: AssignFulfillmentPersonnelInput;
}>;


export type AssignFulfillmentPersonnelMutation = { __typename?: 'Mutation', assignFulfillmentPersonnel: { __typename?: 'Fulfillment', id: string, status: FulfillmentStatus, deliveryPersonnelId?: string | null, updatedAt: any } };

export type UpdateFulfillmentStatusMutationVariables = Exact<{
  input: UpdateFulfillmentStatusInput;
}>;


export type UpdateFulfillmentStatusMutation = { __typename?: 'Mutation', updateFulfillmentStatus: { __typename?: 'Fulfillment', id: string, status: FulfillmentStatus, updatedAt: any } };

export type InvoiceImportQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type InvoiceImportQuery = { __typename?: 'Query', invoiceImport?: { __typename?: 'InvoiceImport', id: string, url: string, supplierName?: string | null, storeId?: string | null, status: InvoiceImportStatus, message?: string | null, createdAt: any, parsed?: any | null } | null };

export type StoresForImportDetailQueryVariables = Exact<{ [key: string]: never; }>;


export type StoresForImportDetailQuery = { __typename?: 'Query', listStores: Array<{ __typename?: 'Store', id: string, name: string }> };

export type ApproveInvoiceImportMutationVariables = Exact<{
  input: ApproveInvoiceImportInput;
}>;


export type ApproveInvoiceImportMutation = { __typename?: 'Mutation', adminApproveInvoiceImport: { __typename?: 'ApproveInvoiceResult', purchaseOrderId?: string | null, invoiceImport: { __typename?: 'InvoiceImport', id: string, status: InvoiceImportStatus, message?: string | null } } };

export type ReprocessInvoiceImportMutationVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type ReprocessInvoiceImportMutation = { __typename?: 'Mutation', adminReprocessInvoiceImport: { __typename?: 'InvoiceImport', id: string, status: InvoiceImportStatus, message?: string | null, parsed?: any | null } };

export type UpdateInvoiceImportMutationVariables = Exact<{
  input: UpdateInvoiceImportInput;
}>;


export type UpdateInvoiceImportMutation = { __typename?: 'Mutation', adminUpdateInvoiceImport: { __typename?: 'InvoiceImport', id: string, url: string, supplierName?: string | null, storeId?: string | null, parsed?: any | null } };

export type InvoiceImportsQueryVariables = Exact<{ [key: string]: never; }>;


export type InvoiceImportsQuery = { __typename?: 'Query', invoiceImports: Array<{ __typename?: 'InvoiceImport', id: string, url: string, supplierName?: string | null, storeId?: string | null, status: InvoiceImportStatus, createdAt: any }> };

export type CreateInvoiceImportMutationVariables = Exact<{
  input: CreateInvoiceImportInput;
}>;


export type CreateInvoiceImportMutation = { __typename?: 'Mutation', adminCreateInvoiceImport: { __typename?: 'InvoiceImport', id: string } };

export type LowStockQueryVariables = Exact<{
  storeId?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type LowStockQuery = { __typename?: 'Query', lowStockCandidates: Array<{ __typename?: 'LowStockCandidate', storeId: string, storeName?: string | null, productVariantId: string, productId?: string | null, productName?: string | null, barcode?: string | null, quantity?: number | null, reorderPoint?: number | null, reorderQty?: number | null, supplierId?: string | null, supplierName?: string | null, supplierDefaultCost?: number | null, supplierLeadTimeDays?: number | null, supplierIsPreferred?: boolean | null, supplierCount?: number | null }> };

export type RunScanMutationVariables = Exact<{ [key: string]: never; }>;


export type RunScanMutation = { __typename?: 'Mutation', runLowStockScanNow: boolean };

export type CreateLowStockReqMutationVariables = Exact<{
  storeId: Scalars['String']['input'];
  requestedById: Scalars['String']['input'];
}>;


export type CreateLowStockReqMutation = { __typename?: 'Mutation', createRequisitionFromLowStock?: string | null };

export type CreateAndIssuePreferredMutationVariables = Exact<{
  storeId: Scalars['String']['input'];
  requestedById: Scalars['String']['input'];
}>;


export type CreateAndIssuePreferredMutation = { __typename?: 'Mutation', createLowStockRequisitionAndIssuePreferred?: string | null };

export type HeaderNotificationsQueryVariables = Exact<{ [key: string]: never; }>;


export type HeaderNotificationsQuery = { __typename?: 'Query', notifications: Array<{ __typename?: 'Notification', id: string, isRead: boolean, type: string, message: string, createdAt: any }> };

export type OutboxStatusQueryVariables = Exact<{ [key: string]: never; }>;


export type OutboxStatusQuery = { __typename?: 'Query', outboxStatus: { __typename?: 'OutboxStatusCounts', pending: number, failed: number, published: number } };

export type LastFailedOutboxEventsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type LastFailedOutboxEventsQuery = { __typename?: 'Query', lastFailedOutboxEvents: Array<{ __typename?: 'OutboxEvent', id: string, type: string, lastError?: string | null, createdAt: any }> };

export type OutboxStatusByTypeQueryVariables = Exact<{
  types?: InputMaybe<Array<Scalars['String']['input']> | Scalars['String']['input']>;
}>;


export type OutboxStatusByTypeQuery = { __typename?: 'Query', outboxStatusByType: Array<{ __typename?: 'OutboxTypeCount', type: string, pending: number, failed: number, published: number }> };

export type ProcessOutboxMutationVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<OutboxStatus>;
}>;


export type ProcessOutboxMutation = { __typename?: 'Mutation', processOutbox: number };

export type RetryOutboxFailedMutationVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
}>;


export type RetryOutboxFailedMutation = { __typename?: 'Mutation', retryOutboxFailed: number };

export type StoresForPaymentsQueryVariables = Exact<{ [key: string]: never; }>;


export type StoresForPaymentsQuery = { __typename?: 'Query', listStores: Array<{ __typename?: 'Store', id: string, name: string }> };

export type StorePaymentsSummaryQueryVariables = Exact<{
  storeId: Scalars['String']['input'];
  month?: InputMaybe<Scalars['String']['input']>;
}>;


export type StorePaymentsSummaryQuery = { __typename?: 'Query', storePaymentsSummary: { __typename?: 'StorePaymentsSummary', storeId: string, month: string, consumerPaid: number, resellerPaid: number, totalPaid: number } };

export type DailyPaymentsSeriesQueryVariables = Exact<{
  month?: InputMaybe<Scalars['String']['input']>;
  storeId?: InputMaybe<Scalars['String']['input']>;
}>;


export type DailyPaymentsSeriesQuery = { __typename?: 'Query', dailyPaymentsSeries: Array<{ __typename?: 'PaymentDaySeries', date: string, consumerPaid: number, resellerPaid: number, totalPaid: number }> };

export type StorePaymentsSummaryRangeQueryVariables = Exact<{
  storeId: Scalars['String']['input'];
  start: Scalars['DateTime']['input'];
  end: Scalars['DateTime']['input'];
}>;


export type StorePaymentsSummaryRangeQuery = { __typename?: 'Query', storePaymentsSummaryRange: { __typename?: 'StorePaymentsSummary', storeId: string, month: string, consumerPaid: number, resellerPaid: number, totalPaid: number } };

export type DailyPaymentsSeriesRangeQueryVariables = Exact<{
  start: Scalars['DateTime']['input'];
  end: Scalars['DateTime']['input'];
  storeId?: InputMaybe<Scalars['String']['input']>;
}>;


export type DailyPaymentsSeriesRangeQuery = { __typename?: 'Query', dailyPaymentsSeriesRange: Array<{ __typename?: 'PaymentDaySeries', date: string, consumerPaid: number, resellerPaid: number, totalPaid: number }> };

export type ProductFacetsQueryVariables = Exact<{
  productId: Scalars['String']['input'];
}>;


export type ProductFacetsQuery = { __typename?: 'Query', productFacets: Array<{ __typename?: 'FacetAssignment', value: string, facet: { __typename?: 'FacetGQL', id: string, name: string, code: string, values: Array<string>, isPrivate: boolean } }> };

export type AssignFacetToProductMutationVariables = Exact<{
  productId: Scalars['String']['input'];
  facetId: Scalars['String']['input'];
  value: Scalars['String']['input'];
}>;


export type AssignFacetToProductMutation = { __typename?: 'Mutation', assignFacetToProduct: string };

export type RemoveFacetFromProductMutationVariables = Exact<{
  productId: Scalars['String']['input'];
  facetId: Scalars['String']['input'];
  value: Scalars['String']['input'];
}>;


export type RemoveFacetFromProductMutation = { __typename?: 'Mutation', removeFacetFromProduct: string };

export type CreateProductVariantMutationVariables = Exact<{
  data: ProductVariantCreateInput;
}>;


export type CreateProductVariantMutation = { __typename?: 'Mutation', createProductVariant?: { __typename?: 'ProductVariant', id: string } | null };

export type UpdateProductMutationVariables = Exact<{
  id: Scalars['String']['input'];
  data: ProductUpdateInput;
}>;


export type UpdateProductMutation = { __typename?: 'Mutation', updateProduct?: { __typename?: 'Product', id: string } | null };

export type UpdateProductVariantMutationVariables = Exact<{
  id: Scalars['String']['input'];
  data: ProductVariantUpdateInput;
}>;


export type UpdateProductVariantMutation = { __typename?: 'Mutation', updateProductVariant?: { __typename?: 'ProductVariant', id: string } | null };

export type DeleteProductVariantMutationVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type DeleteProductVariantMutation = { __typename?: 'Mutation', deleteProductVariant?: { __typename?: 'ProductVariant', id: string } | null };

export type StockTotalsByProductQueryVariables = Exact<{
  productId: Scalars['String']['input'];
}>;


export type StockTotalsByProductQuery = { __typename?: 'Query', stockTotalsByProduct: Array<{ __typename?: 'VariantStockTotal', variantId: string, onHand: number, reserved: number, available: number }> };

export type StockTotalsByProductStoreQueryVariables = Exact<{
  productId: Scalars['String']['input'];
  storeId: Scalars['String']['input'];
}>;


export type StockTotalsByProductStoreQuery = { __typename?: 'Query', stockTotalsByProductStore: Array<{ __typename?: 'VariantStockTotal', variantId: string, onHand: number, reserved: number, available: number }> };

export type StockByVariantQueryVariables = Exact<{
  productVariantId: Scalars['ID']['input'];
}>;


export type StockByVariantQuery = { __typename?: 'Query', stock: Array<{ __typename?: 'Stock', id: string, quantity: number, reserved: number, store: { __typename?: 'Store', id: string, name: string } }> };

export type ProductsQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductWhereInput>;
}>;


export type ProductsQuery = { __typename?: 'Query', listProducts: Array<{ __typename?: 'Product', id: string, name: string, barcode?: string | null }> };

export type CreateProductMutationVariables = Exact<{
  data: ProductCreateInput;
}>;


export type CreateProductMutation = { __typename?: 'Mutation', createProduct?: { __typename?: 'Product', id: string } | null };

export type ProductQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type ProductQuery = { __typename?: 'Query', findUniqueProduct?: { __typename?: 'Product', id: string, name: string, barcode?: string | null, description?: string | null, createdAt: any, variants?: Array<{ __typename?: 'ProductVariant', id: string, name?: string | null, barcode?: string | null, price: number, resellerPrice: number, createdAt: any }> | null } | null };

export type PurchaseOrderQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type PurchaseOrderQuery = { __typename?: 'Query', purchaseOrder: { __typename?: 'PurchaseOrder', id: string, supplierId: string, status: PurchaseOrderStatus, phase: PurchasePhase, totalAmount: number, createdAt: any, invoiceNumber: string, supplier: { __typename?: 'Supplier', id: string, name: string }, items?: Array<{ __typename?: 'PurchaseOrderItem', productVariantId: string, quantity: number, unitCost: number, productVariant: { __typename?: 'ProductVariant', id: string, name?: string | null, barcode?: string | null, product?: { __typename?: 'Product', name: string } | null } }> | null }, purchaseOrderReceiptProgress: Array<{ __typename?: 'PurchaseOrderReceiptProgress', productVariantId: string, orderedQty: number, receivedQty: number }> };

export type PurchaseOrdersQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
}>;


export type PurchaseOrdersQuery = { __typename?: 'Query', purchaseOrders: Array<{ __typename?: 'PurchaseOrder', id: string, invoiceNumber: string, status: PurchaseOrderStatus, phase: PurchasePhase, createdAt: any, supplier: { __typename?: 'Supplier', id: string, name: string } }> };

export type PurchaseOrdersByStatusQueryVariables = Exact<{
  status: Scalars['String']['input'];
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
}>;


export type PurchaseOrdersByStatusQuery = { __typename?: 'Query', purchaseOrdersByStatus: Array<{ __typename?: 'PurchaseOrder', id: string, invoiceNumber: string, status: PurchaseOrderStatus, phase: PurchasePhase, createdAt: any, supplier: { __typename?: 'Supplier', id: string, name: string } }> };

export type PurchaseOrdersByPhaseQueryVariables = Exact<{
  phase: Scalars['String']['input'];
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
}>;


export type PurchaseOrdersByPhaseQuery = { __typename?: 'Query', purchaseOrdersByPhase: Array<{ __typename?: 'PurchaseOrder', id: string, invoiceNumber: string, status: PurchaseOrderStatus, phase: PurchasePhase, createdAt: any, supplier: { __typename?: 'Supplier', id: string, name: string } }> };

export type PurchaseOrdersCountQueryVariables = Exact<{
  status?: InputMaybe<Scalars['String']['input']>;
  phase?: InputMaybe<Scalars['String']['input']>;
}>;


export type PurchaseOrdersCountQuery = { __typename?: 'Query', purchaseOrdersCount: number };

export type PurchaseOrdersSearchQueryVariables = Exact<{
  q: Scalars['String']['input'];
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
}>;


export type PurchaseOrdersSearchQuery = { __typename?: 'Query', purchaseOrdersSearch: Array<{ __typename?: 'PurchaseOrder', id: string, invoiceNumber: string, status: PurchaseOrderStatus, phase: PurchasePhase, createdAt: any, supplier: { __typename?: 'Supplier', id: string, name: string } }> };

export type PurchaseOrdersSearchCountQueryVariables = Exact<{
  q: Scalars['String']['input'];
}>;


export type PurchaseOrdersSearchCountQuery = { __typename?: 'Query', purchaseOrdersSearchCount: number };

export type UpdatePoStatusMutationVariables = Exact<{
  input: UpdatePurchaseOrderStatusInput;
}>;


export type UpdatePoStatusMutation = { __typename?: 'Mutation', updatePurchaseOrderStatus: { __typename?: 'PurchaseOrder', id: string, status: PurchaseOrderStatus } };

export type ReceiveStockMutationVariables = Exact<{
  input: ReceiveStockBatchInput;
}>;


export type ReceiveStockMutation = { __typename?: 'Mutation', receiveStockBatch: { __typename?: 'StockReceiptBatch', id: string, storeId: string } };

export type RfqDashboardQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type RfqDashboardQuery = { __typename?: 'Query', rfqDashboard: { __typename?: 'RfqDashboard', draft: number, submitted: number, selected: number, rejected: number, total: number, pendingQuotes: Array<{ __typename?: 'SupplierQuoteSummary', id: string, requisitionId: string, supplierId: string, status: string, validUntil?: any | null, createdAt: any }> }, purchaseRequisitionSummary?: { __typename?: 'RequisitionSummary', id: string, status: string, createdAt: any } | null };

export type QuotesByReqQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type QuotesByReqQuery = { __typename?: 'Query', supplierQuotesByRequisition: Array<{ __typename?: 'SupplierQuoteSummary', id: string, requisitionId: string, supplierId: string, status: string, validUntil?: any | null, createdAt: any }> };

export type IssueRfqPreferredMutationVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type IssueRfqPreferredMutation = { __typename?: 'Mutation', issueRFQPreferred: boolean };

export type SelectSupplierQuoteMutationVariables = Exact<{
  quoteId: Scalars['String']['input'];
  exclusive?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type SelectSupplierQuoteMutation = { __typename?: 'Mutation', selectSupplierQuote: boolean };

export type RejectSupplierQuoteMutationVariables = Exact<{
  quoteId: Scalars['String']['input'];
  reason?: InputMaybe<Scalars['String']['input']>;
}>;


export type RejectSupplierQuoteMutation = { __typename?: 'Mutation', rejectSupplierQuote: boolean };

export type SubmitPurchaseRequisitionMutationVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type SubmitPurchaseRequisitionMutation = { __typename?: 'Mutation', submitPurchaseRequisition: boolean };

export type ApprovePurchaseRequisitionMutationVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type ApprovePurchaseRequisitionMutation = { __typename?: 'Mutation', approvePurchaseRequisition: boolean };

export type RejectPurchaseRequisitionMutationVariables = Exact<{
  id: Scalars['String']['input'];
  reason?: InputMaybe<Scalars['String']['input']>;
}>;


export type RejectPurchaseRequisitionMutation = { __typename?: 'Mutation', rejectPurchaseRequisition: boolean };

export type RequisitionsByStatusQueryVariables = Exact<{
  status: Scalars['String']['input'];
  storeId?: InputMaybe<Scalars['String']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
}>;


export type RequisitionsByStatusQuery = { __typename?: 'Query', requisitionsByStatus: Array<{ __typename?: 'RequisitionSummary', id: string, storeId: string, requestedById: string, status: string, createdAt: any }> };

export type RequisitionsCountByStatusQueryVariables = Exact<{
  status: Scalars['String']['input'];
  storeId?: InputMaybe<Scalars['String']['input']>;
}>;


export type RequisitionsCountByStatusQuery = { __typename?: 'Query', requisitionsCountByStatus: number };

export type RequisitionsByStoreQueryVariables = Exact<{
  storeId: Scalars['String']['input'];
  status?: InputMaybe<Scalars['String']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
}>;


export type RequisitionsByStoreQuery = { __typename?: 'Query', requisitionsByStore: Array<{ __typename?: 'RequisitionSummary', id: string, storeId: string, requestedById: string, status: string, createdAt: any }> };

export type RequisitionsCountByStoreQueryVariables = Exact<{
  storeId: Scalars['String']['input'];
  status?: InputMaybe<Scalars['String']['input']>;
}>;


export type RequisitionsCountByStoreQuery = { __typename?: 'Query', requisitionsCountByStore: number };

export type PendingResellerApplicationsQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type PendingResellerApplicationsQuery = { __typename?: 'Query', pendingResellerApplications: Array<{ __typename?: 'ResellerProfile', userId: string, tier: UserTier, creditLimit: number, requestedAt: any, requestedBillerId?: string | null, biller?: { __typename?: 'User', id: string, email: string } | null, requestedBiller?: { __typename?: 'User', id: string, email: string } | null, user: { __typename?: 'User', id: string, email: string } }> };

export type ListBillersQueryVariables = Exact<{ [key: string]: never; }>;


export type ListBillersQuery = { __typename?: 'Query', listBillers: Array<{ __typename?: 'User', id: string, email: string }> };

export type ApproveResellerMutationVariables = Exact<{
  resellerId: Scalars['String']['input'];
  input: ApproveResellerInput;
}>;


export type ApproveResellerMutation = { __typename?: 'Mutation', approveReseller: { __typename?: 'ResellerProfile', userId: string, profileStatus: ProfileStatus, biller?: { __typename?: 'User', id: string, email: string } | null } };

export type ActivateResellerMutationVariables = Exact<{
  resellerId: Scalars['String']['input'];
  billerId?: InputMaybe<Scalars['String']['input']>;
}>;


export type ActivateResellerMutation = { __typename?: 'Mutation', activateReseller: { __typename?: 'ResellerProfile', userId: string, profileStatus: ProfileStatus, biller?: { __typename?: 'User', id: string, email: string } | null } };

export type RejectResellerMutationVariables = Exact<{
  resellerId: Scalars['String']['input'];
  reason?: InputMaybe<Scalars['String']['input']>;
}>;


export type RejectResellerMutation = { __typename?: 'Mutation', rejectReseller: { __typename?: 'ResellerProfile', userId: string, profileStatus: ProfileStatus, rejectionReason?: string | null } };

export type ResellersQueryVariables = Exact<{
  status?: InputMaybe<Scalars['String']['input']>;
  take?: InputMaybe<Scalars['Int']['input']>;
  q?: InputMaybe<Scalars['String']['input']>;
}>;


export type ResellersQuery = { __typename?: 'Query', resellers: Array<{ __typename?: 'ResellerProfile', userId: string, profileStatus: ProfileStatus, tier: UserTier, creditLimit: number, requestedAt: any, user: { __typename?: 'User', id: string, email: string }, biller?: { __typename?: 'User', id: string, email: string } | null, requestedBiller?: { __typename?: 'User', id: string, email: string } | null }> };

export type ResellerProfileQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type ResellerProfileQuery = { __typename?: 'Query', resellerProfile?: { __typename?: 'ResellerProfile', userId: string, profileStatus: ProfileStatus, tier: UserTier, creditLimit: number, outstandingBalance: number, requestedAt: any, activatedAt?: any | null, rejectedAt?: any | null, rejectionReason?: string | null, biller?: { __typename?: 'User', id: string, email: string } | null, requestedBiller?: { __typename?: 'User', id: string, email: string } | null, user: { __typename?: 'User', id: string, email: string } } | null };

export type ApplyResellerMutationVariables = Exact<{
  input: ApplyResellerInput;
}>;


export type ApplyResellerMutation = { __typename?: 'Mutation', applyReseller: { __typename?: 'ResellerProfile', userId: string, profileStatus: ProfileStatus } };

export type SalesReturnsByStoreQueryVariables = Exact<{
  storeId: Scalars['String']['input'];
}>;


export type SalesReturnsByStoreQuery = { __typename?: 'Query', salesReturnsByStore: Array<{ __typename?: 'SalesReturn', id: string, status: ReturnStatus, createdAt: any, consumerSaleId?: string | null, resellerSaleId?: string | null }> };

export type PurchaseReturnsBySupplierQueryVariables = Exact<{
  supplierId: Scalars['String']['input'];
}>;


export type PurchaseReturnsBySupplierQuery = { __typename?: 'Query', purchaseReturnsBySupplier: Array<{ __typename?: 'PurchaseReturn', id: string, status: ReturnStatus, createdAt: any, supplierId: string }> };

export type UpdateSalesReturnStatusMutationVariables = Exact<{
  input: UpdateSalesReturnStatusInput;
}>;


export type UpdateSalesReturnStatusMutation = { __typename?: 'Mutation', updateSalesReturnStatus: boolean };

export type FulfillPurchaseReturnMutationVariables = Exact<{
  input: FulfillPurchaseReturnInput;
}>;


export type FulfillPurchaseReturnMutation = { __typename?: 'Mutation', fulfillPurchaseReturn: boolean };

export type CreateStaffMutationVariables = Exact<{
  input: CreateStaffInput;
}>;


export type CreateStaffMutation = { __typename?: 'Mutation', createStaff: { __typename?: 'User', id: string, email: string } };

export type AssignBillerMutationVariables = Exact<{
  input: AssignBillerInput;
}>;


export type AssignBillerMutation = { __typename?: 'Mutation', assignBiller: { __typename?: 'ResellerProfile', userId: string, billerId?: string | null } };

export type StaffDetailQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type StaffDetailQuery = { __typename?: 'Query', findUniqueUser: { __typename?: 'User', id: string, email: string, createdAt: any, updatedAt: any, isEmailVerified: boolean, role: { __typename?: 'Role', name: string }, Store?: Array<{ __typename?: 'Store', id: string, name: string, isMain: boolean, location?: string | null }> | null, Notification?: Array<{ __typename?: 'Notification', id: string, type: string, message: string, isRead: boolean, createdAt: any }> | null } };

export type SendUserEmailVerificationMutationVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type SendUserEmailVerificationMutation = { __typename?: 'Mutation', sendUserEmailVerification: boolean };

export type StockQueryVariables = Exact<{
  input?: InputMaybe<QueryStockInput>;
}>;


export type StockQuery = { __typename?: 'Query', stock: Array<{ __typename?: 'Stock', id: string, productVariantId: string, storeId: string, quantity: number, reserved: number, productVariant: { __typename?: 'ProductVariant', id: string, name?: string | null, barcode?: string | null, product?: { __typename?: 'Product', id: string, name: string } | null }, store: { __typename?: 'Store', id: string, name: string } }> };

export type StoresQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<StoreWhereInput>;
}>;


export type StoresQuery = { __typename?: 'Query', listStores: Array<{ __typename?: 'Store', id: string, name: string, location?: string | null, isMain: boolean, manager: { __typename?: 'User', id: string, email: string } }> };

export type StoresWithInvalidManagersQueryVariables = Exact<{ [key: string]: never; }>;


export type StoresWithInvalidManagersQuery = { __typename?: 'Query', storesWithInvalidManagers: Array<{ __typename?: 'StoreManagerDiagnostic', id: string, name: string, managerId: string, managerEmail?: string | null, validManager: boolean }> };

export type ListManagersQueryVariables = Exact<{ [key: string]: never; }>;


export type ListManagersQuery = { __typename?: 'Query', listManagers: Array<{ __typename?: 'User', id: string, email: string, customerProfile?: { __typename?: 'CustomerProfile', fullName: string } | null }> };

export type AssignStoreManagerMutationVariables = Exact<{
  storeId: Scalars['String']['input'];
  managerId: Scalars['String']['input'];
}>;


export type AssignStoreManagerMutation = { __typename?: 'Mutation', assignStoreManager: boolean };

export type BulkAssignStoreManagerMutationVariables = Exact<{
  storeIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
  managerId: Scalars['String']['input'];
}>;


export type BulkAssignStoreManagerMutation = { __typename?: 'Mutation', bulkAssignStoreManager: number };

export type SupplierPaymentsByPoQueryVariables = Exact<{
  purchaseOrderId: Scalars['String']['input'];
}>;


export type SupplierPaymentsByPoQuery = { __typename?: 'Query', supplierPaymentsByPO: Array<{ __typename?: 'SupplierPayment', id: string, amount: number, paymentDate: any, method: string, notes?: string | null }>, purchaseOrder: { __typename?: 'PurchaseOrder', id: string, totalAmount: number, createdAt: any, supplier: { __typename?: 'Supplier', id: string, name: string } } };

export type CreateSupplierPaymentMutationVariables = Exact<{
  input: CreateSupplierPaymentInput;
}>;


export type CreateSupplierPaymentMutation = { __typename?: 'Mutation', createSupplierPayment: { __typename?: 'SupplierPayment', id: string, amount: number, paymentDate: any, method: string } };

export type SupplierStatementDataQueryVariables = Exact<{
  supplierId: Scalars['String']['input'];
}>;


export type SupplierStatementDataQuery = { __typename?: 'Query', purchaseOrdersBySupplier: Array<{ __typename?: 'PurchaseOrder', id: string, totalAmount: number, createdAt: any }>, supplierPaymentsBySupplier: Array<{ __typename?: 'SupplierPayment', id: string, amount: number, paymentDate: any, method: string }> };

export type SupplierAgingDataQueryVariables = Exact<{
  supplierId: Scalars['String']['input'];
}>;


export type SupplierAgingDataQuery = { __typename?: 'Query', purchaseOrdersBySupplier: Array<{ __typename?: 'PurchaseOrder', id: string, totalAmount: number, createdAt: any, dueDate: any, payments?: Array<{ __typename?: 'SupplierPayment', id: string, amount: number }> | null }> };

export type SuppliersQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
}>;


export type SuppliersQuery = { __typename?: 'Query', listSuppliers: Array<{ __typename?: 'Supplier', id: string, name: string, creditLimit: number, currentBalance: number, createdAt: any }> };

export type MySupportMessagesQueryVariables = Exact<{ [key: string]: never; }>;


export type MySupportMessagesQuery = { __typename?: 'Query', mySupportMessages: Array<{ __typename?: 'SupportMessage', id: string, message: string, createdAt: any, isAdmin: boolean }> };

export type RecentSupportThreadsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type RecentSupportThreadsQuery = { __typename?: 'Query', recentSupportThreads: Array<{ __typename?: 'SupportMessage', id: string, userId: string, message: string, createdAt: any, isAdmin: boolean }> };

export type SupportConversationQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type SupportConversationQuery = { __typename?: 'Query', supportConversation: Array<{ __typename?: 'SupportMessage', id: string, message: string, createdAt: any, isAdmin: boolean }> };

export type SendSupportMessageMutationVariables = Exact<{
  message: Scalars['String']['input'];
}>;


export type SendSupportMessageMutation = { __typename?: 'Mutation', sendSupportMessage: { __typename?: 'SupportMessage', id: string, message: string, createdAt: any, isAdmin: boolean } };

export type AdminSendSupportMessageMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  message: Scalars['String']['input'];
}>;


export type AdminSendSupportMessageMutation = { __typename?: 'Mutation', adminSendSupportMessage: { __typename?: 'SupportMessage', id: string, message: string, createdAt: any, isAdmin: boolean } };

export type UsersQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
}>;


export type UsersQuery = { __typename?: 'Query', listUsers: Array<{ __typename?: 'User', id: string, email: string, createdAt: any, isEmailVerified: boolean, role: { __typename?: 'Role', name: string }, customerProfile?: { __typename?: 'CustomerProfile', fullName: string } | null, resellerProfile?: { __typename?: 'ResellerProfile', tier: UserTier } | null }> };

export type ListFacetsQueryVariables = Exact<{ [key: string]: never; }>;


export type ListFacetsQuery = { __typename?: 'Query', listFacets: Array<{ __typename?: 'FacetGQL', id: string, name: string, code: string, values: Array<string>, isPrivate: boolean }> };

export type ListFacetsAllQueryVariables = Exact<{ [key: string]: never; }>;


export type ListFacetsAllQuery = { __typename?: 'Query', listFacets: Array<{ __typename?: 'FacetGQL', id: string, name: string, code: string, values: Array<string>, isPrivate: boolean }> };

export type CreateFacetMutationVariables = Exact<{
  input: CreateFacetInput;
}>;


export type CreateFacetMutation = { __typename?: 'Mutation', createFacet: { __typename?: 'FacetGQL', id: string, name: string, code: string, isPrivate: boolean, values: Array<string> } };

export type UpdateFacetMutationVariables = Exact<{
  input: UpdateFacetInput;
}>;


export type UpdateFacetMutation = { __typename?: 'Mutation', updateFacet: { __typename?: 'FacetGQL', id: string, name: string, code: string, isPrivate: boolean, values: Array<string> } };

export type DeleteFacetMutationVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type DeleteFacetMutation = { __typename?: 'Mutation', deleteFacet: string };

export type VariantFacetsQueryVariables = Exact<{
  productVariantId: Scalars['String']['input'];
}>;


export type VariantFacetsQuery = { __typename?: 'Query', variantFacets: Array<{ __typename?: 'FacetAssignment', value: string, facet: { __typename?: 'FacetGQL', id: string, name: string, code: string, values: Array<string>, isPrivate: boolean } }> };

export type AssignFacetToVariantMutationVariables = Exact<{
  productVariantId: Scalars['String']['input'];
  facetId: Scalars['String']['input'];
  value: Scalars['String']['input'];
}>;


export type AssignFacetToVariantMutation = { __typename?: 'Mutation', assignFacetToVariant: string };

export type RemoveFacetFromVariantMutationVariables = Exact<{
  productVariantId: Scalars['String']['input'];
  facetId: Scalars['String']['input'];
  value: Scalars['String']['input'];
}>;


export type RemoveFacetFromVariantMutation = { __typename?: 'Mutation', removeFacetFromVariant: string };

export type BulkAssignFacetToVariantsMutationVariables = Exact<{
  variantIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
  facetId: Scalars['String']['input'];
  value: Scalars['String']['input'];
}>;


export type BulkAssignFacetToVariantsMutation = { __typename?: 'Mutation', bulkAssignFacetToVariants: number };

export type BulkRemoveFacetFromVariantsMutationVariables = Exact<{
  variantIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
  facetId: Scalars['String']['input'];
  value: Scalars['String']['input'];
}>;


export type BulkRemoveFacetFromVariantsMutation = { __typename?: 'Mutation', bulkRemoveFacetFromVariants: number };

export type BulkAssignFacetToProductsMutationVariables = Exact<{
  productIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
  facetId: Scalars['String']['input'];
  value: Scalars['String']['input'];
}>;


export type BulkAssignFacetToProductsMutation = { __typename?: 'Mutation', bulkAssignFacetToProducts: number };

export type BulkRemoveFacetFromProductsMutationVariables = Exact<{
  productIds: Array<Scalars['String']['input']> | Scalars['String']['input'];
  facetId: Scalars['String']['input'];
  value: Scalars['String']['input'];
}>;


export type BulkRemoveFacetFromProductsMutation = { __typename?: 'Mutation', bulkRemoveFacetFromProducts: number };

export type VariantsQueryVariables = Exact<{
  take?: InputMaybe<Scalars['Int']['input']>;
  skip?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ProductVariantWhereInput>;
}>;


export type VariantsQuery = { __typename?: 'Query', listProductVariants: Array<{ __typename?: 'ProductVariant', id: string, name?: string | null, barcode?: string | null, price: number, resellerPrice: number, createdAt: any, product?: { __typename?: 'Product', id: string, name: string } | null, stockItems?: Array<{ __typename?: 'Stock', quantity: number, reserved: number }> | null }> };

export type ProductVariantsCountQueryVariables = Exact<{
  where?: InputMaybe<ProductVariantWhereInput>;
}>;


export type ProductVariantsCountQuery = { __typename?: 'Query', productVariantsCount: number };

export type VariantQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type VariantQuery = { __typename?: 'Query', findUniqueProductVariant?: { __typename?: 'ProductVariant', id: string, name?: string | null, barcode?: string | null, price: number, resellerPrice: number, createdAt: any, product?: { __typename?: 'Product', id: string, name: string } | null } | null };

export type VerifyEmailMutationVariables = Exact<{
  token: Scalars['String']['input'];
}>;


export type VerifyEmailMutation = { __typename?: 'Mutation', verifyEmail: boolean };

export type AdminProcessInvoiceUrlMutationVariables = Exact<{
  input: ProcessInvoiceUrlInput;
}>;


export type AdminProcessInvoiceUrlMutation = { __typename?: 'Mutation', adminProcessInvoiceUrl: { __typename?: 'ProcessInvoiceResult', status: string, message?: string | null, supplierId?: string | null, supplierName?: string | null, invoiceNumber?: string | null, purchaseOrderId?: string | null, totalAmount?: number | null, lines: Array<{ __typename?: 'IngestLineResult', description: string, qty: number, unitPrice: number, discountPct?: number | null, discountedUnitPrice?: number | null, lineTotal: number, variantId?: string | null }> } };

export type MeForPermsQueryVariables = Exact<{ [key: string]: never; }>;


export type MeForPermsQuery = { __typename?: 'Query', me: { __typename?: 'User', role: { __typename?: 'Role', permissions?: Array<{ __typename?: 'Permission', name: string }> | null } } };

export type SearchUsersQueryVariables = Exact<{
  where?: InputMaybe<UserWhereInput>;
  take?: InputMaybe<Scalars['Int']['input']>;
}>;


export type SearchUsersQuery = { __typename?: 'Query', listUsers: Array<{ __typename?: 'User', id: string, email: string }> };

export type SearchStoresQueryVariables = Exact<{
  where?: InputMaybe<StoreWhereInput>;
  take?: InputMaybe<Scalars['Int']['input']>;
}>;


export type SearchStoresQuery = { __typename?: 'Query', listStores: Array<{ __typename?: 'Store', id: string, name: string, location?: string | null }> };

export type SearchVariantsQueryVariables = Exact<{
  where?: InputMaybe<ProductVariantWhereInput>;
  take?: InputMaybe<Scalars['Int']['input']>;
}>;


export type SearchVariantsQuery = { __typename?: 'Query', listProductVariants: Array<{ __typename?: 'ProductVariant', id: string, name?: string | null, barcode?: string | null }> };

export type SearchSuppliersQueryVariables = Exact<{
  where?: InputMaybe<SupplierWhereInput>;
  take?: InputMaybe<Scalars['Int']['input']>;
}>;


export type SearchSuppliersQuery = { __typename?: 'Query', listSuppliers: Array<{ __typename?: 'Supplier', id: string, name: string }> };


export const MonthlySalesSummaryDocument = gql`
    query MonthlySalesSummary($month: String) {
  monthlySalesSummary(month: $month) {
    month
    totalSold
    totalReturned
  }
}
    `;

/**
 * __useMonthlySalesSummaryQuery__
 *
 * To run a query within a React component, call `useMonthlySalesSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useMonthlySalesSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMonthlySalesSummaryQuery({
 *   variables: {
 *      month: // value for 'month'
 *   },
 * });
 */
export function useMonthlySalesSummaryQuery(baseOptions?: Apollo.QueryHookOptions<MonthlySalesSummaryQuery, MonthlySalesSummaryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MonthlySalesSummaryQuery, MonthlySalesSummaryQueryVariables>(MonthlySalesSummaryDocument, options);
      }
export function useMonthlySalesSummaryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MonthlySalesSummaryQuery, MonthlySalesSummaryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MonthlySalesSummaryQuery, MonthlySalesSummaryQueryVariables>(MonthlySalesSummaryDocument, options);
        }
export function useMonthlySalesSummarySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MonthlySalesSummaryQuery, MonthlySalesSummaryQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MonthlySalesSummaryQuery, MonthlySalesSummaryQueryVariables>(MonthlySalesSummaryDocument, options);
        }
export type MonthlySalesSummaryQueryHookResult = ReturnType<typeof useMonthlySalesSummaryQuery>;
export type MonthlySalesSummaryLazyQueryHookResult = ReturnType<typeof useMonthlySalesSummaryLazyQuery>;
export type MonthlySalesSummarySuspenseQueryHookResult = ReturnType<typeof useMonthlySalesSummarySuspenseQuery>;
export type MonthlySalesSummaryQueryResult = Apollo.QueryResult<MonthlySalesSummaryQuery, MonthlySalesSummaryQueryVariables>;
export const MonthlySalesSummaryByStoreDocument = gql`
    query MonthlySalesSummaryByStore($storeId: String!, $month: String) {
  monthlySalesSummaryByStore(storeId: $storeId, month: $month) {
    month
    totalSold
    totalReturned
  }
}
    `;

/**
 * __useMonthlySalesSummaryByStoreQuery__
 *
 * To run a query within a React component, call `useMonthlySalesSummaryByStoreQuery` and pass it any options that fit your needs.
 * When your component renders, `useMonthlySalesSummaryByStoreQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMonthlySalesSummaryByStoreQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      month: // value for 'month'
 *   },
 * });
 */
export function useMonthlySalesSummaryByStoreQuery(baseOptions: Apollo.QueryHookOptions<MonthlySalesSummaryByStoreQuery, MonthlySalesSummaryByStoreQueryVariables> & ({ variables: MonthlySalesSummaryByStoreQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MonthlySalesSummaryByStoreQuery, MonthlySalesSummaryByStoreQueryVariables>(MonthlySalesSummaryByStoreDocument, options);
      }
export function useMonthlySalesSummaryByStoreLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MonthlySalesSummaryByStoreQuery, MonthlySalesSummaryByStoreQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MonthlySalesSummaryByStoreQuery, MonthlySalesSummaryByStoreQueryVariables>(MonthlySalesSummaryByStoreDocument, options);
        }
export function useMonthlySalesSummaryByStoreSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MonthlySalesSummaryByStoreQuery, MonthlySalesSummaryByStoreQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MonthlySalesSummaryByStoreQuery, MonthlySalesSummaryByStoreQueryVariables>(MonthlySalesSummaryByStoreDocument, options);
        }
export type MonthlySalesSummaryByStoreQueryHookResult = ReturnType<typeof useMonthlySalesSummaryByStoreQuery>;
export type MonthlySalesSummaryByStoreLazyQueryHookResult = ReturnType<typeof useMonthlySalesSummaryByStoreLazyQuery>;
export type MonthlySalesSummaryByStoreSuspenseQueryHookResult = ReturnType<typeof useMonthlySalesSummaryByStoreSuspenseQuery>;
export type MonthlySalesSummaryByStoreQueryResult = Apollo.QueryResult<MonthlySalesSummaryByStoreQuery, MonthlySalesSummaryByStoreQueryVariables>;
export const TopSellingVariantsDetailedDocument = gql`
    query TopSellingVariantsDetailed($month: String, $limit: Int) {
  topSellingVariantsDetailed(month: $month, limit: $limit) {
    productVariantId
    productName
    quantity
  }
}
    `;

/**
 * __useTopSellingVariantsDetailedQuery__
 *
 * To run a query within a React component, call `useTopSellingVariantsDetailedQuery` and pass it any options that fit your needs.
 * When your component renders, `useTopSellingVariantsDetailedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTopSellingVariantsDetailedQuery({
 *   variables: {
 *      month: // value for 'month'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useTopSellingVariantsDetailedQuery(baseOptions?: Apollo.QueryHookOptions<TopSellingVariantsDetailedQuery, TopSellingVariantsDetailedQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TopSellingVariantsDetailedQuery, TopSellingVariantsDetailedQueryVariables>(TopSellingVariantsDetailedDocument, options);
      }
export function useTopSellingVariantsDetailedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TopSellingVariantsDetailedQuery, TopSellingVariantsDetailedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TopSellingVariantsDetailedQuery, TopSellingVariantsDetailedQueryVariables>(TopSellingVariantsDetailedDocument, options);
        }
export function useTopSellingVariantsDetailedSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<TopSellingVariantsDetailedQuery, TopSellingVariantsDetailedQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TopSellingVariantsDetailedQuery, TopSellingVariantsDetailedQueryVariables>(TopSellingVariantsDetailedDocument, options);
        }
export type TopSellingVariantsDetailedQueryHookResult = ReturnType<typeof useTopSellingVariantsDetailedQuery>;
export type TopSellingVariantsDetailedLazyQueryHookResult = ReturnType<typeof useTopSellingVariantsDetailedLazyQuery>;
export type TopSellingVariantsDetailedSuspenseQueryHookResult = ReturnType<typeof useTopSellingVariantsDetailedSuspenseQuery>;
export type TopSellingVariantsDetailedQueryResult = Apollo.QueryResult<TopSellingVariantsDetailedQuery, TopSellingVariantsDetailedQueryVariables>;
export const TopSellingVariantsByStoreDocument = gql`
    query TopSellingVariantsByStore($storeId: String!, $month: String, $limit: Int) {
  topSellingVariantsByStore(storeId: $storeId, month: $month, limit: $limit) {
    productVariantId
    productName
    quantity
  }
}
    `;

/**
 * __useTopSellingVariantsByStoreQuery__
 *
 * To run a query within a React component, call `useTopSellingVariantsByStoreQuery` and pass it any options that fit your needs.
 * When your component renders, `useTopSellingVariantsByStoreQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTopSellingVariantsByStoreQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      month: // value for 'month'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useTopSellingVariantsByStoreQuery(baseOptions: Apollo.QueryHookOptions<TopSellingVariantsByStoreQuery, TopSellingVariantsByStoreQueryVariables> & ({ variables: TopSellingVariantsByStoreQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TopSellingVariantsByStoreQuery, TopSellingVariantsByStoreQueryVariables>(TopSellingVariantsByStoreDocument, options);
      }
export function useTopSellingVariantsByStoreLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TopSellingVariantsByStoreQuery, TopSellingVariantsByStoreQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TopSellingVariantsByStoreQuery, TopSellingVariantsByStoreQueryVariables>(TopSellingVariantsByStoreDocument, options);
        }
export function useTopSellingVariantsByStoreSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<TopSellingVariantsByStoreQuery, TopSellingVariantsByStoreQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TopSellingVariantsByStoreQuery, TopSellingVariantsByStoreQueryVariables>(TopSellingVariantsByStoreDocument, options);
        }
export type TopSellingVariantsByStoreQueryHookResult = ReturnType<typeof useTopSellingVariantsByStoreQuery>;
export type TopSellingVariantsByStoreLazyQueryHookResult = ReturnType<typeof useTopSellingVariantsByStoreLazyQuery>;
export type TopSellingVariantsByStoreSuspenseQueryHookResult = ReturnType<typeof useTopSellingVariantsByStoreSuspenseQuery>;
export type TopSellingVariantsByStoreQueryResult = Apollo.QueryResult<TopSellingVariantsByStoreQuery, TopSellingVariantsByStoreQueryVariables>;
export const AssetAssignmentsDocument = gql`
    query AssetAssignments($entityType: AssetEntityType!, $entityId: String!) {
  assetAssignments(input: {entityType: $entityType, entityId: $entityId}) {
    id
    assetId
    entityType
    entityId
    isPrimary
    createdAt
    updatedAt
    asset {
      id
      kind
      url
      filename
      mimetype
      size
      metadata
      createdAt
    }
  }
}
    `;

/**
 * __useAssetAssignmentsQuery__
 *
 * To run a query within a React component, call `useAssetAssignmentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAssetAssignmentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAssetAssignmentsQuery({
 *   variables: {
 *      entityType: // value for 'entityType'
 *      entityId: // value for 'entityId'
 *   },
 * });
 */
export function useAssetAssignmentsQuery(baseOptions: Apollo.QueryHookOptions<AssetAssignmentsQuery, AssetAssignmentsQueryVariables> & ({ variables: AssetAssignmentsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AssetAssignmentsQuery, AssetAssignmentsQueryVariables>(AssetAssignmentsDocument, options);
      }
export function useAssetAssignmentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AssetAssignmentsQuery, AssetAssignmentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AssetAssignmentsQuery, AssetAssignmentsQueryVariables>(AssetAssignmentsDocument, options);
        }
export function useAssetAssignmentsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<AssetAssignmentsQuery, AssetAssignmentsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AssetAssignmentsQuery, AssetAssignmentsQueryVariables>(AssetAssignmentsDocument, options);
        }
export type AssetAssignmentsQueryHookResult = ReturnType<typeof useAssetAssignmentsQuery>;
export type AssetAssignmentsLazyQueryHookResult = ReturnType<typeof useAssetAssignmentsLazyQuery>;
export type AssetAssignmentsSuspenseQueryHookResult = ReturnType<typeof useAssetAssignmentsSuspenseQuery>;
export type AssetAssignmentsQueryResult = Apollo.QueryResult<AssetAssignmentsQuery, AssetAssignmentsQueryVariables>;
export const PrimaryAssetAssignmentDocument = gql`
    query PrimaryAssetAssignment($entityType: AssetEntityType!, $entityId: String!) {
  primaryAssetAssignment(input: {entityType: $entityType, entityId: $entityId}) {
    id
    assetId
    entityType
    entityId
    isPrimary
    asset {
      id
      kind
      url
      filename
      mimetype
    }
  }
}
    `;

/**
 * __usePrimaryAssetAssignmentQuery__
 *
 * To run a query within a React component, call `usePrimaryAssetAssignmentQuery` and pass it any options that fit your needs.
 * When your component renders, `usePrimaryAssetAssignmentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePrimaryAssetAssignmentQuery({
 *   variables: {
 *      entityType: // value for 'entityType'
 *      entityId: // value for 'entityId'
 *   },
 * });
 */
export function usePrimaryAssetAssignmentQuery(baseOptions: Apollo.QueryHookOptions<PrimaryAssetAssignmentQuery, PrimaryAssetAssignmentQueryVariables> & ({ variables: PrimaryAssetAssignmentQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PrimaryAssetAssignmentQuery, PrimaryAssetAssignmentQueryVariables>(PrimaryAssetAssignmentDocument, options);
      }
export function usePrimaryAssetAssignmentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PrimaryAssetAssignmentQuery, PrimaryAssetAssignmentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PrimaryAssetAssignmentQuery, PrimaryAssetAssignmentQueryVariables>(PrimaryAssetAssignmentDocument, options);
        }
export function usePrimaryAssetAssignmentSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PrimaryAssetAssignmentQuery, PrimaryAssetAssignmentQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PrimaryAssetAssignmentQuery, PrimaryAssetAssignmentQueryVariables>(PrimaryAssetAssignmentDocument, options);
        }
export type PrimaryAssetAssignmentQueryHookResult = ReturnType<typeof usePrimaryAssetAssignmentQuery>;
export type PrimaryAssetAssignmentLazyQueryHookResult = ReturnType<typeof usePrimaryAssetAssignmentLazyQuery>;
export type PrimaryAssetAssignmentSuspenseQueryHookResult = ReturnType<typeof usePrimaryAssetAssignmentSuspenseQuery>;
export type PrimaryAssetAssignmentQueryResult = Apollo.QueryResult<PrimaryAssetAssignmentQuery, PrimaryAssetAssignmentQueryVariables>;
export const AssignAssetDocument = gql`
    mutation AssignAsset($assetId: String!, $entityType: AssetEntityType!, $entityId: String!, $isPrimary: Boolean) {
  assignAsset(
    input: {assetId: $assetId, entityType: $entityType, entityId: $entityId, isPrimary: $isPrimary}
  ) {
    id
    assetId
    entityType
    entityId
    isPrimary
  }
}
    `;
export type AssignAssetMutationFn = Apollo.MutationFunction<AssignAssetMutation, AssignAssetMutationVariables>;

/**
 * __useAssignAssetMutation__
 *
 * To run a mutation, you first call `useAssignAssetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAssignAssetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [assignAssetMutation, { data, loading, error }] = useAssignAssetMutation({
 *   variables: {
 *      assetId: // value for 'assetId'
 *      entityType: // value for 'entityType'
 *      entityId: // value for 'entityId'
 *      isPrimary: // value for 'isPrimary'
 *   },
 * });
 */
export function useAssignAssetMutation(baseOptions?: Apollo.MutationHookOptions<AssignAssetMutation, AssignAssetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AssignAssetMutation, AssignAssetMutationVariables>(AssignAssetDocument, options);
      }
export type AssignAssetMutationHookResult = ReturnType<typeof useAssignAssetMutation>;
export type AssignAssetMutationResult = Apollo.MutationResult<AssignAssetMutation>;
export type AssignAssetMutationOptions = Apollo.BaseMutationOptions<AssignAssetMutation, AssignAssetMutationVariables>;
export const UnassignAssetDocument = gql`
    mutation UnassignAsset($assetId: String!, $entityType: AssetEntityType!, $entityId: String!) {
  unassignAsset(
    input: {assetId: $assetId, entityType: $entityType, entityId: $entityId}
  )
}
    `;
export type UnassignAssetMutationFn = Apollo.MutationFunction<UnassignAssetMutation, UnassignAssetMutationVariables>;

/**
 * __useUnassignAssetMutation__
 *
 * To run a mutation, you first call `useUnassignAssetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnassignAssetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unassignAssetMutation, { data, loading, error }] = useUnassignAssetMutation({
 *   variables: {
 *      assetId: // value for 'assetId'
 *      entityType: // value for 'entityType'
 *      entityId: // value for 'entityId'
 *   },
 * });
 */
export function useUnassignAssetMutation(baseOptions?: Apollo.MutationHookOptions<UnassignAssetMutation, UnassignAssetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnassignAssetMutation, UnassignAssetMutationVariables>(UnassignAssetDocument, options);
      }
export type UnassignAssetMutationHookResult = ReturnType<typeof useUnassignAssetMutation>;
export type UnassignAssetMutationResult = Apollo.MutationResult<UnassignAssetMutation>;
export type UnassignAssetMutationOptions = Apollo.BaseMutationOptions<UnassignAssetMutation, UnassignAssetMutationVariables>;
export const RemoveAssetDocument = gql`
    mutation RemoveAsset($assetId: String!) {
  removeAsset(assetId: $assetId)
}
    `;
export type RemoveAssetMutationFn = Apollo.MutationFunction<RemoveAssetMutation, RemoveAssetMutationVariables>;

/**
 * __useRemoveAssetMutation__
 *
 * To run a mutation, you first call `useRemoveAssetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveAssetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeAssetMutation, { data, loading, error }] = useRemoveAssetMutation({
 *   variables: {
 *      assetId: // value for 'assetId'
 *   },
 * });
 */
export function useRemoveAssetMutation(baseOptions?: Apollo.MutationHookOptions<RemoveAssetMutation, RemoveAssetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveAssetMutation, RemoveAssetMutationVariables>(RemoveAssetDocument, options);
      }
export type RemoveAssetMutationHookResult = ReturnType<typeof useRemoveAssetMutation>;
export type RemoveAssetMutationResult = Apollo.MutationResult<RemoveAssetMutation>;
export type RemoveAssetMutationOptions = Apollo.BaseMutationOptions<RemoveAssetMutation, RemoveAssetMutationVariables>;
export const AssetsDocument = gql`
    query Assets($take: Int, $skip: Int) {
  assets(take: $take, skip: $skip, orderBy: [{createdAt: desc}]) {
    id
    kind
    bucket
    key
    url
    filename
    mimetype
    size
    createdAt
    updatedAt
    assignments {
      id
      entityType
      entityId
      isPrimary
    }
  }
}
    `;

/**
 * __useAssetsQuery__
 *
 * To run a query within a React component, call `useAssetsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAssetsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAssetsQuery({
 *   variables: {
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function useAssetsQuery(baseOptions?: Apollo.QueryHookOptions<AssetsQuery, AssetsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AssetsQuery, AssetsQueryVariables>(AssetsDocument, options);
      }
export function useAssetsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AssetsQuery, AssetsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AssetsQuery, AssetsQueryVariables>(AssetsDocument, options);
        }
export function useAssetsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<AssetsQuery, AssetsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AssetsQuery, AssetsQueryVariables>(AssetsDocument, options);
        }
export type AssetsQueryHookResult = ReturnType<typeof useAssetsQuery>;
export type AssetsLazyQueryHookResult = ReturnType<typeof useAssetsLazyQuery>;
export type AssetsSuspenseQueryHookResult = ReturnType<typeof useAssetsSuspenseQuery>;
export type AssetsQueryResult = Apollo.QueryResult<AssetsQuery, AssetsQueryVariables>;
export const LoginDocument = gql`
    mutation Login($input: LoginInput!) {
  login(input: $input) {
    accessToken
    user {
      id
      email
      role {
        id
        name
      }
    }
  }
}
    `;
export type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;

/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, options);
      }
export type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export type LoginMutationResult = Apollo.MutationResult<LoginMutation>;
export type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;
export const MeDocument = gql`
    query Me {
  me {
    id
    email
    role {
      id
      name
      permissions {
        id
        name
        module
        action
      }
    }
    customerProfile {
      fullName
      email
      phone
    }
  }
}
    `;

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options);
      }
export function useMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options);
        }
export function useMeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MeQuery, MeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MeQuery, MeQueryVariables>(MeDocument, options);
        }
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeSuspenseQueryHookResult = ReturnType<typeof useMeSuspenseQuery>;
export type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;
export const ChangePasswordDocument = gql`
    mutation ChangePassword($input: ChangePasswordInput!) {
  changePassword(input: $input)
}
    `;
export type ChangePasswordMutationFn = Apollo.MutationFunction<ChangePasswordMutation, ChangePasswordMutationVariables>;

/**
 * __useChangePasswordMutation__
 *
 * To run a mutation, you first call `useChangePasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChangePasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [changePasswordMutation, { data, loading, error }] = useChangePasswordMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useChangePasswordMutation(baseOptions?: Apollo.MutationHookOptions<ChangePasswordMutation, ChangePasswordMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChangePasswordMutation, ChangePasswordMutationVariables>(ChangePasswordDocument, options);
      }
export type ChangePasswordMutationHookResult = ReturnType<typeof useChangePasswordMutation>;
export type ChangePasswordMutationResult = Apollo.MutationResult<ChangePasswordMutation>;
export type ChangePasswordMutationOptions = Apollo.BaseMutationOptions<ChangePasswordMutation, ChangePasswordMutationVariables>;
export const UpdateMyProfileDocument = gql`
    mutation UpdateMyProfile($input: UpdateCustomerProfileInput!) {
  updateMyProfile(input: $input) {
    userId
    fullName
    email
    phone
    preferredStore {
      id
      name
    }
  }
}
    `;
export type UpdateMyProfileMutationFn = Apollo.MutationFunction<UpdateMyProfileMutation, UpdateMyProfileMutationVariables>;

/**
 * __useUpdateMyProfileMutation__
 *
 * To run a mutation, you first call `useUpdateMyProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMyProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMyProfileMutation, { data, loading, error }] = useUpdateMyProfileMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateMyProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMyProfileMutation, UpdateMyProfileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateMyProfileMutation, UpdateMyProfileMutationVariables>(UpdateMyProfileDocument, options);
      }
export type UpdateMyProfileMutationHookResult = ReturnType<typeof useUpdateMyProfileMutation>;
export type UpdateMyProfileMutationResult = Apollo.MutationResult<UpdateMyProfileMutation>;
export type UpdateMyProfileMutationOptions = Apollo.BaseMutationOptions<UpdateMyProfileMutation, UpdateMyProfileMutationVariables>;
export const CollectionsDocument = gql`
    query Collections {
  collections {
    id
    name
    code
    target
    filters
    createdAt
  }
}
    `;

/**
 * __useCollectionsQuery__
 *
 * To run a query within a React component, call `useCollectionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useCollectionsQuery(baseOptions?: Apollo.QueryHookOptions<CollectionsQuery, CollectionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionsQuery, CollectionsQueryVariables>(CollectionsDocument, options);
      }
export function useCollectionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionsQuery, CollectionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionsQuery, CollectionsQueryVariables>(CollectionsDocument, options);
        }
export function useCollectionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CollectionsQuery, CollectionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CollectionsQuery, CollectionsQueryVariables>(CollectionsDocument, options);
        }
export type CollectionsQueryHookResult = ReturnType<typeof useCollectionsQuery>;
export type CollectionsLazyQueryHookResult = ReturnType<typeof useCollectionsLazyQuery>;
export type CollectionsSuspenseQueryHookResult = ReturnType<typeof useCollectionsSuspenseQuery>;
export type CollectionsQueryResult = Apollo.QueryResult<CollectionsQuery, CollectionsQueryVariables>;
export const CreateCollectionDocument = gql`
    mutation CreateCollection($input: CreateCollectionInput!) {
  createCollection(input: $input) {
    id
  }
}
    `;
export type CreateCollectionMutationFn = Apollo.MutationFunction<CreateCollectionMutation, CreateCollectionMutationVariables>;

/**
 * __useCreateCollectionMutation__
 *
 * To run a mutation, you first call `useCreateCollectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCollectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCollectionMutation, { data, loading, error }] = useCreateCollectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCollectionMutation(baseOptions?: Apollo.MutationHookOptions<CreateCollectionMutation, CreateCollectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCollectionMutation, CreateCollectionMutationVariables>(CreateCollectionDocument, options);
      }
export type CreateCollectionMutationHookResult = ReturnType<typeof useCreateCollectionMutation>;
export type CreateCollectionMutationResult = Apollo.MutationResult<CreateCollectionMutation>;
export type CreateCollectionMutationOptions = Apollo.BaseMutationOptions<CreateCollectionMutation, CreateCollectionMutationVariables>;
export const UpdateCollectionDocument = gql`
    mutation UpdateCollection($input: UpdateCollectionInput!) {
  updateCollection(input: $input) {
    id
  }
}
    `;
export type UpdateCollectionMutationFn = Apollo.MutationFunction<UpdateCollectionMutation, UpdateCollectionMutationVariables>;

/**
 * __useUpdateCollectionMutation__
 *
 * To run a mutation, you first call `useUpdateCollectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCollectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCollectionMutation, { data, loading, error }] = useUpdateCollectionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCollectionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCollectionMutation, UpdateCollectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCollectionMutation, UpdateCollectionMutationVariables>(UpdateCollectionDocument, options);
      }
export type UpdateCollectionMutationHookResult = ReturnType<typeof useUpdateCollectionMutation>;
export type UpdateCollectionMutationResult = Apollo.MutationResult<UpdateCollectionMutation>;
export type UpdateCollectionMutationOptions = Apollo.BaseMutationOptions<UpdateCollectionMutation, UpdateCollectionMutationVariables>;
export const DeleteCollectionDocument = gql`
    mutation DeleteCollection($id: String!) {
  deleteCollection(id: $id)
}
    `;
export type DeleteCollectionMutationFn = Apollo.MutationFunction<DeleteCollectionMutation, DeleteCollectionMutationVariables>;

/**
 * __useDeleteCollectionMutation__
 *
 * To run a mutation, you first call `useDeleteCollectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCollectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCollectionMutation, { data, loading, error }] = useDeleteCollectionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteCollectionMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCollectionMutation, DeleteCollectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCollectionMutation, DeleteCollectionMutationVariables>(DeleteCollectionDocument, options);
      }
export type DeleteCollectionMutationHookResult = ReturnType<typeof useDeleteCollectionMutation>;
export type DeleteCollectionMutationResult = Apollo.MutationResult<DeleteCollectionMutation>;
export type DeleteCollectionMutationOptions = Apollo.BaseMutationOptions<DeleteCollectionMutation, DeleteCollectionMutationVariables>;
export const CollectionMembersCountDocument = gql`
    query CollectionMembersCount($id: String!) {
  collectionMembersCount(id: $id)
}
    `;

/**
 * __useCollectionMembersCountQuery__
 *
 * To run a query within a React component, call `useCollectionMembersCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionMembersCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionMembersCountQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCollectionMembersCountQuery(baseOptions: Apollo.QueryHookOptions<CollectionMembersCountQuery, CollectionMembersCountQueryVariables> & ({ variables: CollectionMembersCountQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionMembersCountQuery, CollectionMembersCountQueryVariables>(CollectionMembersCountDocument, options);
      }
export function useCollectionMembersCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionMembersCountQuery, CollectionMembersCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionMembersCountQuery, CollectionMembersCountQueryVariables>(CollectionMembersCountDocument, options);
        }
export function useCollectionMembersCountSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CollectionMembersCountQuery, CollectionMembersCountQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CollectionMembersCountQuery, CollectionMembersCountQueryVariables>(CollectionMembersCountDocument, options);
        }
export type CollectionMembersCountQueryHookResult = ReturnType<typeof useCollectionMembersCountQuery>;
export type CollectionMembersCountLazyQueryHookResult = ReturnType<typeof useCollectionMembersCountLazyQuery>;
export type CollectionMembersCountSuspenseQueryHookResult = ReturnType<typeof useCollectionMembersCountSuspenseQuery>;
export type CollectionMembersCountQueryResult = Apollo.QueryResult<CollectionMembersCountQuery, CollectionMembersCountQueryVariables>;
export const CollectionVariantsDocument = gql`
    query CollectionVariants($id: String!, $take: Int, $skip: Int) {
  collectionVariants(id: $id, take: $take, skip: $skip) {
    id
    name
    barcode
    product {
      id
      name
    }
  }
}
    `;

/**
 * __useCollectionVariantsQuery__
 *
 * To run a query within a React component, call `useCollectionVariantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionVariantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionVariantsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function useCollectionVariantsQuery(baseOptions: Apollo.QueryHookOptions<CollectionVariantsQuery, CollectionVariantsQueryVariables> & ({ variables: CollectionVariantsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionVariantsQuery, CollectionVariantsQueryVariables>(CollectionVariantsDocument, options);
      }
export function useCollectionVariantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionVariantsQuery, CollectionVariantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionVariantsQuery, CollectionVariantsQueryVariables>(CollectionVariantsDocument, options);
        }
export function useCollectionVariantsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CollectionVariantsQuery, CollectionVariantsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CollectionVariantsQuery, CollectionVariantsQueryVariables>(CollectionVariantsDocument, options);
        }
export type CollectionVariantsQueryHookResult = ReturnType<typeof useCollectionVariantsQuery>;
export type CollectionVariantsLazyQueryHookResult = ReturnType<typeof useCollectionVariantsLazyQuery>;
export type CollectionVariantsSuspenseQueryHookResult = ReturnType<typeof useCollectionVariantsSuspenseQuery>;
export type CollectionVariantsQueryResult = Apollo.QueryResult<CollectionVariantsQuery, CollectionVariantsQueryVariables>;
export const CollectionProductsDocument = gql`
    query CollectionProducts($id: String!, $take: Int, $skip: Int) {
  collectionProducts(id: $id, take: $take, skip: $skip) {
    id
    name
    barcode
  }
}
    `;

/**
 * __useCollectionProductsQuery__
 *
 * To run a query within a React component, call `useCollectionProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectionProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectionProductsQuery({
 *   variables: {
 *      id: // value for 'id'
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function useCollectionProductsQuery(baseOptions: Apollo.QueryHookOptions<CollectionProductsQuery, CollectionProductsQueryVariables> & ({ variables: CollectionProductsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectionProductsQuery, CollectionProductsQueryVariables>(CollectionProductsDocument, options);
      }
export function useCollectionProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectionProductsQuery, CollectionProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectionProductsQuery, CollectionProductsQueryVariables>(CollectionProductsDocument, options);
        }
export function useCollectionProductsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CollectionProductsQuery, CollectionProductsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CollectionProductsQuery, CollectionProductsQueryVariables>(CollectionProductsDocument, options);
        }
export type CollectionProductsQueryHookResult = ReturnType<typeof useCollectionProductsQuery>;
export type CollectionProductsLazyQueryHookResult = ReturnType<typeof useCollectionProductsLazyQuery>;
export type CollectionProductsSuspenseQueryHookResult = ReturnType<typeof useCollectionProductsSuspenseQuery>;
export type CollectionProductsQueryResult = Apollo.QueryResult<CollectionProductsQuery, CollectionProductsQueryVariables>;
export const CustomersDocument = gql`
    query Customers($take: Int, $where: UserWhereInput) {
  listUsers(take: $take, where: $where) {
    id
    email
    customerProfile {
      fullName
      email
      phone
      profileStatus
      preferredStore {
        id
        name
      }
    }
  }
}
    `;

/**
 * __useCustomersQuery__
 *
 * To run a query within a React component, call `useCustomersQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomersQuery({
 *   variables: {
 *      take: // value for 'take'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useCustomersQuery(baseOptions?: Apollo.QueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
      }
export function useCustomersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
        }
export function useCustomersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CustomersQuery, CustomersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomersQuery, CustomersQueryVariables>(CustomersDocument, options);
        }
export type CustomersQueryHookResult = ReturnType<typeof useCustomersQuery>;
export type CustomersLazyQueryHookResult = ReturnType<typeof useCustomersLazyQuery>;
export type CustomersSuspenseQueryHookResult = ReturnType<typeof useCustomersSuspenseQuery>;
export type CustomersQueryResult = Apollo.QueryResult<CustomersQuery, CustomersQueryVariables>;
export const CustomerDocument = gql`
    query Customer($id: String!) {
  findUniqueUser(where: {id: $id}) {
    id
    email
    customerProfile {
      fullName
      email
      phone
      profileStatus
      preferredStore {
        id
        name
      }
      sales {
        id
        status
        createdAt
        totalAmount
        store {
          id
          name
        }
        receipt {
          id
          issuedAt
          consumerSaleId
        }
      }
    }
  }
}
    `;

/**
 * __useCustomerQuery__
 *
 * To run a query within a React component, call `useCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCustomerQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCustomerQuery(baseOptions: Apollo.QueryHookOptions<CustomerQuery, CustomerQueryVariables> & ({ variables: CustomerQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CustomerQuery, CustomerQueryVariables>(CustomerDocument, options);
      }
export function useCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CustomerQuery, CustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CustomerQuery, CustomerQueryVariables>(CustomerDocument, options);
        }
export function useCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<CustomerQuery, CustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CustomerQuery, CustomerQueryVariables>(CustomerDocument, options);
        }
export type CustomerQueryHookResult = ReturnType<typeof useCustomerQuery>;
export type CustomerLazyQueryHookResult = ReturnType<typeof useCustomerLazyQuery>;
export type CustomerSuspenseQueryHookResult = ReturnType<typeof useCustomerSuspenseQuery>;
export type CustomerQueryResult = Apollo.QueryResult<CustomerQuery, CustomerQueryVariables>;
export const StoresForCustomersDocument = gql`
    query StoresForCustomers {
  listStores(take: 200) {
    id
    name
  }
}
    `;

/**
 * __useStoresForCustomersQuery__
 *
 * To run a query within a React component, call `useStoresForCustomersQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoresForCustomersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoresForCustomersQuery({
 *   variables: {
 *   },
 * });
 */
export function useStoresForCustomersQuery(baseOptions?: Apollo.QueryHookOptions<StoresForCustomersQuery, StoresForCustomersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoresForCustomersQuery, StoresForCustomersQueryVariables>(StoresForCustomersDocument, options);
      }
export function useStoresForCustomersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoresForCustomersQuery, StoresForCustomersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoresForCustomersQuery, StoresForCustomersQueryVariables>(StoresForCustomersDocument, options);
        }
export function useStoresForCustomersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StoresForCustomersQuery, StoresForCustomersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StoresForCustomersQuery, StoresForCustomersQueryVariables>(StoresForCustomersDocument, options);
        }
export type StoresForCustomersQueryHookResult = ReturnType<typeof useStoresForCustomersQuery>;
export type StoresForCustomersLazyQueryHookResult = ReturnType<typeof useStoresForCustomersLazyQuery>;
export type StoresForCustomersSuspenseQueryHookResult = ReturnType<typeof useStoresForCustomersSuspenseQuery>;
export type StoresForCustomersQueryResult = Apollo.QueryResult<StoresForCustomersQuery, StoresForCustomersQueryVariables>;
export const AdminUpdateCustomerProfileDocument = gql`
    mutation AdminUpdateCustomerProfile($userId: String!, $input: AdminUpdateCustomerProfileInput!) {
  adminUpdateCustomerProfile(userId: $userId, input: $input) {
    userId
    profileStatus
  }
}
    `;
export type AdminUpdateCustomerProfileMutationFn = Apollo.MutationFunction<AdminUpdateCustomerProfileMutation, AdminUpdateCustomerProfileMutationVariables>;

/**
 * __useAdminUpdateCustomerProfileMutation__
 *
 * To run a mutation, you first call `useAdminUpdateCustomerProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAdminUpdateCustomerProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [adminUpdateCustomerProfileMutation, { data, loading, error }] = useAdminUpdateCustomerProfileMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAdminUpdateCustomerProfileMutation(baseOptions?: Apollo.MutationHookOptions<AdminUpdateCustomerProfileMutation, AdminUpdateCustomerProfileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AdminUpdateCustomerProfileMutation, AdminUpdateCustomerProfileMutationVariables>(AdminUpdateCustomerProfileDocument, options);
      }
export type AdminUpdateCustomerProfileMutationHookResult = ReturnType<typeof useAdminUpdateCustomerProfileMutation>;
export type AdminUpdateCustomerProfileMutationResult = Apollo.MutationResult<AdminUpdateCustomerProfileMutation>;
export type AdminUpdateCustomerProfileMutationOptions = Apollo.BaseMutationOptions<AdminUpdateCustomerProfileMutation, AdminUpdateCustomerProfileMutationVariables>;
export const AdminCreateCustomerDocument = gql`
    mutation AdminCreateCustomer($input: AdminCreateCustomerInput!) {
  adminCreateCustomer(input: $input) {
    id
    email
    customerProfile {
      fullName
    }
  }
}
    `;
export type AdminCreateCustomerMutationFn = Apollo.MutationFunction<AdminCreateCustomerMutation, AdminCreateCustomerMutationVariables>;

/**
 * __useAdminCreateCustomerMutation__
 *
 * To run a mutation, you first call `useAdminCreateCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAdminCreateCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [adminCreateCustomerMutation, { data, loading, error }] = useAdminCreateCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAdminCreateCustomerMutation(baseOptions?: Apollo.MutationHookOptions<AdminCreateCustomerMutation, AdminCreateCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AdminCreateCustomerMutation, AdminCreateCustomerMutationVariables>(AdminCreateCustomerDocument, options);
      }
export type AdminCreateCustomerMutationHookResult = ReturnType<typeof useAdminCreateCustomerMutation>;
export type AdminCreateCustomerMutationResult = Apollo.MutationResult<AdminCreateCustomerMutation>;
export type AdminCreateCustomerMutationOptions = Apollo.BaseMutationOptions<AdminCreateCustomerMutation, AdminCreateCustomerMutationVariables>;
export const ConsumerSalesByCustomerDocument = gql`
    query ConsumerSalesByCustomer($customerId: String!, $take: Int, $skip: Int, $order: String, $cursorId: String) {
  consumerSalesByCustomer(
    customerId: $customerId
    take: $take
    skip: $skip
    order: $order
    cursorId: $cursorId
  ) {
    id
    status
    totalAmount
    createdAt
    store {
      id
      name
    }
  }
}
    `;

/**
 * __useConsumerSalesByCustomerQuery__
 *
 * To run a query within a React component, call `useConsumerSalesByCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useConsumerSalesByCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConsumerSalesByCustomerQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *      order: // value for 'order'
 *      cursorId: // value for 'cursorId'
 *   },
 * });
 */
export function useConsumerSalesByCustomerQuery(baseOptions: Apollo.QueryHookOptions<ConsumerSalesByCustomerQuery, ConsumerSalesByCustomerQueryVariables> & ({ variables: ConsumerSalesByCustomerQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConsumerSalesByCustomerQuery, ConsumerSalesByCustomerQueryVariables>(ConsumerSalesByCustomerDocument, options);
      }
export function useConsumerSalesByCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConsumerSalesByCustomerQuery, ConsumerSalesByCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConsumerSalesByCustomerQuery, ConsumerSalesByCustomerQueryVariables>(ConsumerSalesByCustomerDocument, options);
        }
export function useConsumerSalesByCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ConsumerSalesByCustomerQuery, ConsumerSalesByCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ConsumerSalesByCustomerQuery, ConsumerSalesByCustomerQueryVariables>(ConsumerSalesByCustomerDocument, options);
        }
export type ConsumerSalesByCustomerQueryHookResult = ReturnType<typeof useConsumerSalesByCustomerQuery>;
export type ConsumerSalesByCustomerLazyQueryHookResult = ReturnType<typeof useConsumerSalesByCustomerLazyQuery>;
export type ConsumerSalesByCustomerSuspenseQueryHookResult = ReturnType<typeof useConsumerSalesByCustomerSuspenseQuery>;
export type ConsumerSalesByCustomerQueryResult = Apollo.QueryResult<ConsumerSalesByCustomerQuery, ConsumerSalesByCustomerQueryVariables>;
export const ConsumerReceiptsByCustomerDocument = gql`
    query ConsumerReceiptsByCustomer($customerId: String!, $take: Int, $skip: Int, $order: String, $cursorId: String) {
  consumerReceiptsByCustomer(
    customerId: $customerId
    take: $take
    skip: $skip
    order: $order
    cursorId: $cursorId
  ) {
    id
    issuedAt
    consumerSaleId
  }
}
    `;

/**
 * __useConsumerReceiptsByCustomerQuery__
 *
 * To run a query within a React component, call `useConsumerReceiptsByCustomerQuery` and pass it any options that fit your needs.
 * When your component renders, `useConsumerReceiptsByCustomerQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConsumerReceiptsByCustomerQuery({
 *   variables: {
 *      customerId: // value for 'customerId'
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *      order: // value for 'order'
 *      cursorId: // value for 'cursorId'
 *   },
 * });
 */
export function useConsumerReceiptsByCustomerQuery(baseOptions: Apollo.QueryHookOptions<ConsumerReceiptsByCustomerQuery, ConsumerReceiptsByCustomerQueryVariables> & ({ variables: ConsumerReceiptsByCustomerQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConsumerReceiptsByCustomerQuery, ConsumerReceiptsByCustomerQueryVariables>(ConsumerReceiptsByCustomerDocument, options);
      }
export function useConsumerReceiptsByCustomerLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConsumerReceiptsByCustomerQuery, ConsumerReceiptsByCustomerQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConsumerReceiptsByCustomerQuery, ConsumerReceiptsByCustomerQueryVariables>(ConsumerReceiptsByCustomerDocument, options);
        }
export function useConsumerReceiptsByCustomerSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ConsumerReceiptsByCustomerQuery, ConsumerReceiptsByCustomerQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ConsumerReceiptsByCustomerQuery, ConsumerReceiptsByCustomerQueryVariables>(ConsumerReceiptsByCustomerDocument, options);
        }
export type ConsumerReceiptsByCustomerQueryHookResult = ReturnType<typeof useConsumerReceiptsByCustomerQuery>;
export type ConsumerReceiptsByCustomerLazyQueryHookResult = ReturnType<typeof useConsumerReceiptsByCustomerLazyQuery>;
export type ConsumerReceiptsByCustomerSuspenseQueryHookResult = ReturnType<typeof useConsumerReceiptsByCustomerSuspenseQuery>;
export type ConsumerReceiptsByCustomerQueryResult = Apollo.QueryResult<ConsumerReceiptsByCustomerQuery, ConsumerReceiptsByCustomerQueryVariables>;
export const CompleteCustomerProfileDocument = gql`
    mutation CompleteCustomerProfile($input: UpdateCustomerProfileInput!) {
  completeCustomerProfile(input: $input) {
    userId
    profileStatus
    fullName
    email
    phone
  }
}
    `;
export type CompleteCustomerProfileMutationFn = Apollo.MutationFunction<CompleteCustomerProfileMutation, CompleteCustomerProfileMutationVariables>;

/**
 * __useCompleteCustomerProfileMutation__
 *
 * To run a mutation, you first call `useCompleteCustomerProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCompleteCustomerProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [completeCustomerProfileMutation, { data, loading, error }] = useCompleteCustomerProfileMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCompleteCustomerProfileMutation(baseOptions?: Apollo.MutationHookOptions<CompleteCustomerProfileMutation, CompleteCustomerProfileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CompleteCustomerProfileMutation, CompleteCustomerProfileMutationVariables>(CompleteCustomerProfileDocument, options);
      }
export type CompleteCustomerProfileMutationHookResult = ReturnType<typeof useCompleteCustomerProfileMutation>;
export type CompleteCustomerProfileMutationResult = Apollo.MutationResult<CompleteCustomerProfileMutation>;
export type CompleteCustomerProfileMutationOptions = Apollo.BaseMutationOptions<CompleteCustomerProfileMutation, CompleteCustomerProfileMutationVariables>;
export const SignupCustomerDocument = gql`
    mutation SignupCustomer($input: CreateUserInput!) {
  signupCustomer(input: $input) {
    accessToken
    user {
      id
      email
    }
  }
}
    `;
export type SignupCustomerMutationFn = Apollo.MutationFunction<SignupCustomerMutation, SignupCustomerMutationVariables>;

/**
 * __useSignupCustomerMutation__
 *
 * To run a mutation, you first call `useSignupCustomerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignupCustomerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signupCustomerMutation, { data, loading, error }] = useSignupCustomerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSignupCustomerMutation(baseOptions?: Apollo.MutationHookOptions<SignupCustomerMutation, SignupCustomerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignupCustomerMutation, SignupCustomerMutationVariables>(SignupCustomerDocument, options);
      }
export type SignupCustomerMutationHookResult = ReturnType<typeof useSignupCustomerMutation>;
export type SignupCustomerMutationResult = Apollo.MutationResult<SignupCustomerMutation>;
export type SignupCustomerMutationOptions = Apollo.BaseMutationOptions<SignupCustomerMutation, SignupCustomerMutationVariables>;
export const DevCountsDocument = gql`
    query DevCounts {
  devCounts {
    invoiceImports
    purchaseOrders
    orphanVariants
  }
}
    `;

/**
 * __useDevCountsQuery__
 *
 * To run a query within a React component, call `useDevCountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useDevCountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDevCountsQuery({
 *   variables: {
 *   },
 * });
 */
export function useDevCountsQuery(baseOptions?: Apollo.QueryHookOptions<DevCountsQuery, DevCountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DevCountsQuery, DevCountsQueryVariables>(DevCountsDocument, options);
      }
export function useDevCountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DevCountsQuery, DevCountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DevCountsQuery, DevCountsQueryVariables>(DevCountsDocument, options);
        }
export function useDevCountsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<DevCountsQuery, DevCountsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DevCountsQuery, DevCountsQueryVariables>(DevCountsDocument, options);
        }
export type DevCountsQueryHookResult = ReturnType<typeof useDevCountsQuery>;
export type DevCountsLazyQueryHookResult = ReturnType<typeof useDevCountsLazyQuery>;
export type DevCountsSuspenseQueryHookResult = ReturnType<typeof useDevCountsSuspenseQuery>;
export type DevCountsQueryResult = Apollo.QueryResult<DevCountsQuery, DevCountsQueryVariables>;
export const DevPurgeInvoiceImportsDocument = gql`
    mutation DevPurgeInvoiceImports($filter: DevPurgeFilter) {
  devPurgeInvoiceImports(filter: $filter)
}
    `;
export type DevPurgeInvoiceImportsMutationFn = Apollo.MutationFunction<DevPurgeInvoiceImportsMutation, DevPurgeInvoiceImportsMutationVariables>;

/**
 * __useDevPurgeInvoiceImportsMutation__
 *
 * To run a mutation, you first call `useDevPurgeInvoiceImportsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDevPurgeInvoiceImportsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [devPurgeInvoiceImportsMutation, { data, loading, error }] = useDevPurgeInvoiceImportsMutation({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useDevPurgeInvoiceImportsMutation(baseOptions?: Apollo.MutationHookOptions<DevPurgeInvoiceImportsMutation, DevPurgeInvoiceImportsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DevPurgeInvoiceImportsMutation, DevPurgeInvoiceImportsMutationVariables>(DevPurgeInvoiceImportsDocument, options);
      }
export type DevPurgeInvoiceImportsMutationHookResult = ReturnType<typeof useDevPurgeInvoiceImportsMutation>;
export type DevPurgeInvoiceImportsMutationResult = Apollo.MutationResult<DevPurgeInvoiceImportsMutation>;
export type DevPurgeInvoiceImportsMutationOptions = Apollo.BaseMutationOptions<DevPurgeInvoiceImportsMutation, DevPurgeInvoiceImportsMutationVariables>;
export const DevPurgePurchaseOrdersDocument = gql`
    mutation DevPurgePurchaseOrders($filter: DevPurgeFilter) {
  devPurgePurchaseOrders(filter: $filter)
}
    `;
export type DevPurgePurchaseOrdersMutationFn = Apollo.MutationFunction<DevPurgePurchaseOrdersMutation, DevPurgePurchaseOrdersMutationVariables>;

/**
 * __useDevPurgePurchaseOrdersMutation__
 *
 * To run a mutation, you first call `useDevPurgePurchaseOrdersMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDevPurgePurchaseOrdersMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [devPurgePurchaseOrdersMutation, { data, loading, error }] = useDevPurgePurchaseOrdersMutation({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useDevPurgePurchaseOrdersMutation(baseOptions?: Apollo.MutationHookOptions<DevPurgePurchaseOrdersMutation, DevPurgePurchaseOrdersMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DevPurgePurchaseOrdersMutation, DevPurgePurchaseOrdersMutationVariables>(DevPurgePurchaseOrdersDocument, options);
      }
export type DevPurgePurchaseOrdersMutationHookResult = ReturnType<typeof useDevPurgePurchaseOrdersMutation>;
export type DevPurgePurchaseOrdersMutationResult = Apollo.MutationResult<DevPurgePurchaseOrdersMutation>;
export type DevPurgePurchaseOrdersMutationOptions = Apollo.BaseMutationOptions<DevPurgePurchaseOrdersMutation, DevPurgePurchaseOrdersMutationVariables>;
export const DevPurgeOrphanVariantsDocument = gql`
    mutation DevPurgeOrphanVariants($filter: DevPurgeFilter) {
  devPurgeOrphanVariants(filter: $filter)
}
    `;
export type DevPurgeOrphanVariantsMutationFn = Apollo.MutationFunction<DevPurgeOrphanVariantsMutation, DevPurgeOrphanVariantsMutationVariables>;

/**
 * __useDevPurgeOrphanVariantsMutation__
 *
 * To run a mutation, you first call `useDevPurgeOrphanVariantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDevPurgeOrphanVariantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [devPurgeOrphanVariantsMutation, { data, loading, error }] = useDevPurgeOrphanVariantsMutation({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useDevPurgeOrphanVariantsMutation(baseOptions?: Apollo.MutationHookOptions<DevPurgeOrphanVariantsMutation, DevPurgeOrphanVariantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DevPurgeOrphanVariantsMutation, DevPurgeOrphanVariantsMutationVariables>(DevPurgeOrphanVariantsDocument, options);
      }
export type DevPurgeOrphanVariantsMutationHookResult = ReturnType<typeof useDevPurgeOrphanVariantsMutation>;
export type DevPurgeOrphanVariantsMutationResult = Apollo.MutationResult<DevPurgeOrphanVariantsMutation>;
export type DevPurgeOrphanVariantsMutationOptions = Apollo.BaseMutationOptions<DevPurgeOrphanVariantsMutation, DevPurgeOrphanVariantsMutationVariables>;
export const DevPurgeProductsDocument = gql`
    mutation DevPurgeProducts($filter: DevPurgeFilter) {
  devPurgeProducts(filter: $filter)
}
    `;
export type DevPurgeProductsMutationFn = Apollo.MutationFunction<DevPurgeProductsMutation, DevPurgeProductsMutationVariables>;

/**
 * __useDevPurgeProductsMutation__
 *
 * To run a mutation, you first call `useDevPurgeProductsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDevPurgeProductsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [devPurgeProductsMutation, { data, loading, error }] = useDevPurgeProductsMutation({
 *   variables: {
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useDevPurgeProductsMutation(baseOptions?: Apollo.MutationHookOptions<DevPurgeProductsMutation, DevPurgeProductsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DevPurgeProductsMutation, DevPurgeProductsMutationVariables>(DevPurgeProductsDocument, options);
      }
export type DevPurgeProductsMutationHookResult = ReturnType<typeof useDevPurgeProductsMutation>;
export type DevPurgeProductsMutationResult = Apollo.MutationResult<DevPurgeProductsMutation>;
export type DevPurgeProductsMutationOptions = Apollo.BaseMutationOptions<DevPurgeProductsMutation, DevPurgeProductsMutationVariables>;
export const AssignFulfillmentPersonnelDocument = gql`
    mutation AssignFulfillmentPersonnel($input: AssignFulfillmentPersonnelInput!) {
  assignFulfillmentPersonnel(input: $input) {
    id
    status
    deliveryPersonnelId
    updatedAt
  }
}
    `;
export type AssignFulfillmentPersonnelMutationFn = Apollo.MutationFunction<AssignFulfillmentPersonnelMutation, AssignFulfillmentPersonnelMutationVariables>;

/**
 * __useAssignFulfillmentPersonnelMutation__
 *
 * To run a mutation, you first call `useAssignFulfillmentPersonnelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAssignFulfillmentPersonnelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [assignFulfillmentPersonnelMutation, { data, loading, error }] = useAssignFulfillmentPersonnelMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAssignFulfillmentPersonnelMutation(baseOptions?: Apollo.MutationHookOptions<AssignFulfillmentPersonnelMutation, AssignFulfillmentPersonnelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AssignFulfillmentPersonnelMutation, AssignFulfillmentPersonnelMutationVariables>(AssignFulfillmentPersonnelDocument, options);
      }
export type AssignFulfillmentPersonnelMutationHookResult = ReturnType<typeof useAssignFulfillmentPersonnelMutation>;
export type AssignFulfillmentPersonnelMutationResult = Apollo.MutationResult<AssignFulfillmentPersonnelMutation>;
export type AssignFulfillmentPersonnelMutationOptions = Apollo.BaseMutationOptions<AssignFulfillmentPersonnelMutation, AssignFulfillmentPersonnelMutationVariables>;
export const UpdateFulfillmentStatusDocument = gql`
    mutation UpdateFulfillmentStatus($input: UpdateFulfillmentStatusInput!) {
  updateFulfillmentStatus(input: $input) {
    id
    status
    updatedAt
  }
}
    `;
export type UpdateFulfillmentStatusMutationFn = Apollo.MutationFunction<UpdateFulfillmentStatusMutation, UpdateFulfillmentStatusMutationVariables>;

/**
 * __useUpdateFulfillmentStatusMutation__
 *
 * To run a mutation, you first call `useUpdateFulfillmentStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFulfillmentStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFulfillmentStatusMutation, { data, loading, error }] = useUpdateFulfillmentStatusMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateFulfillmentStatusMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFulfillmentStatusMutation, UpdateFulfillmentStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFulfillmentStatusMutation, UpdateFulfillmentStatusMutationVariables>(UpdateFulfillmentStatusDocument, options);
      }
export type UpdateFulfillmentStatusMutationHookResult = ReturnType<typeof useUpdateFulfillmentStatusMutation>;
export type UpdateFulfillmentStatusMutationResult = Apollo.MutationResult<UpdateFulfillmentStatusMutation>;
export type UpdateFulfillmentStatusMutationOptions = Apollo.BaseMutationOptions<UpdateFulfillmentStatusMutation, UpdateFulfillmentStatusMutationVariables>;
export const InvoiceImportDocument = gql`
    query InvoiceImport($id: String!) {
  invoiceImport(id: $id) {
    id
    url
    supplierName
    storeId
    status
    message
    createdAt
    parsed
  }
}
    `;

/**
 * __useInvoiceImportQuery__
 *
 * To run a query within a React component, call `useInvoiceImportQuery` and pass it any options that fit your needs.
 * When your component renders, `useInvoiceImportQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInvoiceImportQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useInvoiceImportQuery(baseOptions: Apollo.QueryHookOptions<InvoiceImportQuery, InvoiceImportQueryVariables> & ({ variables: InvoiceImportQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InvoiceImportQuery, InvoiceImportQueryVariables>(InvoiceImportDocument, options);
      }
export function useInvoiceImportLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InvoiceImportQuery, InvoiceImportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InvoiceImportQuery, InvoiceImportQueryVariables>(InvoiceImportDocument, options);
        }
export function useInvoiceImportSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<InvoiceImportQuery, InvoiceImportQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<InvoiceImportQuery, InvoiceImportQueryVariables>(InvoiceImportDocument, options);
        }
export type InvoiceImportQueryHookResult = ReturnType<typeof useInvoiceImportQuery>;
export type InvoiceImportLazyQueryHookResult = ReturnType<typeof useInvoiceImportLazyQuery>;
export type InvoiceImportSuspenseQueryHookResult = ReturnType<typeof useInvoiceImportSuspenseQuery>;
export type InvoiceImportQueryResult = Apollo.QueryResult<InvoiceImportQuery, InvoiceImportQueryVariables>;
export const StoresForImportDetailDocument = gql`
    query StoresForImportDetail {
  listStores(take: 200) {
    id
    name
  }
}
    `;

/**
 * __useStoresForImportDetailQuery__
 *
 * To run a query within a React component, call `useStoresForImportDetailQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoresForImportDetailQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoresForImportDetailQuery({
 *   variables: {
 *   },
 * });
 */
export function useStoresForImportDetailQuery(baseOptions?: Apollo.QueryHookOptions<StoresForImportDetailQuery, StoresForImportDetailQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoresForImportDetailQuery, StoresForImportDetailQueryVariables>(StoresForImportDetailDocument, options);
      }
export function useStoresForImportDetailLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoresForImportDetailQuery, StoresForImportDetailQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoresForImportDetailQuery, StoresForImportDetailQueryVariables>(StoresForImportDetailDocument, options);
        }
export function useStoresForImportDetailSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StoresForImportDetailQuery, StoresForImportDetailQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StoresForImportDetailQuery, StoresForImportDetailQueryVariables>(StoresForImportDetailDocument, options);
        }
export type StoresForImportDetailQueryHookResult = ReturnType<typeof useStoresForImportDetailQuery>;
export type StoresForImportDetailLazyQueryHookResult = ReturnType<typeof useStoresForImportDetailLazyQuery>;
export type StoresForImportDetailSuspenseQueryHookResult = ReturnType<typeof useStoresForImportDetailSuspenseQuery>;
export type StoresForImportDetailQueryResult = Apollo.QueryResult<StoresForImportDetailQuery, StoresForImportDetailQueryVariables>;
export const ApproveInvoiceImportDocument = gql`
    mutation ApproveInvoiceImport($input: ApproveInvoiceImportInput!) {
  adminApproveInvoiceImport(input: $input) {
    purchaseOrderId
    invoiceImport {
      id
      status
      message
    }
  }
}
    `;
export type ApproveInvoiceImportMutationFn = Apollo.MutationFunction<ApproveInvoiceImportMutation, ApproveInvoiceImportMutationVariables>;

/**
 * __useApproveInvoiceImportMutation__
 *
 * To run a mutation, you first call `useApproveInvoiceImportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveInvoiceImportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveInvoiceImportMutation, { data, loading, error }] = useApproveInvoiceImportMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useApproveInvoiceImportMutation(baseOptions?: Apollo.MutationHookOptions<ApproveInvoiceImportMutation, ApproveInvoiceImportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveInvoiceImportMutation, ApproveInvoiceImportMutationVariables>(ApproveInvoiceImportDocument, options);
      }
export type ApproveInvoiceImportMutationHookResult = ReturnType<typeof useApproveInvoiceImportMutation>;
export type ApproveInvoiceImportMutationResult = Apollo.MutationResult<ApproveInvoiceImportMutation>;
export type ApproveInvoiceImportMutationOptions = Apollo.BaseMutationOptions<ApproveInvoiceImportMutation, ApproveInvoiceImportMutationVariables>;
export const ReprocessInvoiceImportDocument = gql`
    mutation ReprocessInvoiceImport($id: String!) {
  adminReprocessInvoiceImport(id: $id) {
    id
    status
    message
    parsed
  }
}
    `;
export type ReprocessInvoiceImportMutationFn = Apollo.MutationFunction<ReprocessInvoiceImportMutation, ReprocessInvoiceImportMutationVariables>;

/**
 * __useReprocessInvoiceImportMutation__
 *
 * To run a mutation, you first call `useReprocessInvoiceImportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReprocessInvoiceImportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [reprocessInvoiceImportMutation, { data, loading, error }] = useReprocessInvoiceImportMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useReprocessInvoiceImportMutation(baseOptions?: Apollo.MutationHookOptions<ReprocessInvoiceImportMutation, ReprocessInvoiceImportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReprocessInvoiceImportMutation, ReprocessInvoiceImportMutationVariables>(ReprocessInvoiceImportDocument, options);
      }
export type ReprocessInvoiceImportMutationHookResult = ReturnType<typeof useReprocessInvoiceImportMutation>;
export type ReprocessInvoiceImportMutationResult = Apollo.MutationResult<ReprocessInvoiceImportMutation>;
export type ReprocessInvoiceImportMutationOptions = Apollo.BaseMutationOptions<ReprocessInvoiceImportMutation, ReprocessInvoiceImportMutationVariables>;
export const UpdateInvoiceImportDocument = gql`
    mutation UpdateInvoiceImport($input: UpdateInvoiceImportInput!) {
  adminUpdateInvoiceImport(input: $input) {
    id
    url
    supplierName
    storeId
    parsed
  }
}
    `;
export type UpdateInvoiceImportMutationFn = Apollo.MutationFunction<UpdateInvoiceImportMutation, UpdateInvoiceImportMutationVariables>;

/**
 * __useUpdateInvoiceImportMutation__
 *
 * To run a mutation, you first call `useUpdateInvoiceImportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInvoiceImportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInvoiceImportMutation, { data, loading, error }] = useUpdateInvoiceImportMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateInvoiceImportMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInvoiceImportMutation, UpdateInvoiceImportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInvoiceImportMutation, UpdateInvoiceImportMutationVariables>(UpdateInvoiceImportDocument, options);
      }
export type UpdateInvoiceImportMutationHookResult = ReturnType<typeof useUpdateInvoiceImportMutation>;
export type UpdateInvoiceImportMutationResult = Apollo.MutationResult<UpdateInvoiceImportMutation>;
export type UpdateInvoiceImportMutationOptions = Apollo.BaseMutationOptions<UpdateInvoiceImportMutation, UpdateInvoiceImportMutationVariables>;
export const InvoiceImportsDocument = gql`
    query InvoiceImports {
  invoiceImports {
    id
    url
    supplierName
    storeId
    status
    createdAt
  }
}
    `;

/**
 * __useInvoiceImportsQuery__
 *
 * To run a query within a React component, call `useInvoiceImportsQuery` and pass it any options that fit your needs.
 * When your component renders, `useInvoiceImportsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInvoiceImportsQuery({
 *   variables: {
 *   },
 * });
 */
export function useInvoiceImportsQuery(baseOptions?: Apollo.QueryHookOptions<InvoiceImportsQuery, InvoiceImportsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InvoiceImportsQuery, InvoiceImportsQueryVariables>(InvoiceImportsDocument, options);
      }
export function useInvoiceImportsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InvoiceImportsQuery, InvoiceImportsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InvoiceImportsQuery, InvoiceImportsQueryVariables>(InvoiceImportsDocument, options);
        }
export function useInvoiceImportsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<InvoiceImportsQuery, InvoiceImportsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<InvoiceImportsQuery, InvoiceImportsQueryVariables>(InvoiceImportsDocument, options);
        }
export type InvoiceImportsQueryHookResult = ReturnType<typeof useInvoiceImportsQuery>;
export type InvoiceImportsLazyQueryHookResult = ReturnType<typeof useInvoiceImportsLazyQuery>;
export type InvoiceImportsSuspenseQueryHookResult = ReturnType<typeof useInvoiceImportsSuspenseQuery>;
export type InvoiceImportsQueryResult = Apollo.QueryResult<InvoiceImportsQuery, InvoiceImportsQueryVariables>;
export const CreateInvoiceImportDocument = gql`
    mutation CreateInvoiceImport($input: CreateInvoiceImportInput!) {
  adminCreateInvoiceImport(input: $input) {
    id
  }
}
    `;
export type CreateInvoiceImportMutationFn = Apollo.MutationFunction<CreateInvoiceImportMutation, CreateInvoiceImportMutationVariables>;

/**
 * __useCreateInvoiceImportMutation__
 *
 * To run a mutation, you first call `useCreateInvoiceImportMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateInvoiceImportMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createInvoiceImportMutation, { data, loading, error }] = useCreateInvoiceImportMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateInvoiceImportMutation(baseOptions?: Apollo.MutationHookOptions<CreateInvoiceImportMutation, CreateInvoiceImportMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateInvoiceImportMutation, CreateInvoiceImportMutationVariables>(CreateInvoiceImportDocument, options);
      }
export type CreateInvoiceImportMutationHookResult = ReturnType<typeof useCreateInvoiceImportMutation>;
export type CreateInvoiceImportMutationResult = Apollo.MutationResult<CreateInvoiceImportMutation>;
export type CreateInvoiceImportMutationOptions = Apollo.BaseMutationOptions<CreateInvoiceImportMutation, CreateInvoiceImportMutationVariables>;
export const LowStockDocument = gql`
    query LowStock($storeId: String, $limit: Int) {
  lowStockCandidates(storeId: $storeId, limit: $limit) {
    storeId
    storeName
    productVariantId
    productId
    productName
    barcode
    quantity
    reorderPoint
    reorderQty
    supplierId
    supplierName
    supplierDefaultCost
    supplierLeadTimeDays
    supplierIsPreferred
    supplierCount
  }
}
    `;

/**
 * __useLowStockQuery__
 *
 * To run a query within a React component, call `useLowStockQuery` and pass it any options that fit your needs.
 * When your component renders, `useLowStockQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLowStockQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useLowStockQuery(baseOptions?: Apollo.QueryHookOptions<LowStockQuery, LowStockQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LowStockQuery, LowStockQueryVariables>(LowStockDocument, options);
      }
export function useLowStockLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LowStockQuery, LowStockQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LowStockQuery, LowStockQueryVariables>(LowStockDocument, options);
        }
export function useLowStockSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<LowStockQuery, LowStockQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LowStockQuery, LowStockQueryVariables>(LowStockDocument, options);
        }
export type LowStockQueryHookResult = ReturnType<typeof useLowStockQuery>;
export type LowStockLazyQueryHookResult = ReturnType<typeof useLowStockLazyQuery>;
export type LowStockSuspenseQueryHookResult = ReturnType<typeof useLowStockSuspenseQuery>;
export type LowStockQueryResult = Apollo.QueryResult<LowStockQuery, LowStockQueryVariables>;
export const RunScanDocument = gql`
    mutation RunScan {
  runLowStockScanNow
}
    `;
export type RunScanMutationFn = Apollo.MutationFunction<RunScanMutation, RunScanMutationVariables>;

/**
 * __useRunScanMutation__
 *
 * To run a mutation, you first call `useRunScanMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRunScanMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [runScanMutation, { data, loading, error }] = useRunScanMutation({
 *   variables: {
 *   },
 * });
 */
export function useRunScanMutation(baseOptions?: Apollo.MutationHookOptions<RunScanMutation, RunScanMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RunScanMutation, RunScanMutationVariables>(RunScanDocument, options);
      }
export type RunScanMutationHookResult = ReturnType<typeof useRunScanMutation>;
export type RunScanMutationResult = Apollo.MutationResult<RunScanMutation>;
export type RunScanMutationOptions = Apollo.BaseMutationOptions<RunScanMutation, RunScanMutationVariables>;
export const CreateLowStockReqDocument = gql`
    mutation CreateLowStockReq($storeId: String!, $requestedById: String!) {
  createRequisitionFromLowStock(
    input: {storeId: $storeId, requestedById: $requestedById}
  )
}
    `;
export type CreateLowStockReqMutationFn = Apollo.MutationFunction<CreateLowStockReqMutation, CreateLowStockReqMutationVariables>;

/**
 * __useCreateLowStockReqMutation__
 *
 * To run a mutation, you first call `useCreateLowStockReqMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateLowStockReqMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createLowStockReqMutation, { data, loading, error }] = useCreateLowStockReqMutation({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      requestedById: // value for 'requestedById'
 *   },
 * });
 */
export function useCreateLowStockReqMutation(baseOptions?: Apollo.MutationHookOptions<CreateLowStockReqMutation, CreateLowStockReqMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateLowStockReqMutation, CreateLowStockReqMutationVariables>(CreateLowStockReqDocument, options);
      }
export type CreateLowStockReqMutationHookResult = ReturnType<typeof useCreateLowStockReqMutation>;
export type CreateLowStockReqMutationResult = Apollo.MutationResult<CreateLowStockReqMutation>;
export type CreateLowStockReqMutationOptions = Apollo.BaseMutationOptions<CreateLowStockReqMutation, CreateLowStockReqMutationVariables>;
export const CreateAndIssuePreferredDocument = gql`
    mutation CreateAndIssuePreferred($storeId: String!, $requestedById: String!) {
  createLowStockRequisitionAndIssuePreferred(
    input: {storeId: $storeId, requestedById: $requestedById}
  )
}
    `;
export type CreateAndIssuePreferredMutationFn = Apollo.MutationFunction<CreateAndIssuePreferredMutation, CreateAndIssuePreferredMutationVariables>;

/**
 * __useCreateAndIssuePreferredMutation__
 *
 * To run a mutation, you first call `useCreateAndIssuePreferredMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAndIssuePreferredMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAndIssuePreferredMutation, { data, loading, error }] = useCreateAndIssuePreferredMutation({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      requestedById: // value for 'requestedById'
 *   },
 * });
 */
export function useCreateAndIssuePreferredMutation(baseOptions?: Apollo.MutationHookOptions<CreateAndIssuePreferredMutation, CreateAndIssuePreferredMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAndIssuePreferredMutation, CreateAndIssuePreferredMutationVariables>(CreateAndIssuePreferredDocument, options);
      }
export type CreateAndIssuePreferredMutationHookResult = ReturnType<typeof useCreateAndIssuePreferredMutation>;
export type CreateAndIssuePreferredMutationResult = Apollo.MutationResult<CreateAndIssuePreferredMutation>;
export type CreateAndIssuePreferredMutationOptions = Apollo.BaseMutationOptions<CreateAndIssuePreferredMutation, CreateAndIssuePreferredMutationVariables>;
export const HeaderNotificationsDocument = gql`
    query HeaderNotifications {
  notifications {
    id
    isRead
    type
    message
    createdAt
  }
}
    `;

/**
 * __useHeaderNotificationsQuery__
 *
 * To run a query within a React component, call `useHeaderNotificationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useHeaderNotificationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHeaderNotificationsQuery({
 *   variables: {
 *   },
 * });
 */
export function useHeaderNotificationsQuery(baseOptions?: Apollo.QueryHookOptions<HeaderNotificationsQuery, HeaderNotificationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HeaderNotificationsQuery, HeaderNotificationsQueryVariables>(HeaderNotificationsDocument, options);
      }
export function useHeaderNotificationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HeaderNotificationsQuery, HeaderNotificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HeaderNotificationsQuery, HeaderNotificationsQueryVariables>(HeaderNotificationsDocument, options);
        }
export function useHeaderNotificationsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<HeaderNotificationsQuery, HeaderNotificationsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<HeaderNotificationsQuery, HeaderNotificationsQueryVariables>(HeaderNotificationsDocument, options);
        }
export type HeaderNotificationsQueryHookResult = ReturnType<typeof useHeaderNotificationsQuery>;
export type HeaderNotificationsLazyQueryHookResult = ReturnType<typeof useHeaderNotificationsLazyQuery>;
export type HeaderNotificationsSuspenseQueryHookResult = ReturnType<typeof useHeaderNotificationsSuspenseQuery>;
export type HeaderNotificationsQueryResult = Apollo.QueryResult<HeaderNotificationsQuery, HeaderNotificationsQueryVariables>;
export const OutboxStatusDocument = gql`
    query OutboxStatus {
  outboxStatus {
    pending
    failed
    published
  }
}
    `;

/**
 * __useOutboxStatusQuery__
 *
 * To run a query within a React component, call `useOutboxStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `useOutboxStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOutboxStatusQuery({
 *   variables: {
 *   },
 * });
 */
export function useOutboxStatusQuery(baseOptions?: Apollo.QueryHookOptions<OutboxStatusQuery, OutboxStatusQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OutboxStatusQuery, OutboxStatusQueryVariables>(OutboxStatusDocument, options);
      }
export function useOutboxStatusLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OutboxStatusQuery, OutboxStatusQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OutboxStatusQuery, OutboxStatusQueryVariables>(OutboxStatusDocument, options);
        }
export function useOutboxStatusSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<OutboxStatusQuery, OutboxStatusQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OutboxStatusQuery, OutboxStatusQueryVariables>(OutboxStatusDocument, options);
        }
export type OutboxStatusQueryHookResult = ReturnType<typeof useOutboxStatusQuery>;
export type OutboxStatusLazyQueryHookResult = ReturnType<typeof useOutboxStatusLazyQuery>;
export type OutboxStatusSuspenseQueryHookResult = ReturnType<typeof useOutboxStatusSuspenseQuery>;
export type OutboxStatusQueryResult = Apollo.QueryResult<OutboxStatusQuery, OutboxStatusQueryVariables>;
export const LastFailedOutboxEventsDocument = gql`
    query LastFailedOutboxEvents($limit: Int) {
  lastFailedOutboxEvents(limit: $limit) {
    id
    type
    lastError
    createdAt
  }
}
    `;

/**
 * __useLastFailedOutboxEventsQuery__
 *
 * To run a query within a React component, call `useLastFailedOutboxEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useLastFailedOutboxEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLastFailedOutboxEventsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useLastFailedOutboxEventsQuery(baseOptions?: Apollo.QueryHookOptions<LastFailedOutboxEventsQuery, LastFailedOutboxEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LastFailedOutboxEventsQuery, LastFailedOutboxEventsQueryVariables>(LastFailedOutboxEventsDocument, options);
      }
export function useLastFailedOutboxEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LastFailedOutboxEventsQuery, LastFailedOutboxEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LastFailedOutboxEventsQuery, LastFailedOutboxEventsQueryVariables>(LastFailedOutboxEventsDocument, options);
        }
export function useLastFailedOutboxEventsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<LastFailedOutboxEventsQuery, LastFailedOutboxEventsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LastFailedOutboxEventsQuery, LastFailedOutboxEventsQueryVariables>(LastFailedOutboxEventsDocument, options);
        }
export type LastFailedOutboxEventsQueryHookResult = ReturnType<typeof useLastFailedOutboxEventsQuery>;
export type LastFailedOutboxEventsLazyQueryHookResult = ReturnType<typeof useLastFailedOutboxEventsLazyQuery>;
export type LastFailedOutboxEventsSuspenseQueryHookResult = ReturnType<typeof useLastFailedOutboxEventsSuspenseQuery>;
export type LastFailedOutboxEventsQueryResult = Apollo.QueryResult<LastFailedOutboxEventsQuery, LastFailedOutboxEventsQueryVariables>;
export const OutboxStatusByTypeDocument = gql`
    query OutboxStatusByType($types: [String!]) {
  outboxStatusByType(types: $types) {
    type
    pending
    failed
    published
  }
}
    `;

/**
 * __useOutboxStatusByTypeQuery__
 *
 * To run a query within a React component, call `useOutboxStatusByTypeQuery` and pass it any options that fit your needs.
 * When your component renders, `useOutboxStatusByTypeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOutboxStatusByTypeQuery({
 *   variables: {
 *      types: // value for 'types'
 *   },
 * });
 */
export function useOutboxStatusByTypeQuery(baseOptions?: Apollo.QueryHookOptions<OutboxStatusByTypeQuery, OutboxStatusByTypeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OutboxStatusByTypeQuery, OutboxStatusByTypeQueryVariables>(OutboxStatusByTypeDocument, options);
      }
export function useOutboxStatusByTypeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OutboxStatusByTypeQuery, OutboxStatusByTypeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OutboxStatusByTypeQuery, OutboxStatusByTypeQueryVariables>(OutboxStatusByTypeDocument, options);
        }
export function useOutboxStatusByTypeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<OutboxStatusByTypeQuery, OutboxStatusByTypeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OutboxStatusByTypeQuery, OutboxStatusByTypeQueryVariables>(OutboxStatusByTypeDocument, options);
        }
export type OutboxStatusByTypeQueryHookResult = ReturnType<typeof useOutboxStatusByTypeQuery>;
export type OutboxStatusByTypeLazyQueryHookResult = ReturnType<typeof useOutboxStatusByTypeLazyQuery>;
export type OutboxStatusByTypeSuspenseQueryHookResult = ReturnType<typeof useOutboxStatusByTypeSuspenseQuery>;
export type OutboxStatusByTypeQueryResult = Apollo.QueryResult<OutboxStatusByTypeQuery, OutboxStatusByTypeQueryVariables>;
export const ProcessOutboxDocument = gql`
    mutation ProcessOutbox($limit: Int, $type: String, $status: OutboxStatus) {
  processOutbox(limit: $limit, type: $type, status: $status)
}
    `;
export type ProcessOutboxMutationFn = Apollo.MutationFunction<ProcessOutboxMutation, ProcessOutboxMutationVariables>;

/**
 * __useProcessOutboxMutation__
 *
 * To run a mutation, you first call `useProcessOutboxMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProcessOutboxMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [processOutboxMutation, { data, loading, error }] = useProcessOutboxMutation({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useProcessOutboxMutation(baseOptions?: Apollo.MutationHookOptions<ProcessOutboxMutation, ProcessOutboxMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProcessOutboxMutation, ProcessOutboxMutationVariables>(ProcessOutboxDocument, options);
      }
export type ProcessOutboxMutationHookResult = ReturnType<typeof useProcessOutboxMutation>;
export type ProcessOutboxMutationResult = Apollo.MutationResult<ProcessOutboxMutation>;
export type ProcessOutboxMutationOptions = Apollo.BaseMutationOptions<ProcessOutboxMutation, ProcessOutboxMutationVariables>;
export const RetryOutboxFailedDocument = gql`
    mutation RetryOutboxFailed($limit: Int, $type: String) {
  retryOutboxFailed(limit: $limit, type: $type)
}
    `;
export type RetryOutboxFailedMutationFn = Apollo.MutationFunction<RetryOutboxFailedMutation, RetryOutboxFailedMutationVariables>;

/**
 * __useRetryOutboxFailedMutation__
 *
 * To run a mutation, you first call `useRetryOutboxFailedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRetryOutboxFailedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [retryOutboxFailedMutation, { data, loading, error }] = useRetryOutboxFailedMutation({
 *   variables: {
 *      limit: // value for 'limit'
 *      type: // value for 'type'
 *   },
 * });
 */
export function useRetryOutboxFailedMutation(baseOptions?: Apollo.MutationHookOptions<RetryOutboxFailedMutation, RetryOutboxFailedMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RetryOutboxFailedMutation, RetryOutboxFailedMutationVariables>(RetryOutboxFailedDocument, options);
      }
export type RetryOutboxFailedMutationHookResult = ReturnType<typeof useRetryOutboxFailedMutation>;
export type RetryOutboxFailedMutationResult = Apollo.MutationResult<RetryOutboxFailedMutation>;
export type RetryOutboxFailedMutationOptions = Apollo.BaseMutationOptions<RetryOutboxFailedMutation, RetryOutboxFailedMutationVariables>;
export const StoresForPaymentsDocument = gql`
    query StoresForPayments {
  listStores(take: 200) {
    id
    name
  }
}
    `;

/**
 * __useStoresForPaymentsQuery__
 *
 * To run a query within a React component, call `useStoresForPaymentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoresForPaymentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoresForPaymentsQuery({
 *   variables: {
 *   },
 * });
 */
export function useStoresForPaymentsQuery(baseOptions?: Apollo.QueryHookOptions<StoresForPaymentsQuery, StoresForPaymentsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoresForPaymentsQuery, StoresForPaymentsQueryVariables>(StoresForPaymentsDocument, options);
      }
export function useStoresForPaymentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoresForPaymentsQuery, StoresForPaymentsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoresForPaymentsQuery, StoresForPaymentsQueryVariables>(StoresForPaymentsDocument, options);
        }
export function useStoresForPaymentsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StoresForPaymentsQuery, StoresForPaymentsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StoresForPaymentsQuery, StoresForPaymentsQueryVariables>(StoresForPaymentsDocument, options);
        }
export type StoresForPaymentsQueryHookResult = ReturnType<typeof useStoresForPaymentsQuery>;
export type StoresForPaymentsLazyQueryHookResult = ReturnType<typeof useStoresForPaymentsLazyQuery>;
export type StoresForPaymentsSuspenseQueryHookResult = ReturnType<typeof useStoresForPaymentsSuspenseQuery>;
export type StoresForPaymentsQueryResult = Apollo.QueryResult<StoresForPaymentsQuery, StoresForPaymentsQueryVariables>;
export const StorePaymentsSummaryDocument = gql`
    query StorePaymentsSummary($storeId: String!, $month: String) {
  storePaymentsSummary(storeId: $storeId, month: $month) {
    storeId
    month
    consumerPaid
    resellerPaid
    totalPaid
  }
}
    `;

/**
 * __useStorePaymentsSummaryQuery__
 *
 * To run a query within a React component, call `useStorePaymentsSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useStorePaymentsSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStorePaymentsSummaryQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      month: // value for 'month'
 *   },
 * });
 */
export function useStorePaymentsSummaryQuery(baseOptions: Apollo.QueryHookOptions<StorePaymentsSummaryQuery, StorePaymentsSummaryQueryVariables> & ({ variables: StorePaymentsSummaryQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StorePaymentsSummaryQuery, StorePaymentsSummaryQueryVariables>(StorePaymentsSummaryDocument, options);
      }
export function useStorePaymentsSummaryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StorePaymentsSummaryQuery, StorePaymentsSummaryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StorePaymentsSummaryQuery, StorePaymentsSummaryQueryVariables>(StorePaymentsSummaryDocument, options);
        }
export function useStorePaymentsSummarySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StorePaymentsSummaryQuery, StorePaymentsSummaryQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StorePaymentsSummaryQuery, StorePaymentsSummaryQueryVariables>(StorePaymentsSummaryDocument, options);
        }
export type StorePaymentsSummaryQueryHookResult = ReturnType<typeof useStorePaymentsSummaryQuery>;
export type StorePaymentsSummaryLazyQueryHookResult = ReturnType<typeof useStorePaymentsSummaryLazyQuery>;
export type StorePaymentsSummarySuspenseQueryHookResult = ReturnType<typeof useStorePaymentsSummarySuspenseQuery>;
export type StorePaymentsSummaryQueryResult = Apollo.QueryResult<StorePaymentsSummaryQuery, StorePaymentsSummaryQueryVariables>;
export const DailyPaymentsSeriesDocument = gql`
    query DailyPaymentsSeries($month: String, $storeId: String) {
  dailyPaymentsSeries(month: $month, storeId: $storeId) {
    date
    consumerPaid
    resellerPaid
    totalPaid
  }
}
    `;

/**
 * __useDailyPaymentsSeriesQuery__
 *
 * To run a query within a React component, call `useDailyPaymentsSeriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useDailyPaymentsSeriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDailyPaymentsSeriesQuery({
 *   variables: {
 *      month: // value for 'month'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useDailyPaymentsSeriesQuery(baseOptions?: Apollo.QueryHookOptions<DailyPaymentsSeriesQuery, DailyPaymentsSeriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DailyPaymentsSeriesQuery, DailyPaymentsSeriesQueryVariables>(DailyPaymentsSeriesDocument, options);
      }
export function useDailyPaymentsSeriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DailyPaymentsSeriesQuery, DailyPaymentsSeriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DailyPaymentsSeriesQuery, DailyPaymentsSeriesQueryVariables>(DailyPaymentsSeriesDocument, options);
        }
export function useDailyPaymentsSeriesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<DailyPaymentsSeriesQuery, DailyPaymentsSeriesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DailyPaymentsSeriesQuery, DailyPaymentsSeriesQueryVariables>(DailyPaymentsSeriesDocument, options);
        }
export type DailyPaymentsSeriesQueryHookResult = ReturnType<typeof useDailyPaymentsSeriesQuery>;
export type DailyPaymentsSeriesLazyQueryHookResult = ReturnType<typeof useDailyPaymentsSeriesLazyQuery>;
export type DailyPaymentsSeriesSuspenseQueryHookResult = ReturnType<typeof useDailyPaymentsSeriesSuspenseQuery>;
export type DailyPaymentsSeriesQueryResult = Apollo.QueryResult<DailyPaymentsSeriesQuery, DailyPaymentsSeriesQueryVariables>;
export const StorePaymentsSummaryRangeDocument = gql`
    query StorePaymentsSummaryRange($storeId: String!, $start: DateTime!, $end: DateTime!) {
  storePaymentsSummaryRange(storeId: $storeId, start: $start, end: $end) {
    storeId
    month
    consumerPaid
    resellerPaid
    totalPaid
  }
}
    `;

/**
 * __useStorePaymentsSummaryRangeQuery__
 *
 * To run a query within a React component, call `useStorePaymentsSummaryRangeQuery` and pass it any options that fit your needs.
 * When your component renders, `useStorePaymentsSummaryRangeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStorePaymentsSummaryRangeQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      start: // value for 'start'
 *      end: // value for 'end'
 *   },
 * });
 */
export function useStorePaymentsSummaryRangeQuery(baseOptions: Apollo.QueryHookOptions<StorePaymentsSummaryRangeQuery, StorePaymentsSummaryRangeQueryVariables> & ({ variables: StorePaymentsSummaryRangeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StorePaymentsSummaryRangeQuery, StorePaymentsSummaryRangeQueryVariables>(StorePaymentsSummaryRangeDocument, options);
      }
export function useStorePaymentsSummaryRangeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StorePaymentsSummaryRangeQuery, StorePaymentsSummaryRangeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StorePaymentsSummaryRangeQuery, StorePaymentsSummaryRangeQueryVariables>(StorePaymentsSummaryRangeDocument, options);
        }
export function useStorePaymentsSummaryRangeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StorePaymentsSummaryRangeQuery, StorePaymentsSummaryRangeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StorePaymentsSummaryRangeQuery, StorePaymentsSummaryRangeQueryVariables>(StorePaymentsSummaryRangeDocument, options);
        }
export type StorePaymentsSummaryRangeQueryHookResult = ReturnType<typeof useStorePaymentsSummaryRangeQuery>;
export type StorePaymentsSummaryRangeLazyQueryHookResult = ReturnType<typeof useStorePaymentsSummaryRangeLazyQuery>;
export type StorePaymentsSummaryRangeSuspenseQueryHookResult = ReturnType<typeof useStorePaymentsSummaryRangeSuspenseQuery>;
export type StorePaymentsSummaryRangeQueryResult = Apollo.QueryResult<StorePaymentsSummaryRangeQuery, StorePaymentsSummaryRangeQueryVariables>;
export const DailyPaymentsSeriesRangeDocument = gql`
    query DailyPaymentsSeriesRange($start: DateTime!, $end: DateTime!, $storeId: String) {
  dailyPaymentsSeriesRange(start: $start, end: $end, storeId: $storeId) {
    date
    consumerPaid
    resellerPaid
    totalPaid
  }
}
    `;

/**
 * __useDailyPaymentsSeriesRangeQuery__
 *
 * To run a query within a React component, call `useDailyPaymentsSeriesRangeQuery` and pass it any options that fit your needs.
 * When your component renders, `useDailyPaymentsSeriesRangeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDailyPaymentsSeriesRangeQuery({
 *   variables: {
 *      start: // value for 'start'
 *      end: // value for 'end'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useDailyPaymentsSeriesRangeQuery(baseOptions: Apollo.QueryHookOptions<DailyPaymentsSeriesRangeQuery, DailyPaymentsSeriesRangeQueryVariables> & ({ variables: DailyPaymentsSeriesRangeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DailyPaymentsSeriesRangeQuery, DailyPaymentsSeriesRangeQueryVariables>(DailyPaymentsSeriesRangeDocument, options);
      }
export function useDailyPaymentsSeriesRangeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DailyPaymentsSeriesRangeQuery, DailyPaymentsSeriesRangeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DailyPaymentsSeriesRangeQuery, DailyPaymentsSeriesRangeQueryVariables>(DailyPaymentsSeriesRangeDocument, options);
        }
export function useDailyPaymentsSeriesRangeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<DailyPaymentsSeriesRangeQuery, DailyPaymentsSeriesRangeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DailyPaymentsSeriesRangeQuery, DailyPaymentsSeriesRangeQueryVariables>(DailyPaymentsSeriesRangeDocument, options);
        }
export type DailyPaymentsSeriesRangeQueryHookResult = ReturnType<typeof useDailyPaymentsSeriesRangeQuery>;
export type DailyPaymentsSeriesRangeLazyQueryHookResult = ReturnType<typeof useDailyPaymentsSeriesRangeLazyQuery>;
export type DailyPaymentsSeriesRangeSuspenseQueryHookResult = ReturnType<typeof useDailyPaymentsSeriesRangeSuspenseQuery>;
export type DailyPaymentsSeriesRangeQueryResult = Apollo.QueryResult<DailyPaymentsSeriesRangeQuery, DailyPaymentsSeriesRangeQueryVariables>;
export const ProductFacetsDocument = gql`
    query ProductFacets($productId: String!) {
  productFacets(productId: $productId) {
    facet {
      id
      name
      code
      values
      isPrivate
    }
    value
  }
}
    `;

/**
 * __useProductFacetsQuery__
 *
 * To run a query within a React component, call `useProductFacetsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProductFacetsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProductFacetsQuery({
 *   variables: {
 *      productId: // value for 'productId'
 *   },
 * });
 */
export function useProductFacetsQuery(baseOptions: Apollo.QueryHookOptions<ProductFacetsQuery, ProductFacetsQueryVariables> & ({ variables: ProductFacetsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProductFacetsQuery, ProductFacetsQueryVariables>(ProductFacetsDocument, options);
      }
export function useProductFacetsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProductFacetsQuery, ProductFacetsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProductFacetsQuery, ProductFacetsQueryVariables>(ProductFacetsDocument, options);
        }
export function useProductFacetsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ProductFacetsQuery, ProductFacetsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProductFacetsQuery, ProductFacetsQueryVariables>(ProductFacetsDocument, options);
        }
export type ProductFacetsQueryHookResult = ReturnType<typeof useProductFacetsQuery>;
export type ProductFacetsLazyQueryHookResult = ReturnType<typeof useProductFacetsLazyQuery>;
export type ProductFacetsSuspenseQueryHookResult = ReturnType<typeof useProductFacetsSuspenseQuery>;
export type ProductFacetsQueryResult = Apollo.QueryResult<ProductFacetsQuery, ProductFacetsQueryVariables>;
export const AssignFacetToProductDocument = gql`
    mutation AssignFacetToProduct($productId: String!, $facetId: String!, $value: String!) {
  assignFacetToProduct(productId: $productId, facetId: $facetId, value: $value)
}
    `;
export type AssignFacetToProductMutationFn = Apollo.MutationFunction<AssignFacetToProductMutation, AssignFacetToProductMutationVariables>;

/**
 * __useAssignFacetToProductMutation__
 *
 * To run a mutation, you first call `useAssignFacetToProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAssignFacetToProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [assignFacetToProductMutation, { data, loading, error }] = useAssignFacetToProductMutation({
 *   variables: {
 *      productId: // value for 'productId'
 *      facetId: // value for 'facetId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useAssignFacetToProductMutation(baseOptions?: Apollo.MutationHookOptions<AssignFacetToProductMutation, AssignFacetToProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AssignFacetToProductMutation, AssignFacetToProductMutationVariables>(AssignFacetToProductDocument, options);
      }
export type AssignFacetToProductMutationHookResult = ReturnType<typeof useAssignFacetToProductMutation>;
export type AssignFacetToProductMutationResult = Apollo.MutationResult<AssignFacetToProductMutation>;
export type AssignFacetToProductMutationOptions = Apollo.BaseMutationOptions<AssignFacetToProductMutation, AssignFacetToProductMutationVariables>;
export const RemoveFacetFromProductDocument = gql`
    mutation RemoveFacetFromProduct($productId: String!, $facetId: String!, $value: String!) {
  removeFacetFromProduct(productId: $productId, facetId: $facetId, value: $value)
}
    `;
export type RemoveFacetFromProductMutationFn = Apollo.MutationFunction<RemoveFacetFromProductMutation, RemoveFacetFromProductMutationVariables>;

/**
 * __useRemoveFacetFromProductMutation__
 *
 * To run a mutation, you first call `useRemoveFacetFromProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveFacetFromProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeFacetFromProductMutation, { data, loading, error }] = useRemoveFacetFromProductMutation({
 *   variables: {
 *      productId: // value for 'productId'
 *      facetId: // value for 'facetId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useRemoveFacetFromProductMutation(baseOptions?: Apollo.MutationHookOptions<RemoveFacetFromProductMutation, RemoveFacetFromProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveFacetFromProductMutation, RemoveFacetFromProductMutationVariables>(RemoveFacetFromProductDocument, options);
      }
export type RemoveFacetFromProductMutationHookResult = ReturnType<typeof useRemoveFacetFromProductMutation>;
export type RemoveFacetFromProductMutationResult = Apollo.MutationResult<RemoveFacetFromProductMutation>;
export type RemoveFacetFromProductMutationOptions = Apollo.BaseMutationOptions<RemoveFacetFromProductMutation, RemoveFacetFromProductMutationVariables>;
export const CreateProductVariantDocument = gql`
    mutation CreateProductVariant($data: ProductVariantCreateInput!) {
  createProductVariant(data: $data) {
    id
  }
}
    `;
export type CreateProductVariantMutationFn = Apollo.MutationFunction<CreateProductVariantMutation, CreateProductVariantMutationVariables>;

/**
 * __useCreateProductVariantMutation__
 *
 * To run a mutation, you first call `useCreateProductVariantMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProductVariantMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProductVariantMutation, { data, loading, error }] = useCreateProductVariantMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateProductVariantMutation(baseOptions?: Apollo.MutationHookOptions<CreateProductVariantMutation, CreateProductVariantMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProductVariantMutation, CreateProductVariantMutationVariables>(CreateProductVariantDocument, options);
      }
export type CreateProductVariantMutationHookResult = ReturnType<typeof useCreateProductVariantMutation>;
export type CreateProductVariantMutationResult = Apollo.MutationResult<CreateProductVariantMutation>;
export type CreateProductVariantMutationOptions = Apollo.BaseMutationOptions<CreateProductVariantMutation, CreateProductVariantMutationVariables>;
export const UpdateProductDocument = gql`
    mutation UpdateProduct($id: String!, $data: ProductUpdateInput!) {
  updateProduct(where: {id: $id}, data: $data) {
    id
  }
}
    `;
export type UpdateProductMutationFn = Apollo.MutationFunction<UpdateProductMutation, UpdateProductMutationVariables>;

/**
 * __useUpdateProductMutation__
 *
 * To run a mutation, you first call `useUpdateProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProductMutation, { data, loading, error }] = useUpdateProductMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateProductMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProductMutation, UpdateProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProductMutation, UpdateProductMutationVariables>(UpdateProductDocument, options);
      }
export type UpdateProductMutationHookResult = ReturnType<typeof useUpdateProductMutation>;
export type UpdateProductMutationResult = Apollo.MutationResult<UpdateProductMutation>;
export type UpdateProductMutationOptions = Apollo.BaseMutationOptions<UpdateProductMutation, UpdateProductMutationVariables>;
export const UpdateProductVariantDocument = gql`
    mutation UpdateProductVariant($id: String!, $data: ProductVariantUpdateInput!) {
  updateProductVariant(where: {id: $id}, data: $data) {
    id
  }
}
    `;
export type UpdateProductVariantMutationFn = Apollo.MutationFunction<UpdateProductVariantMutation, UpdateProductVariantMutationVariables>;

/**
 * __useUpdateProductVariantMutation__
 *
 * To run a mutation, you first call `useUpdateProductVariantMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProductVariantMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProductVariantMutation, { data, loading, error }] = useUpdateProductVariantMutation({
 *   variables: {
 *      id: // value for 'id'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useUpdateProductVariantMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProductVariantMutation, UpdateProductVariantMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProductVariantMutation, UpdateProductVariantMutationVariables>(UpdateProductVariantDocument, options);
      }
export type UpdateProductVariantMutationHookResult = ReturnType<typeof useUpdateProductVariantMutation>;
export type UpdateProductVariantMutationResult = Apollo.MutationResult<UpdateProductVariantMutation>;
export type UpdateProductVariantMutationOptions = Apollo.BaseMutationOptions<UpdateProductVariantMutation, UpdateProductVariantMutationVariables>;
export const DeleteProductVariantDocument = gql`
    mutation DeleteProductVariant($id: String!) {
  deleteProductVariant(where: {id: $id}) {
    id
  }
}
    `;
export type DeleteProductVariantMutationFn = Apollo.MutationFunction<DeleteProductVariantMutation, DeleteProductVariantMutationVariables>;

/**
 * __useDeleteProductVariantMutation__
 *
 * To run a mutation, you first call `useDeleteProductVariantMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteProductVariantMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteProductVariantMutation, { data, loading, error }] = useDeleteProductVariantMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteProductVariantMutation(baseOptions?: Apollo.MutationHookOptions<DeleteProductVariantMutation, DeleteProductVariantMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteProductVariantMutation, DeleteProductVariantMutationVariables>(DeleteProductVariantDocument, options);
      }
export type DeleteProductVariantMutationHookResult = ReturnType<typeof useDeleteProductVariantMutation>;
export type DeleteProductVariantMutationResult = Apollo.MutationResult<DeleteProductVariantMutation>;
export type DeleteProductVariantMutationOptions = Apollo.BaseMutationOptions<DeleteProductVariantMutation, DeleteProductVariantMutationVariables>;
export const StockTotalsByProductDocument = gql`
    query StockTotalsByProduct($productId: String!) {
  stockTotalsByProduct(productId: $productId) {
    variantId
    onHand
    reserved
    available
  }
}
    `;

/**
 * __useStockTotalsByProductQuery__
 *
 * To run a query within a React component, call `useStockTotalsByProductQuery` and pass it any options that fit your needs.
 * When your component renders, `useStockTotalsByProductQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStockTotalsByProductQuery({
 *   variables: {
 *      productId: // value for 'productId'
 *   },
 * });
 */
export function useStockTotalsByProductQuery(baseOptions: Apollo.QueryHookOptions<StockTotalsByProductQuery, StockTotalsByProductQueryVariables> & ({ variables: StockTotalsByProductQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StockTotalsByProductQuery, StockTotalsByProductQueryVariables>(StockTotalsByProductDocument, options);
      }
export function useStockTotalsByProductLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StockTotalsByProductQuery, StockTotalsByProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StockTotalsByProductQuery, StockTotalsByProductQueryVariables>(StockTotalsByProductDocument, options);
        }
export function useStockTotalsByProductSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StockTotalsByProductQuery, StockTotalsByProductQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StockTotalsByProductQuery, StockTotalsByProductQueryVariables>(StockTotalsByProductDocument, options);
        }
export type StockTotalsByProductQueryHookResult = ReturnType<typeof useStockTotalsByProductQuery>;
export type StockTotalsByProductLazyQueryHookResult = ReturnType<typeof useStockTotalsByProductLazyQuery>;
export type StockTotalsByProductSuspenseQueryHookResult = ReturnType<typeof useStockTotalsByProductSuspenseQuery>;
export type StockTotalsByProductQueryResult = Apollo.QueryResult<StockTotalsByProductQuery, StockTotalsByProductQueryVariables>;
export const StockTotalsByProductStoreDocument = gql`
    query StockTotalsByProductStore($productId: String!, $storeId: String!) {
  stockTotalsByProductStore(productId: $productId, storeId: $storeId) {
    variantId
    onHand
    reserved
    available
  }
}
    `;

/**
 * __useStockTotalsByProductStoreQuery__
 *
 * To run a query within a React component, call `useStockTotalsByProductStoreQuery` and pass it any options that fit your needs.
 * When your component renders, `useStockTotalsByProductStoreQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStockTotalsByProductStoreQuery({
 *   variables: {
 *      productId: // value for 'productId'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useStockTotalsByProductStoreQuery(baseOptions: Apollo.QueryHookOptions<StockTotalsByProductStoreQuery, StockTotalsByProductStoreQueryVariables> & ({ variables: StockTotalsByProductStoreQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StockTotalsByProductStoreQuery, StockTotalsByProductStoreQueryVariables>(StockTotalsByProductStoreDocument, options);
      }
export function useStockTotalsByProductStoreLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StockTotalsByProductStoreQuery, StockTotalsByProductStoreQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StockTotalsByProductStoreQuery, StockTotalsByProductStoreQueryVariables>(StockTotalsByProductStoreDocument, options);
        }
export function useStockTotalsByProductStoreSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StockTotalsByProductStoreQuery, StockTotalsByProductStoreQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StockTotalsByProductStoreQuery, StockTotalsByProductStoreQueryVariables>(StockTotalsByProductStoreDocument, options);
        }
export type StockTotalsByProductStoreQueryHookResult = ReturnType<typeof useStockTotalsByProductStoreQuery>;
export type StockTotalsByProductStoreLazyQueryHookResult = ReturnType<typeof useStockTotalsByProductStoreLazyQuery>;
export type StockTotalsByProductStoreSuspenseQueryHookResult = ReturnType<typeof useStockTotalsByProductStoreSuspenseQuery>;
export type StockTotalsByProductStoreQueryResult = Apollo.QueryResult<StockTotalsByProductStoreQuery, StockTotalsByProductStoreQueryVariables>;
export const StockByVariantDocument = gql`
    query StockByVariant($productVariantId: ID!) {
  stock(input: {productVariantId: $productVariantId}) {
    id
    quantity
    reserved
    store {
      id
      name
    }
  }
}
    `;

/**
 * __useStockByVariantQuery__
 *
 * To run a query within a React component, call `useStockByVariantQuery` and pass it any options that fit your needs.
 * When your component renders, `useStockByVariantQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStockByVariantQuery({
 *   variables: {
 *      productVariantId: // value for 'productVariantId'
 *   },
 * });
 */
export function useStockByVariantQuery(baseOptions: Apollo.QueryHookOptions<StockByVariantQuery, StockByVariantQueryVariables> & ({ variables: StockByVariantQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StockByVariantQuery, StockByVariantQueryVariables>(StockByVariantDocument, options);
      }
export function useStockByVariantLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StockByVariantQuery, StockByVariantQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StockByVariantQuery, StockByVariantQueryVariables>(StockByVariantDocument, options);
        }
export function useStockByVariantSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StockByVariantQuery, StockByVariantQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StockByVariantQuery, StockByVariantQueryVariables>(StockByVariantDocument, options);
        }
export type StockByVariantQueryHookResult = ReturnType<typeof useStockByVariantQuery>;
export type StockByVariantLazyQueryHookResult = ReturnType<typeof useStockByVariantLazyQuery>;
export type StockByVariantSuspenseQueryHookResult = ReturnType<typeof useStockByVariantSuspenseQuery>;
export type StockByVariantQueryResult = Apollo.QueryResult<StockByVariantQuery, StockByVariantQueryVariables>;
export const ProductsDocument = gql`
    query Products($take: Int, $where: ProductWhereInput) {
  listProducts(take: $take, where: $where) {
    id
    name
    barcode
  }
}
    `;

/**
 * __useProductsQuery__
 *
 * To run a query within a React component, call `useProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProductsQuery({
 *   variables: {
 *      take: // value for 'take'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useProductsQuery(baseOptions?: Apollo.QueryHookOptions<ProductsQuery, ProductsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
      }
export function useProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProductsQuery, ProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
        }
export function useProductsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ProductsQuery, ProductsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
        }
export type ProductsQueryHookResult = ReturnType<typeof useProductsQuery>;
export type ProductsLazyQueryHookResult = ReturnType<typeof useProductsLazyQuery>;
export type ProductsSuspenseQueryHookResult = ReturnType<typeof useProductsSuspenseQuery>;
export type ProductsQueryResult = Apollo.QueryResult<ProductsQuery, ProductsQueryVariables>;
export const CreateProductDocument = gql`
    mutation CreateProduct($data: ProductCreateInput!) {
  createProduct(data: $data) {
    id
  }
}
    `;
export type CreateProductMutationFn = Apollo.MutationFunction<CreateProductMutation, CreateProductMutationVariables>;

/**
 * __useCreateProductMutation__
 *
 * To run a mutation, you first call `useCreateProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProductMutation, { data, loading, error }] = useCreateProductMutation({
 *   variables: {
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCreateProductMutation(baseOptions?: Apollo.MutationHookOptions<CreateProductMutation, CreateProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProductMutation, CreateProductMutationVariables>(CreateProductDocument, options);
      }
export type CreateProductMutationHookResult = ReturnType<typeof useCreateProductMutation>;
export type CreateProductMutationResult = Apollo.MutationResult<CreateProductMutation>;
export type CreateProductMutationOptions = Apollo.BaseMutationOptions<CreateProductMutation, CreateProductMutationVariables>;
export const ProductDocument = gql`
    query Product($id: String!) {
  findUniqueProduct(where: {id: $id}) {
    id
    name
    barcode
    description
    createdAt
    variants {
      id
      name
      barcode
      price
      resellerPrice
      createdAt
    }
  }
}
    `;

/**
 * __useProductQuery__
 *
 * To run a query within a React component, call `useProductQuery` and pass it any options that fit your needs.
 * When your component renders, `useProductQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProductQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useProductQuery(baseOptions: Apollo.QueryHookOptions<ProductQuery, ProductQueryVariables> & ({ variables: ProductQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProductQuery, ProductQueryVariables>(ProductDocument, options);
      }
export function useProductLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProductQuery, ProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProductQuery, ProductQueryVariables>(ProductDocument, options);
        }
export function useProductSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ProductQuery, ProductQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProductQuery, ProductQueryVariables>(ProductDocument, options);
        }
export type ProductQueryHookResult = ReturnType<typeof useProductQuery>;
export type ProductLazyQueryHookResult = ReturnType<typeof useProductLazyQuery>;
export type ProductSuspenseQueryHookResult = ReturnType<typeof useProductSuspenseQuery>;
export type ProductQueryResult = Apollo.QueryResult<ProductQuery, ProductQueryVariables>;
export const PurchaseOrderDocument = gql`
    query PurchaseOrder($id: String!) {
  purchaseOrder(id: $id) {
    id
    supplierId
    status
    phase
    totalAmount
    createdAt
    invoiceNumber
    supplier {
      id
      name
    }
    items {
      productVariantId
      quantity
      unitCost
      productVariant {
        id
        name
        barcode
        product {
          name
        }
      }
    }
  }
  purchaseOrderReceiptProgress(purchaseOrderId: $id) {
    productVariantId
    orderedQty
    receivedQty
  }
}
    `;

/**
 * __usePurchaseOrderQuery__
 *
 * To run a query within a React component, call `usePurchaseOrderQuery` and pass it any options that fit your needs.
 * When your component renders, `usePurchaseOrderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePurchaseOrderQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePurchaseOrderQuery(baseOptions: Apollo.QueryHookOptions<PurchaseOrderQuery, PurchaseOrderQueryVariables> & ({ variables: PurchaseOrderQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PurchaseOrderQuery, PurchaseOrderQueryVariables>(PurchaseOrderDocument, options);
      }
export function usePurchaseOrderLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PurchaseOrderQuery, PurchaseOrderQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PurchaseOrderQuery, PurchaseOrderQueryVariables>(PurchaseOrderDocument, options);
        }
export function usePurchaseOrderSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PurchaseOrderQuery, PurchaseOrderQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PurchaseOrderQuery, PurchaseOrderQueryVariables>(PurchaseOrderDocument, options);
        }
export type PurchaseOrderQueryHookResult = ReturnType<typeof usePurchaseOrderQuery>;
export type PurchaseOrderLazyQueryHookResult = ReturnType<typeof usePurchaseOrderLazyQuery>;
export type PurchaseOrderSuspenseQueryHookResult = ReturnType<typeof usePurchaseOrderSuspenseQuery>;
export type PurchaseOrderQueryResult = Apollo.QueryResult<PurchaseOrderQuery, PurchaseOrderQueryVariables>;
export const PurchaseOrdersDocument = gql`
    query PurchaseOrders($take: Int, $skip: Int) {
  purchaseOrders(take: $take, skip: $skip) {
    id
    invoiceNumber
    status
    phase
    createdAt
    supplier {
      id
      name
    }
  }
}
    `;

/**
 * __usePurchaseOrdersQuery__
 *
 * To run a query within a React component, call `usePurchaseOrdersQuery` and pass it any options that fit your needs.
 * When your component renders, `usePurchaseOrdersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePurchaseOrdersQuery({
 *   variables: {
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function usePurchaseOrdersQuery(baseOptions?: Apollo.QueryHookOptions<PurchaseOrdersQuery, PurchaseOrdersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PurchaseOrdersQuery, PurchaseOrdersQueryVariables>(PurchaseOrdersDocument, options);
      }
export function usePurchaseOrdersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PurchaseOrdersQuery, PurchaseOrdersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PurchaseOrdersQuery, PurchaseOrdersQueryVariables>(PurchaseOrdersDocument, options);
        }
export function usePurchaseOrdersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PurchaseOrdersQuery, PurchaseOrdersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PurchaseOrdersQuery, PurchaseOrdersQueryVariables>(PurchaseOrdersDocument, options);
        }
export type PurchaseOrdersQueryHookResult = ReturnType<typeof usePurchaseOrdersQuery>;
export type PurchaseOrdersLazyQueryHookResult = ReturnType<typeof usePurchaseOrdersLazyQuery>;
export type PurchaseOrdersSuspenseQueryHookResult = ReturnType<typeof usePurchaseOrdersSuspenseQuery>;
export type PurchaseOrdersQueryResult = Apollo.QueryResult<PurchaseOrdersQuery, PurchaseOrdersQueryVariables>;
export const PurchaseOrdersByStatusDocument = gql`
    query PurchaseOrdersByStatus($status: String!, $take: Int, $skip: Int) {
  purchaseOrdersByStatus(status: $status, take: $take, skip: $skip) {
    id
    invoiceNumber
    status
    phase
    createdAt
    supplier {
      id
      name
    }
  }
}
    `;

/**
 * __usePurchaseOrdersByStatusQuery__
 *
 * To run a query within a React component, call `usePurchaseOrdersByStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `usePurchaseOrdersByStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePurchaseOrdersByStatusQuery({
 *   variables: {
 *      status: // value for 'status'
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function usePurchaseOrdersByStatusQuery(baseOptions: Apollo.QueryHookOptions<PurchaseOrdersByStatusQuery, PurchaseOrdersByStatusQueryVariables> & ({ variables: PurchaseOrdersByStatusQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PurchaseOrdersByStatusQuery, PurchaseOrdersByStatusQueryVariables>(PurchaseOrdersByStatusDocument, options);
      }
export function usePurchaseOrdersByStatusLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PurchaseOrdersByStatusQuery, PurchaseOrdersByStatusQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PurchaseOrdersByStatusQuery, PurchaseOrdersByStatusQueryVariables>(PurchaseOrdersByStatusDocument, options);
        }
export function usePurchaseOrdersByStatusSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PurchaseOrdersByStatusQuery, PurchaseOrdersByStatusQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PurchaseOrdersByStatusQuery, PurchaseOrdersByStatusQueryVariables>(PurchaseOrdersByStatusDocument, options);
        }
export type PurchaseOrdersByStatusQueryHookResult = ReturnType<typeof usePurchaseOrdersByStatusQuery>;
export type PurchaseOrdersByStatusLazyQueryHookResult = ReturnType<typeof usePurchaseOrdersByStatusLazyQuery>;
export type PurchaseOrdersByStatusSuspenseQueryHookResult = ReturnType<typeof usePurchaseOrdersByStatusSuspenseQuery>;
export type PurchaseOrdersByStatusQueryResult = Apollo.QueryResult<PurchaseOrdersByStatusQuery, PurchaseOrdersByStatusQueryVariables>;
export const PurchaseOrdersByPhaseDocument = gql`
    query PurchaseOrdersByPhase($phase: String!, $take: Int, $skip: Int) {
  purchaseOrdersByPhase(phase: $phase, take: $take, skip: $skip) {
    id
    invoiceNumber
    status
    phase
    createdAt
    supplier {
      id
      name
    }
  }
}
    `;

/**
 * __usePurchaseOrdersByPhaseQuery__
 *
 * To run a query within a React component, call `usePurchaseOrdersByPhaseQuery` and pass it any options that fit your needs.
 * When your component renders, `usePurchaseOrdersByPhaseQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePurchaseOrdersByPhaseQuery({
 *   variables: {
 *      phase: // value for 'phase'
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function usePurchaseOrdersByPhaseQuery(baseOptions: Apollo.QueryHookOptions<PurchaseOrdersByPhaseQuery, PurchaseOrdersByPhaseQueryVariables> & ({ variables: PurchaseOrdersByPhaseQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PurchaseOrdersByPhaseQuery, PurchaseOrdersByPhaseQueryVariables>(PurchaseOrdersByPhaseDocument, options);
      }
export function usePurchaseOrdersByPhaseLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PurchaseOrdersByPhaseQuery, PurchaseOrdersByPhaseQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PurchaseOrdersByPhaseQuery, PurchaseOrdersByPhaseQueryVariables>(PurchaseOrdersByPhaseDocument, options);
        }
export function usePurchaseOrdersByPhaseSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PurchaseOrdersByPhaseQuery, PurchaseOrdersByPhaseQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PurchaseOrdersByPhaseQuery, PurchaseOrdersByPhaseQueryVariables>(PurchaseOrdersByPhaseDocument, options);
        }
export type PurchaseOrdersByPhaseQueryHookResult = ReturnType<typeof usePurchaseOrdersByPhaseQuery>;
export type PurchaseOrdersByPhaseLazyQueryHookResult = ReturnType<typeof usePurchaseOrdersByPhaseLazyQuery>;
export type PurchaseOrdersByPhaseSuspenseQueryHookResult = ReturnType<typeof usePurchaseOrdersByPhaseSuspenseQuery>;
export type PurchaseOrdersByPhaseQueryResult = Apollo.QueryResult<PurchaseOrdersByPhaseQuery, PurchaseOrdersByPhaseQueryVariables>;
export const PurchaseOrdersCountDocument = gql`
    query PurchaseOrdersCount($status: String, $phase: String) {
  purchaseOrdersCount(status: $status, phase: $phase)
}
    `;

/**
 * __usePurchaseOrdersCountQuery__
 *
 * To run a query within a React component, call `usePurchaseOrdersCountQuery` and pass it any options that fit your needs.
 * When your component renders, `usePurchaseOrdersCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePurchaseOrdersCountQuery({
 *   variables: {
 *      status: // value for 'status'
 *      phase: // value for 'phase'
 *   },
 * });
 */
export function usePurchaseOrdersCountQuery(baseOptions?: Apollo.QueryHookOptions<PurchaseOrdersCountQuery, PurchaseOrdersCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PurchaseOrdersCountQuery, PurchaseOrdersCountQueryVariables>(PurchaseOrdersCountDocument, options);
      }
export function usePurchaseOrdersCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PurchaseOrdersCountQuery, PurchaseOrdersCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PurchaseOrdersCountQuery, PurchaseOrdersCountQueryVariables>(PurchaseOrdersCountDocument, options);
        }
export function usePurchaseOrdersCountSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PurchaseOrdersCountQuery, PurchaseOrdersCountQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PurchaseOrdersCountQuery, PurchaseOrdersCountQueryVariables>(PurchaseOrdersCountDocument, options);
        }
export type PurchaseOrdersCountQueryHookResult = ReturnType<typeof usePurchaseOrdersCountQuery>;
export type PurchaseOrdersCountLazyQueryHookResult = ReturnType<typeof usePurchaseOrdersCountLazyQuery>;
export type PurchaseOrdersCountSuspenseQueryHookResult = ReturnType<typeof usePurchaseOrdersCountSuspenseQuery>;
export type PurchaseOrdersCountQueryResult = Apollo.QueryResult<PurchaseOrdersCountQuery, PurchaseOrdersCountQueryVariables>;
export const PurchaseOrdersSearchDocument = gql`
    query PurchaseOrdersSearch($q: String!, $take: Int, $skip: Int) {
  purchaseOrdersSearch(q: $q, take: $take, skip: $skip) {
    id
    invoiceNumber
    status
    phase
    createdAt
    supplier {
      id
      name
    }
  }
}
    `;

/**
 * __usePurchaseOrdersSearchQuery__
 *
 * To run a query within a React component, call `usePurchaseOrdersSearchQuery` and pass it any options that fit your needs.
 * When your component renders, `usePurchaseOrdersSearchQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePurchaseOrdersSearchQuery({
 *   variables: {
 *      q: // value for 'q'
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function usePurchaseOrdersSearchQuery(baseOptions: Apollo.QueryHookOptions<PurchaseOrdersSearchQuery, PurchaseOrdersSearchQueryVariables> & ({ variables: PurchaseOrdersSearchQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PurchaseOrdersSearchQuery, PurchaseOrdersSearchQueryVariables>(PurchaseOrdersSearchDocument, options);
      }
export function usePurchaseOrdersSearchLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PurchaseOrdersSearchQuery, PurchaseOrdersSearchQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PurchaseOrdersSearchQuery, PurchaseOrdersSearchQueryVariables>(PurchaseOrdersSearchDocument, options);
        }
export function usePurchaseOrdersSearchSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PurchaseOrdersSearchQuery, PurchaseOrdersSearchQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PurchaseOrdersSearchQuery, PurchaseOrdersSearchQueryVariables>(PurchaseOrdersSearchDocument, options);
        }
export type PurchaseOrdersSearchQueryHookResult = ReturnType<typeof usePurchaseOrdersSearchQuery>;
export type PurchaseOrdersSearchLazyQueryHookResult = ReturnType<typeof usePurchaseOrdersSearchLazyQuery>;
export type PurchaseOrdersSearchSuspenseQueryHookResult = ReturnType<typeof usePurchaseOrdersSearchSuspenseQuery>;
export type PurchaseOrdersSearchQueryResult = Apollo.QueryResult<PurchaseOrdersSearchQuery, PurchaseOrdersSearchQueryVariables>;
export const PurchaseOrdersSearchCountDocument = gql`
    query PurchaseOrdersSearchCount($q: String!) {
  purchaseOrdersSearchCount(q: $q)
}
    `;

/**
 * __usePurchaseOrdersSearchCountQuery__
 *
 * To run a query within a React component, call `usePurchaseOrdersSearchCountQuery` and pass it any options that fit your needs.
 * When your component renders, `usePurchaseOrdersSearchCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePurchaseOrdersSearchCountQuery({
 *   variables: {
 *      q: // value for 'q'
 *   },
 * });
 */
export function usePurchaseOrdersSearchCountQuery(baseOptions: Apollo.QueryHookOptions<PurchaseOrdersSearchCountQuery, PurchaseOrdersSearchCountQueryVariables> & ({ variables: PurchaseOrdersSearchCountQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PurchaseOrdersSearchCountQuery, PurchaseOrdersSearchCountQueryVariables>(PurchaseOrdersSearchCountDocument, options);
      }
export function usePurchaseOrdersSearchCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PurchaseOrdersSearchCountQuery, PurchaseOrdersSearchCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PurchaseOrdersSearchCountQuery, PurchaseOrdersSearchCountQueryVariables>(PurchaseOrdersSearchCountDocument, options);
        }
export function usePurchaseOrdersSearchCountSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PurchaseOrdersSearchCountQuery, PurchaseOrdersSearchCountQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PurchaseOrdersSearchCountQuery, PurchaseOrdersSearchCountQueryVariables>(PurchaseOrdersSearchCountDocument, options);
        }
export type PurchaseOrdersSearchCountQueryHookResult = ReturnType<typeof usePurchaseOrdersSearchCountQuery>;
export type PurchaseOrdersSearchCountLazyQueryHookResult = ReturnType<typeof usePurchaseOrdersSearchCountLazyQuery>;
export type PurchaseOrdersSearchCountSuspenseQueryHookResult = ReturnType<typeof usePurchaseOrdersSearchCountSuspenseQuery>;
export type PurchaseOrdersSearchCountQueryResult = Apollo.QueryResult<PurchaseOrdersSearchCountQuery, PurchaseOrdersSearchCountQueryVariables>;
export const UpdatePoStatusDocument = gql`
    mutation UpdatePoStatus($input: UpdatePurchaseOrderStatusInput!) {
  updatePurchaseOrderStatus(input: $input) {
    id
    status
  }
}
    `;
export type UpdatePoStatusMutationFn = Apollo.MutationFunction<UpdatePoStatusMutation, UpdatePoStatusMutationVariables>;

/**
 * __useUpdatePoStatusMutation__
 *
 * To run a mutation, you first call `useUpdatePoStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePoStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePoStatusMutation, { data, loading, error }] = useUpdatePoStatusMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePoStatusMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePoStatusMutation, UpdatePoStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePoStatusMutation, UpdatePoStatusMutationVariables>(UpdatePoStatusDocument, options);
      }
export type UpdatePoStatusMutationHookResult = ReturnType<typeof useUpdatePoStatusMutation>;
export type UpdatePoStatusMutationResult = Apollo.MutationResult<UpdatePoStatusMutation>;
export type UpdatePoStatusMutationOptions = Apollo.BaseMutationOptions<UpdatePoStatusMutation, UpdatePoStatusMutationVariables>;
export const ReceiveStockDocument = gql`
    mutation ReceiveStock($input: ReceiveStockBatchInput!) {
  receiveStockBatch(input: $input) {
    id
    storeId
  }
}
    `;
export type ReceiveStockMutationFn = Apollo.MutationFunction<ReceiveStockMutation, ReceiveStockMutationVariables>;

/**
 * __useReceiveStockMutation__
 *
 * To run a mutation, you first call `useReceiveStockMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReceiveStockMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [receiveStockMutation, { data, loading, error }] = useReceiveStockMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useReceiveStockMutation(baseOptions?: Apollo.MutationHookOptions<ReceiveStockMutation, ReceiveStockMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReceiveStockMutation, ReceiveStockMutationVariables>(ReceiveStockDocument, options);
      }
export type ReceiveStockMutationHookResult = ReturnType<typeof useReceiveStockMutation>;
export type ReceiveStockMutationResult = Apollo.MutationResult<ReceiveStockMutation>;
export type ReceiveStockMutationOptions = Apollo.BaseMutationOptions<ReceiveStockMutation, ReceiveStockMutationVariables>;
export const RfqDashboardDocument = gql`
    query RfqDashboard($id: String!) {
  rfqDashboard(requisitionId: $id) {
    draft
    submitted
    selected
    rejected
    total
    pendingQuotes {
      id
      requisitionId
      supplierId
      status
      validUntil
      createdAt
    }
  }
  purchaseRequisitionSummary(id: $id) {
    id
    status
    createdAt
  }
}
    `;

/**
 * __useRfqDashboardQuery__
 *
 * To run a query within a React component, call `useRfqDashboardQuery` and pass it any options that fit your needs.
 * When your component renders, `useRfqDashboardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRfqDashboardQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRfqDashboardQuery(baseOptions: Apollo.QueryHookOptions<RfqDashboardQuery, RfqDashboardQueryVariables> & ({ variables: RfqDashboardQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RfqDashboardQuery, RfqDashboardQueryVariables>(RfqDashboardDocument, options);
      }
export function useRfqDashboardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RfqDashboardQuery, RfqDashboardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RfqDashboardQuery, RfqDashboardQueryVariables>(RfqDashboardDocument, options);
        }
export function useRfqDashboardSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<RfqDashboardQuery, RfqDashboardQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RfqDashboardQuery, RfqDashboardQueryVariables>(RfqDashboardDocument, options);
        }
export type RfqDashboardQueryHookResult = ReturnType<typeof useRfqDashboardQuery>;
export type RfqDashboardLazyQueryHookResult = ReturnType<typeof useRfqDashboardLazyQuery>;
export type RfqDashboardSuspenseQueryHookResult = ReturnType<typeof useRfqDashboardSuspenseQuery>;
export type RfqDashboardQueryResult = Apollo.QueryResult<RfqDashboardQuery, RfqDashboardQueryVariables>;
export const QuotesByReqDocument = gql`
    query QuotesByReq($id: String!) {
  supplierQuotesByRequisition(requisitionId: $id) {
    id
    requisitionId
    supplierId
    status
    validUntil
    createdAt
  }
}
    `;

/**
 * __useQuotesByReqQuery__
 *
 * To run a query within a React component, call `useQuotesByReqQuery` and pass it any options that fit your needs.
 * When your component renders, `useQuotesByReqQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQuotesByReqQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useQuotesByReqQuery(baseOptions: Apollo.QueryHookOptions<QuotesByReqQuery, QuotesByReqQueryVariables> & ({ variables: QuotesByReqQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<QuotesByReqQuery, QuotesByReqQueryVariables>(QuotesByReqDocument, options);
      }
export function useQuotesByReqLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<QuotesByReqQuery, QuotesByReqQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<QuotesByReqQuery, QuotesByReqQueryVariables>(QuotesByReqDocument, options);
        }
export function useQuotesByReqSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<QuotesByReqQuery, QuotesByReqQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<QuotesByReqQuery, QuotesByReqQueryVariables>(QuotesByReqDocument, options);
        }
export type QuotesByReqQueryHookResult = ReturnType<typeof useQuotesByReqQuery>;
export type QuotesByReqLazyQueryHookResult = ReturnType<typeof useQuotesByReqLazyQuery>;
export type QuotesByReqSuspenseQueryHookResult = ReturnType<typeof useQuotesByReqSuspenseQuery>;
export type QuotesByReqQueryResult = Apollo.QueryResult<QuotesByReqQuery, QuotesByReqQueryVariables>;
export const IssueRfqPreferredDocument = gql`
    mutation IssueRFQPreferred($id: String!) {
  issueRFQPreferred(requisitionId: $id)
}
    `;
export type IssueRfqPreferredMutationFn = Apollo.MutationFunction<IssueRfqPreferredMutation, IssueRfqPreferredMutationVariables>;

/**
 * __useIssueRfqPreferredMutation__
 *
 * To run a mutation, you first call `useIssueRfqPreferredMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useIssueRfqPreferredMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [issueRfqPreferredMutation, { data, loading, error }] = useIssueRfqPreferredMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useIssueRfqPreferredMutation(baseOptions?: Apollo.MutationHookOptions<IssueRfqPreferredMutation, IssueRfqPreferredMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<IssueRfqPreferredMutation, IssueRfqPreferredMutationVariables>(IssueRfqPreferredDocument, options);
      }
export type IssueRfqPreferredMutationHookResult = ReturnType<typeof useIssueRfqPreferredMutation>;
export type IssueRfqPreferredMutationResult = Apollo.MutationResult<IssueRfqPreferredMutation>;
export type IssueRfqPreferredMutationOptions = Apollo.BaseMutationOptions<IssueRfqPreferredMutation, IssueRfqPreferredMutationVariables>;
export const SelectSupplierQuoteDocument = gql`
    mutation SelectSupplierQuote($quoteId: String!, $exclusive: Boolean) {
  selectSupplierQuote(input: {quoteId: $quoteId, exclusive: $exclusive})
}
    `;
export type SelectSupplierQuoteMutationFn = Apollo.MutationFunction<SelectSupplierQuoteMutation, SelectSupplierQuoteMutationVariables>;

/**
 * __useSelectSupplierQuoteMutation__
 *
 * To run a mutation, you first call `useSelectSupplierQuoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSelectSupplierQuoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [selectSupplierQuoteMutation, { data, loading, error }] = useSelectSupplierQuoteMutation({
 *   variables: {
 *      quoteId: // value for 'quoteId'
 *      exclusive: // value for 'exclusive'
 *   },
 * });
 */
export function useSelectSupplierQuoteMutation(baseOptions?: Apollo.MutationHookOptions<SelectSupplierQuoteMutation, SelectSupplierQuoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SelectSupplierQuoteMutation, SelectSupplierQuoteMutationVariables>(SelectSupplierQuoteDocument, options);
      }
export type SelectSupplierQuoteMutationHookResult = ReturnType<typeof useSelectSupplierQuoteMutation>;
export type SelectSupplierQuoteMutationResult = Apollo.MutationResult<SelectSupplierQuoteMutation>;
export type SelectSupplierQuoteMutationOptions = Apollo.BaseMutationOptions<SelectSupplierQuoteMutation, SelectSupplierQuoteMutationVariables>;
export const RejectSupplierQuoteDocument = gql`
    mutation RejectSupplierQuote($quoteId: String!, $reason: String) {
  rejectSupplierQuote(input: {quoteId: $quoteId, reason: $reason})
}
    `;
export type RejectSupplierQuoteMutationFn = Apollo.MutationFunction<RejectSupplierQuoteMutation, RejectSupplierQuoteMutationVariables>;

/**
 * __useRejectSupplierQuoteMutation__
 *
 * To run a mutation, you first call `useRejectSupplierQuoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRejectSupplierQuoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [rejectSupplierQuoteMutation, { data, loading, error }] = useRejectSupplierQuoteMutation({
 *   variables: {
 *      quoteId: // value for 'quoteId'
 *      reason: // value for 'reason'
 *   },
 * });
 */
export function useRejectSupplierQuoteMutation(baseOptions?: Apollo.MutationHookOptions<RejectSupplierQuoteMutation, RejectSupplierQuoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RejectSupplierQuoteMutation, RejectSupplierQuoteMutationVariables>(RejectSupplierQuoteDocument, options);
      }
export type RejectSupplierQuoteMutationHookResult = ReturnType<typeof useRejectSupplierQuoteMutation>;
export type RejectSupplierQuoteMutationResult = Apollo.MutationResult<RejectSupplierQuoteMutation>;
export type RejectSupplierQuoteMutationOptions = Apollo.BaseMutationOptions<RejectSupplierQuoteMutation, RejectSupplierQuoteMutationVariables>;
export const SubmitPurchaseRequisitionDocument = gql`
    mutation SubmitPurchaseRequisition($id: String!) {
  submitPurchaseRequisition(input: {id: $id})
}
    `;
export type SubmitPurchaseRequisitionMutationFn = Apollo.MutationFunction<SubmitPurchaseRequisitionMutation, SubmitPurchaseRequisitionMutationVariables>;

/**
 * __useSubmitPurchaseRequisitionMutation__
 *
 * To run a mutation, you first call `useSubmitPurchaseRequisitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitPurchaseRequisitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitPurchaseRequisitionMutation, { data, loading, error }] = useSubmitPurchaseRequisitionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSubmitPurchaseRequisitionMutation(baseOptions?: Apollo.MutationHookOptions<SubmitPurchaseRequisitionMutation, SubmitPurchaseRequisitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubmitPurchaseRequisitionMutation, SubmitPurchaseRequisitionMutationVariables>(SubmitPurchaseRequisitionDocument, options);
      }
export type SubmitPurchaseRequisitionMutationHookResult = ReturnType<typeof useSubmitPurchaseRequisitionMutation>;
export type SubmitPurchaseRequisitionMutationResult = Apollo.MutationResult<SubmitPurchaseRequisitionMutation>;
export type SubmitPurchaseRequisitionMutationOptions = Apollo.BaseMutationOptions<SubmitPurchaseRequisitionMutation, SubmitPurchaseRequisitionMutationVariables>;
export const ApprovePurchaseRequisitionDocument = gql`
    mutation ApprovePurchaseRequisition($id: String!) {
  approvePurchaseRequisition(input: {id: $id})
}
    `;
export type ApprovePurchaseRequisitionMutationFn = Apollo.MutationFunction<ApprovePurchaseRequisitionMutation, ApprovePurchaseRequisitionMutationVariables>;

/**
 * __useApprovePurchaseRequisitionMutation__
 *
 * To run a mutation, you first call `useApprovePurchaseRequisitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApprovePurchaseRequisitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approvePurchaseRequisitionMutation, { data, loading, error }] = useApprovePurchaseRequisitionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useApprovePurchaseRequisitionMutation(baseOptions?: Apollo.MutationHookOptions<ApprovePurchaseRequisitionMutation, ApprovePurchaseRequisitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApprovePurchaseRequisitionMutation, ApprovePurchaseRequisitionMutationVariables>(ApprovePurchaseRequisitionDocument, options);
      }
export type ApprovePurchaseRequisitionMutationHookResult = ReturnType<typeof useApprovePurchaseRequisitionMutation>;
export type ApprovePurchaseRequisitionMutationResult = Apollo.MutationResult<ApprovePurchaseRequisitionMutation>;
export type ApprovePurchaseRequisitionMutationOptions = Apollo.BaseMutationOptions<ApprovePurchaseRequisitionMutation, ApprovePurchaseRequisitionMutationVariables>;
export const RejectPurchaseRequisitionDocument = gql`
    mutation RejectPurchaseRequisition($id: String!, $reason: String) {
  rejectPurchaseRequisition(input: {id: $id, reason: $reason})
}
    `;
export type RejectPurchaseRequisitionMutationFn = Apollo.MutationFunction<RejectPurchaseRequisitionMutation, RejectPurchaseRequisitionMutationVariables>;

/**
 * __useRejectPurchaseRequisitionMutation__
 *
 * To run a mutation, you first call `useRejectPurchaseRequisitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRejectPurchaseRequisitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [rejectPurchaseRequisitionMutation, { data, loading, error }] = useRejectPurchaseRequisitionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      reason: // value for 'reason'
 *   },
 * });
 */
export function useRejectPurchaseRequisitionMutation(baseOptions?: Apollo.MutationHookOptions<RejectPurchaseRequisitionMutation, RejectPurchaseRequisitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RejectPurchaseRequisitionMutation, RejectPurchaseRequisitionMutationVariables>(RejectPurchaseRequisitionDocument, options);
      }
export type RejectPurchaseRequisitionMutationHookResult = ReturnType<typeof useRejectPurchaseRequisitionMutation>;
export type RejectPurchaseRequisitionMutationResult = Apollo.MutationResult<RejectPurchaseRequisitionMutation>;
export type RejectPurchaseRequisitionMutationOptions = Apollo.BaseMutationOptions<RejectPurchaseRequisitionMutation, RejectPurchaseRequisitionMutationVariables>;
export const RequisitionsByStatusDocument = gql`
    query RequisitionsByStatus($status: String!, $storeId: String, $take: Int, $skip: Int) {
  requisitionsByStatus(
    status: $status
    storeId: $storeId
    take: $take
    skip: $skip
  ) {
    id
    storeId
    requestedById
    status
    createdAt
  }
}
    `;

/**
 * __useRequisitionsByStatusQuery__
 *
 * To run a query within a React component, call `useRequisitionsByStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `useRequisitionsByStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRequisitionsByStatusQuery({
 *   variables: {
 *      status: // value for 'status'
 *      storeId: // value for 'storeId'
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function useRequisitionsByStatusQuery(baseOptions: Apollo.QueryHookOptions<RequisitionsByStatusQuery, RequisitionsByStatusQueryVariables> & ({ variables: RequisitionsByStatusQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RequisitionsByStatusQuery, RequisitionsByStatusQueryVariables>(RequisitionsByStatusDocument, options);
      }
export function useRequisitionsByStatusLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RequisitionsByStatusQuery, RequisitionsByStatusQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RequisitionsByStatusQuery, RequisitionsByStatusQueryVariables>(RequisitionsByStatusDocument, options);
        }
export function useRequisitionsByStatusSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<RequisitionsByStatusQuery, RequisitionsByStatusQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RequisitionsByStatusQuery, RequisitionsByStatusQueryVariables>(RequisitionsByStatusDocument, options);
        }
export type RequisitionsByStatusQueryHookResult = ReturnType<typeof useRequisitionsByStatusQuery>;
export type RequisitionsByStatusLazyQueryHookResult = ReturnType<typeof useRequisitionsByStatusLazyQuery>;
export type RequisitionsByStatusSuspenseQueryHookResult = ReturnType<typeof useRequisitionsByStatusSuspenseQuery>;
export type RequisitionsByStatusQueryResult = Apollo.QueryResult<RequisitionsByStatusQuery, RequisitionsByStatusQueryVariables>;
export const RequisitionsCountByStatusDocument = gql`
    query RequisitionsCountByStatus($status: String!, $storeId: String) {
  requisitionsCountByStatus(status: $status, storeId: $storeId)
}
    `;

/**
 * __useRequisitionsCountByStatusQuery__
 *
 * To run a query within a React component, call `useRequisitionsCountByStatusQuery` and pass it any options that fit your needs.
 * When your component renders, `useRequisitionsCountByStatusQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRequisitionsCountByStatusQuery({
 *   variables: {
 *      status: // value for 'status'
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useRequisitionsCountByStatusQuery(baseOptions: Apollo.QueryHookOptions<RequisitionsCountByStatusQuery, RequisitionsCountByStatusQueryVariables> & ({ variables: RequisitionsCountByStatusQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RequisitionsCountByStatusQuery, RequisitionsCountByStatusQueryVariables>(RequisitionsCountByStatusDocument, options);
      }
export function useRequisitionsCountByStatusLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RequisitionsCountByStatusQuery, RequisitionsCountByStatusQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RequisitionsCountByStatusQuery, RequisitionsCountByStatusQueryVariables>(RequisitionsCountByStatusDocument, options);
        }
export function useRequisitionsCountByStatusSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<RequisitionsCountByStatusQuery, RequisitionsCountByStatusQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RequisitionsCountByStatusQuery, RequisitionsCountByStatusQueryVariables>(RequisitionsCountByStatusDocument, options);
        }
export type RequisitionsCountByStatusQueryHookResult = ReturnType<typeof useRequisitionsCountByStatusQuery>;
export type RequisitionsCountByStatusLazyQueryHookResult = ReturnType<typeof useRequisitionsCountByStatusLazyQuery>;
export type RequisitionsCountByStatusSuspenseQueryHookResult = ReturnType<typeof useRequisitionsCountByStatusSuspenseQuery>;
export type RequisitionsCountByStatusQueryResult = Apollo.QueryResult<RequisitionsCountByStatusQuery, RequisitionsCountByStatusQueryVariables>;
export const RequisitionsByStoreDocument = gql`
    query RequisitionsByStore($storeId: String!, $status: String, $take: Int, $skip: Int) {
  requisitionsByStore(
    storeId: $storeId
    status: $status
    take: $take
    skip: $skip
  ) {
    id
    storeId
    requestedById
    status
    createdAt
  }
}
    `;

/**
 * __useRequisitionsByStoreQuery__
 *
 * To run a query within a React component, call `useRequisitionsByStoreQuery` and pass it any options that fit your needs.
 * When your component renders, `useRequisitionsByStoreQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRequisitionsByStoreQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      status: // value for 'status'
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function useRequisitionsByStoreQuery(baseOptions: Apollo.QueryHookOptions<RequisitionsByStoreQuery, RequisitionsByStoreQueryVariables> & ({ variables: RequisitionsByStoreQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RequisitionsByStoreQuery, RequisitionsByStoreQueryVariables>(RequisitionsByStoreDocument, options);
      }
export function useRequisitionsByStoreLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RequisitionsByStoreQuery, RequisitionsByStoreQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RequisitionsByStoreQuery, RequisitionsByStoreQueryVariables>(RequisitionsByStoreDocument, options);
        }
export function useRequisitionsByStoreSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<RequisitionsByStoreQuery, RequisitionsByStoreQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RequisitionsByStoreQuery, RequisitionsByStoreQueryVariables>(RequisitionsByStoreDocument, options);
        }
export type RequisitionsByStoreQueryHookResult = ReturnType<typeof useRequisitionsByStoreQuery>;
export type RequisitionsByStoreLazyQueryHookResult = ReturnType<typeof useRequisitionsByStoreLazyQuery>;
export type RequisitionsByStoreSuspenseQueryHookResult = ReturnType<typeof useRequisitionsByStoreSuspenseQuery>;
export type RequisitionsByStoreQueryResult = Apollo.QueryResult<RequisitionsByStoreQuery, RequisitionsByStoreQueryVariables>;
export const RequisitionsCountByStoreDocument = gql`
    query RequisitionsCountByStore($storeId: String!, $status: String) {
  requisitionsCountByStore(storeId: $storeId, status: $status)
}
    `;

/**
 * __useRequisitionsCountByStoreQuery__
 *
 * To run a query within a React component, call `useRequisitionsCountByStoreQuery` and pass it any options that fit your needs.
 * When your component renders, `useRequisitionsCountByStoreQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRequisitionsCountByStoreQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      status: // value for 'status'
 *   },
 * });
 */
export function useRequisitionsCountByStoreQuery(baseOptions: Apollo.QueryHookOptions<RequisitionsCountByStoreQuery, RequisitionsCountByStoreQueryVariables> & ({ variables: RequisitionsCountByStoreQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RequisitionsCountByStoreQuery, RequisitionsCountByStoreQueryVariables>(RequisitionsCountByStoreDocument, options);
      }
export function useRequisitionsCountByStoreLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RequisitionsCountByStoreQuery, RequisitionsCountByStoreQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RequisitionsCountByStoreQuery, RequisitionsCountByStoreQueryVariables>(RequisitionsCountByStoreDocument, options);
        }
export function useRequisitionsCountByStoreSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<RequisitionsCountByStoreQuery, RequisitionsCountByStoreQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RequisitionsCountByStoreQuery, RequisitionsCountByStoreQueryVariables>(RequisitionsCountByStoreDocument, options);
        }
export type RequisitionsCountByStoreQueryHookResult = ReturnType<typeof useRequisitionsCountByStoreQuery>;
export type RequisitionsCountByStoreLazyQueryHookResult = ReturnType<typeof useRequisitionsCountByStoreLazyQuery>;
export type RequisitionsCountByStoreSuspenseQueryHookResult = ReturnType<typeof useRequisitionsCountByStoreSuspenseQuery>;
export type RequisitionsCountByStoreQueryResult = Apollo.QueryResult<RequisitionsCountByStoreQuery, RequisitionsCountByStoreQueryVariables>;
export const PendingResellerApplicationsDocument = gql`
    query PendingResellerApplications($take: Int, $skip: Int, $q: String) {
  pendingResellerApplications(take: $take, skip: $skip, q: $q) {
    userId
    tier
    creditLimit
    requestedAt
    requestedBillerId
    biller {
      id
      email
    }
    requestedBiller {
      id
      email
    }
    user {
      id
      email
    }
  }
}
    `;

/**
 * __usePendingResellerApplicationsQuery__
 *
 * To run a query within a React component, call `usePendingResellerApplicationsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePendingResellerApplicationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePendingResellerApplicationsQuery({
 *   variables: {
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *      q: // value for 'q'
 *   },
 * });
 */
export function usePendingResellerApplicationsQuery(baseOptions?: Apollo.QueryHookOptions<PendingResellerApplicationsQuery, PendingResellerApplicationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PendingResellerApplicationsQuery, PendingResellerApplicationsQueryVariables>(PendingResellerApplicationsDocument, options);
      }
export function usePendingResellerApplicationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PendingResellerApplicationsQuery, PendingResellerApplicationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PendingResellerApplicationsQuery, PendingResellerApplicationsQueryVariables>(PendingResellerApplicationsDocument, options);
        }
export function usePendingResellerApplicationsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PendingResellerApplicationsQuery, PendingResellerApplicationsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PendingResellerApplicationsQuery, PendingResellerApplicationsQueryVariables>(PendingResellerApplicationsDocument, options);
        }
export type PendingResellerApplicationsQueryHookResult = ReturnType<typeof usePendingResellerApplicationsQuery>;
export type PendingResellerApplicationsLazyQueryHookResult = ReturnType<typeof usePendingResellerApplicationsLazyQuery>;
export type PendingResellerApplicationsSuspenseQueryHookResult = ReturnType<typeof usePendingResellerApplicationsSuspenseQuery>;
export type PendingResellerApplicationsQueryResult = Apollo.QueryResult<PendingResellerApplicationsQuery, PendingResellerApplicationsQueryVariables>;
export const ListBillersDocument = gql`
    query ListBillers {
  listBillers {
    id
    email
  }
}
    `;

/**
 * __useListBillersQuery__
 *
 * To run a query within a React component, call `useListBillersQuery` and pass it any options that fit your needs.
 * When your component renders, `useListBillersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListBillersQuery({
 *   variables: {
 *   },
 * });
 */
export function useListBillersQuery(baseOptions?: Apollo.QueryHookOptions<ListBillersQuery, ListBillersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListBillersQuery, ListBillersQueryVariables>(ListBillersDocument, options);
      }
export function useListBillersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListBillersQuery, ListBillersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListBillersQuery, ListBillersQueryVariables>(ListBillersDocument, options);
        }
export function useListBillersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ListBillersQuery, ListBillersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ListBillersQuery, ListBillersQueryVariables>(ListBillersDocument, options);
        }
export type ListBillersQueryHookResult = ReturnType<typeof useListBillersQuery>;
export type ListBillersLazyQueryHookResult = ReturnType<typeof useListBillersLazyQuery>;
export type ListBillersSuspenseQueryHookResult = ReturnType<typeof useListBillersSuspenseQuery>;
export type ListBillersQueryResult = Apollo.QueryResult<ListBillersQuery, ListBillersQueryVariables>;
export const ApproveResellerDocument = gql`
    mutation ApproveReseller($resellerId: String!, $input: ApproveResellerInput!) {
  approveReseller(resellerId: $resellerId, input: $input) {
    userId
    profileStatus
    biller {
      id
      email
    }
  }
}
    `;
export type ApproveResellerMutationFn = Apollo.MutationFunction<ApproveResellerMutation, ApproveResellerMutationVariables>;

/**
 * __useApproveResellerMutation__
 *
 * To run a mutation, you first call `useApproveResellerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveResellerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveResellerMutation, { data, loading, error }] = useApproveResellerMutation({
 *   variables: {
 *      resellerId: // value for 'resellerId'
 *      input: // value for 'input'
 *   },
 * });
 */
export function useApproveResellerMutation(baseOptions?: Apollo.MutationHookOptions<ApproveResellerMutation, ApproveResellerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveResellerMutation, ApproveResellerMutationVariables>(ApproveResellerDocument, options);
      }
export type ApproveResellerMutationHookResult = ReturnType<typeof useApproveResellerMutation>;
export type ApproveResellerMutationResult = Apollo.MutationResult<ApproveResellerMutation>;
export type ApproveResellerMutationOptions = Apollo.BaseMutationOptions<ApproveResellerMutation, ApproveResellerMutationVariables>;
export const ActivateResellerDocument = gql`
    mutation ActivateReseller($resellerId: String!, $billerId: String) {
  activateReseller(resellerId: $resellerId, billerId: $billerId) {
    userId
    profileStatus
    biller {
      id
      email
    }
  }
}
    `;
export type ActivateResellerMutationFn = Apollo.MutationFunction<ActivateResellerMutation, ActivateResellerMutationVariables>;

/**
 * __useActivateResellerMutation__
 *
 * To run a mutation, you first call `useActivateResellerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useActivateResellerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [activateResellerMutation, { data, loading, error }] = useActivateResellerMutation({
 *   variables: {
 *      resellerId: // value for 'resellerId'
 *      billerId: // value for 'billerId'
 *   },
 * });
 */
export function useActivateResellerMutation(baseOptions?: Apollo.MutationHookOptions<ActivateResellerMutation, ActivateResellerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ActivateResellerMutation, ActivateResellerMutationVariables>(ActivateResellerDocument, options);
      }
export type ActivateResellerMutationHookResult = ReturnType<typeof useActivateResellerMutation>;
export type ActivateResellerMutationResult = Apollo.MutationResult<ActivateResellerMutation>;
export type ActivateResellerMutationOptions = Apollo.BaseMutationOptions<ActivateResellerMutation, ActivateResellerMutationVariables>;
export const RejectResellerDocument = gql`
    mutation RejectReseller($resellerId: String!, $reason: String) {
  rejectReseller(resellerId: $resellerId, reason: $reason) {
    userId
    profileStatus
    rejectionReason
  }
}
    `;
export type RejectResellerMutationFn = Apollo.MutationFunction<RejectResellerMutation, RejectResellerMutationVariables>;

/**
 * __useRejectResellerMutation__
 *
 * To run a mutation, you first call `useRejectResellerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRejectResellerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [rejectResellerMutation, { data, loading, error }] = useRejectResellerMutation({
 *   variables: {
 *      resellerId: // value for 'resellerId'
 *      reason: // value for 'reason'
 *   },
 * });
 */
export function useRejectResellerMutation(baseOptions?: Apollo.MutationHookOptions<RejectResellerMutation, RejectResellerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RejectResellerMutation, RejectResellerMutationVariables>(RejectResellerDocument, options);
      }
export type RejectResellerMutationHookResult = ReturnType<typeof useRejectResellerMutation>;
export type RejectResellerMutationResult = Apollo.MutationResult<RejectResellerMutation>;
export type RejectResellerMutationOptions = Apollo.BaseMutationOptions<RejectResellerMutation, RejectResellerMutationVariables>;
export const ResellersDocument = gql`
    query Resellers($status: String, $take: Int, $q: String) {
  resellers(status: $status, take: $take, q: $q) {
    userId
    profileStatus
    tier
    creditLimit
    requestedAt
    user {
      id
      email
    }
    biller {
      id
      email
    }
    requestedBiller {
      id
      email
    }
  }
}
    `;

/**
 * __useResellersQuery__
 *
 * To run a query within a React component, call `useResellersQuery` and pass it any options that fit your needs.
 * When your component renders, `useResellersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useResellersQuery({
 *   variables: {
 *      status: // value for 'status'
 *      take: // value for 'take'
 *      q: // value for 'q'
 *   },
 * });
 */
export function useResellersQuery(baseOptions?: Apollo.QueryHookOptions<ResellersQuery, ResellersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ResellersQuery, ResellersQueryVariables>(ResellersDocument, options);
      }
export function useResellersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ResellersQuery, ResellersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ResellersQuery, ResellersQueryVariables>(ResellersDocument, options);
        }
export function useResellersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ResellersQuery, ResellersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ResellersQuery, ResellersQueryVariables>(ResellersDocument, options);
        }
export type ResellersQueryHookResult = ReturnType<typeof useResellersQuery>;
export type ResellersLazyQueryHookResult = ReturnType<typeof useResellersLazyQuery>;
export type ResellersSuspenseQueryHookResult = ReturnType<typeof useResellersSuspenseQuery>;
export type ResellersQueryResult = Apollo.QueryResult<ResellersQuery, ResellersQueryVariables>;
export const ResellerProfileDocument = gql`
    query ResellerProfile($userId: String!) {
  resellerProfile(userId: $userId) {
    userId
    profileStatus
    tier
    creditLimit
    outstandingBalance
    requestedAt
    activatedAt
    rejectedAt
    rejectionReason
    biller {
      id
      email
    }
    requestedBiller {
      id
      email
    }
    user {
      id
      email
    }
  }
}
    `;

/**
 * __useResellerProfileQuery__
 *
 * To run a query within a React component, call `useResellerProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useResellerProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useResellerProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useResellerProfileQuery(baseOptions: Apollo.QueryHookOptions<ResellerProfileQuery, ResellerProfileQueryVariables> & ({ variables: ResellerProfileQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ResellerProfileQuery, ResellerProfileQueryVariables>(ResellerProfileDocument, options);
      }
export function useResellerProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ResellerProfileQuery, ResellerProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ResellerProfileQuery, ResellerProfileQueryVariables>(ResellerProfileDocument, options);
        }
export function useResellerProfileSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ResellerProfileQuery, ResellerProfileQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ResellerProfileQuery, ResellerProfileQueryVariables>(ResellerProfileDocument, options);
        }
export type ResellerProfileQueryHookResult = ReturnType<typeof useResellerProfileQuery>;
export type ResellerProfileLazyQueryHookResult = ReturnType<typeof useResellerProfileLazyQuery>;
export type ResellerProfileSuspenseQueryHookResult = ReturnType<typeof useResellerProfileSuspenseQuery>;
export type ResellerProfileQueryResult = Apollo.QueryResult<ResellerProfileQuery, ResellerProfileQueryVariables>;
export const ApplyResellerDocument = gql`
    mutation ApplyReseller($input: ApplyResellerInput!) {
  applyReseller(input: $input) {
    userId
    profileStatus
  }
}
    `;
export type ApplyResellerMutationFn = Apollo.MutationFunction<ApplyResellerMutation, ApplyResellerMutationVariables>;

/**
 * __useApplyResellerMutation__
 *
 * To run a mutation, you first call `useApplyResellerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApplyResellerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [applyResellerMutation, { data, loading, error }] = useApplyResellerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useApplyResellerMutation(baseOptions?: Apollo.MutationHookOptions<ApplyResellerMutation, ApplyResellerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApplyResellerMutation, ApplyResellerMutationVariables>(ApplyResellerDocument, options);
      }
export type ApplyResellerMutationHookResult = ReturnType<typeof useApplyResellerMutation>;
export type ApplyResellerMutationResult = Apollo.MutationResult<ApplyResellerMutation>;
export type ApplyResellerMutationOptions = Apollo.BaseMutationOptions<ApplyResellerMutation, ApplyResellerMutationVariables>;
export const SalesReturnsByStoreDocument = gql`
    query SalesReturnsByStore($storeId: String!) {
  salesReturnsByStore(storeId: $storeId) {
    id
    status
    createdAt
    consumerSaleId
    resellerSaleId
  }
}
    `;

/**
 * __useSalesReturnsByStoreQuery__
 *
 * To run a query within a React component, call `useSalesReturnsByStoreQuery` and pass it any options that fit your needs.
 * When your component renders, `useSalesReturnsByStoreQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSalesReturnsByStoreQuery({
 *   variables: {
 *      storeId: // value for 'storeId'
 *   },
 * });
 */
export function useSalesReturnsByStoreQuery(baseOptions: Apollo.QueryHookOptions<SalesReturnsByStoreQuery, SalesReturnsByStoreQueryVariables> & ({ variables: SalesReturnsByStoreQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SalesReturnsByStoreQuery, SalesReturnsByStoreQueryVariables>(SalesReturnsByStoreDocument, options);
      }
export function useSalesReturnsByStoreLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SalesReturnsByStoreQuery, SalesReturnsByStoreQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SalesReturnsByStoreQuery, SalesReturnsByStoreQueryVariables>(SalesReturnsByStoreDocument, options);
        }
export function useSalesReturnsByStoreSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SalesReturnsByStoreQuery, SalesReturnsByStoreQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SalesReturnsByStoreQuery, SalesReturnsByStoreQueryVariables>(SalesReturnsByStoreDocument, options);
        }
export type SalesReturnsByStoreQueryHookResult = ReturnType<typeof useSalesReturnsByStoreQuery>;
export type SalesReturnsByStoreLazyQueryHookResult = ReturnType<typeof useSalesReturnsByStoreLazyQuery>;
export type SalesReturnsByStoreSuspenseQueryHookResult = ReturnType<typeof useSalesReturnsByStoreSuspenseQuery>;
export type SalesReturnsByStoreQueryResult = Apollo.QueryResult<SalesReturnsByStoreQuery, SalesReturnsByStoreQueryVariables>;
export const PurchaseReturnsBySupplierDocument = gql`
    query PurchaseReturnsBySupplier($supplierId: String!) {
  purchaseReturnsBySupplier(supplierId: $supplierId) {
    id
    status
    createdAt
    supplierId
  }
}
    `;

/**
 * __usePurchaseReturnsBySupplierQuery__
 *
 * To run a query within a React component, call `usePurchaseReturnsBySupplierQuery` and pass it any options that fit your needs.
 * When your component renders, `usePurchaseReturnsBySupplierQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePurchaseReturnsBySupplierQuery({
 *   variables: {
 *      supplierId: // value for 'supplierId'
 *   },
 * });
 */
export function usePurchaseReturnsBySupplierQuery(baseOptions: Apollo.QueryHookOptions<PurchaseReturnsBySupplierQuery, PurchaseReturnsBySupplierQueryVariables> & ({ variables: PurchaseReturnsBySupplierQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PurchaseReturnsBySupplierQuery, PurchaseReturnsBySupplierQueryVariables>(PurchaseReturnsBySupplierDocument, options);
      }
export function usePurchaseReturnsBySupplierLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PurchaseReturnsBySupplierQuery, PurchaseReturnsBySupplierQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PurchaseReturnsBySupplierQuery, PurchaseReturnsBySupplierQueryVariables>(PurchaseReturnsBySupplierDocument, options);
        }
export function usePurchaseReturnsBySupplierSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<PurchaseReturnsBySupplierQuery, PurchaseReturnsBySupplierQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PurchaseReturnsBySupplierQuery, PurchaseReturnsBySupplierQueryVariables>(PurchaseReturnsBySupplierDocument, options);
        }
export type PurchaseReturnsBySupplierQueryHookResult = ReturnType<typeof usePurchaseReturnsBySupplierQuery>;
export type PurchaseReturnsBySupplierLazyQueryHookResult = ReturnType<typeof usePurchaseReturnsBySupplierLazyQuery>;
export type PurchaseReturnsBySupplierSuspenseQueryHookResult = ReturnType<typeof usePurchaseReturnsBySupplierSuspenseQuery>;
export type PurchaseReturnsBySupplierQueryResult = Apollo.QueryResult<PurchaseReturnsBySupplierQuery, PurchaseReturnsBySupplierQueryVariables>;
export const UpdateSalesReturnStatusDocument = gql`
    mutation UpdateSalesReturnStatus($input: UpdateSalesReturnStatusInput!) {
  updateSalesReturnStatus(input: $input)
}
    `;
export type UpdateSalesReturnStatusMutationFn = Apollo.MutationFunction<UpdateSalesReturnStatusMutation, UpdateSalesReturnStatusMutationVariables>;

/**
 * __useUpdateSalesReturnStatusMutation__
 *
 * To run a mutation, you first call `useUpdateSalesReturnStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSalesReturnStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSalesReturnStatusMutation, { data, loading, error }] = useUpdateSalesReturnStatusMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateSalesReturnStatusMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSalesReturnStatusMutation, UpdateSalesReturnStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSalesReturnStatusMutation, UpdateSalesReturnStatusMutationVariables>(UpdateSalesReturnStatusDocument, options);
      }
export type UpdateSalesReturnStatusMutationHookResult = ReturnType<typeof useUpdateSalesReturnStatusMutation>;
export type UpdateSalesReturnStatusMutationResult = Apollo.MutationResult<UpdateSalesReturnStatusMutation>;
export type UpdateSalesReturnStatusMutationOptions = Apollo.BaseMutationOptions<UpdateSalesReturnStatusMutation, UpdateSalesReturnStatusMutationVariables>;
export const FulfillPurchaseReturnDocument = gql`
    mutation FulfillPurchaseReturn($input: FulfillPurchaseReturnInput!) {
  fulfillPurchaseReturn(input: $input)
}
    `;
export type FulfillPurchaseReturnMutationFn = Apollo.MutationFunction<FulfillPurchaseReturnMutation, FulfillPurchaseReturnMutationVariables>;

/**
 * __useFulfillPurchaseReturnMutation__
 *
 * To run a mutation, you first call `useFulfillPurchaseReturnMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFulfillPurchaseReturnMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [fulfillPurchaseReturnMutation, { data, loading, error }] = useFulfillPurchaseReturnMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useFulfillPurchaseReturnMutation(baseOptions?: Apollo.MutationHookOptions<FulfillPurchaseReturnMutation, FulfillPurchaseReturnMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FulfillPurchaseReturnMutation, FulfillPurchaseReturnMutationVariables>(FulfillPurchaseReturnDocument, options);
      }
export type FulfillPurchaseReturnMutationHookResult = ReturnType<typeof useFulfillPurchaseReturnMutation>;
export type FulfillPurchaseReturnMutationResult = Apollo.MutationResult<FulfillPurchaseReturnMutation>;
export type FulfillPurchaseReturnMutationOptions = Apollo.BaseMutationOptions<FulfillPurchaseReturnMutation, FulfillPurchaseReturnMutationVariables>;
export const CreateStaffDocument = gql`
    mutation CreateStaff($input: CreateStaffInput!) {
  createStaff(input: $input) {
    id
    email
  }
}
    `;
export type CreateStaffMutationFn = Apollo.MutationFunction<CreateStaffMutation, CreateStaffMutationVariables>;

/**
 * __useCreateStaffMutation__
 *
 * To run a mutation, you first call `useCreateStaffMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateStaffMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createStaffMutation, { data, loading, error }] = useCreateStaffMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateStaffMutation(baseOptions?: Apollo.MutationHookOptions<CreateStaffMutation, CreateStaffMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateStaffMutation, CreateStaffMutationVariables>(CreateStaffDocument, options);
      }
export type CreateStaffMutationHookResult = ReturnType<typeof useCreateStaffMutation>;
export type CreateStaffMutationResult = Apollo.MutationResult<CreateStaffMutation>;
export type CreateStaffMutationOptions = Apollo.BaseMutationOptions<CreateStaffMutation, CreateStaffMutationVariables>;
export const AssignBillerDocument = gql`
    mutation AssignBiller($input: AssignBillerInput!) {
  assignBiller(input: $input) {
    userId
    billerId
  }
}
    `;
export type AssignBillerMutationFn = Apollo.MutationFunction<AssignBillerMutation, AssignBillerMutationVariables>;

/**
 * __useAssignBillerMutation__
 *
 * To run a mutation, you first call `useAssignBillerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAssignBillerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [assignBillerMutation, { data, loading, error }] = useAssignBillerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAssignBillerMutation(baseOptions?: Apollo.MutationHookOptions<AssignBillerMutation, AssignBillerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AssignBillerMutation, AssignBillerMutationVariables>(AssignBillerDocument, options);
      }
export type AssignBillerMutationHookResult = ReturnType<typeof useAssignBillerMutation>;
export type AssignBillerMutationResult = Apollo.MutationResult<AssignBillerMutation>;
export type AssignBillerMutationOptions = Apollo.BaseMutationOptions<AssignBillerMutation, AssignBillerMutationVariables>;
export const StaffDetailDocument = gql`
    query StaffDetail($id: String!) {
  findUniqueUser(where: {id: $id}) {
    id
    email
    createdAt
    updatedAt
    isEmailVerified
    role {
      name
    }
    Store {
      id
      name
      isMain
      location
    }
    Notification {
      id
      type
      message
      isRead
      createdAt
    }
  }
}
    `;

/**
 * __useStaffDetailQuery__
 *
 * To run a query within a React component, call `useStaffDetailQuery` and pass it any options that fit your needs.
 * When your component renders, `useStaffDetailQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStaffDetailQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useStaffDetailQuery(baseOptions: Apollo.QueryHookOptions<StaffDetailQuery, StaffDetailQueryVariables> & ({ variables: StaffDetailQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StaffDetailQuery, StaffDetailQueryVariables>(StaffDetailDocument, options);
      }
export function useStaffDetailLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StaffDetailQuery, StaffDetailQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StaffDetailQuery, StaffDetailQueryVariables>(StaffDetailDocument, options);
        }
export function useStaffDetailSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StaffDetailQuery, StaffDetailQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StaffDetailQuery, StaffDetailQueryVariables>(StaffDetailDocument, options);
        }
export type StaffDetailQueryHookResult = ReturnType<typeof useStaffDetailQuery>;
export type StaffDetailLazyQueryHookResult = ReturnType<typeof useStaffDetailLazyQuery>;
export type StaffDetailSuspenseQueryHookResult = ReturnType<typeof useStaffDetailSuspenseQuery>;
export type StaffDetailQueryResult = Apollo.QueryResult<StaffDetailQuery, StaffDetailQueryVariables>;
export const SendUserEmailVerificationDocument = gql`
    mutation SendUserEmailVerification($userId: String!) {
  sendUserEmailVerification(userId: $userId)
}
    `;
export type SendUserEmailVerificationMutationFn = Apollo.MutationFunction<SendUserEmailVerificationMutation, SendUserEmailVerificationMutationVariables>;

/**
 * __useSendUserEmailVerificationMutation__
 *
 * To run a mutation, you first call `useSendUserEmailVerificationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendUserEmailVerificationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendUserEmailVerificationMutation, { data, loading, error }] = useSendUserEmailVerificationMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSendUserEmailVerificationMutation(baseOptions?: Apollo.MutationHookOptions<SendUserEmailVerificationMutation, SendUserEmailVerificationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendUserEmailVerificationMutation, SendUserEmailVerificationMutationVariables>(SendUserEmailVerificationDocument, options);
      }
export type SendUserEmailVerificationMutationHookResult = ReturnType<typeof useSendUserEmailVerificationMutation>;
export type SendUserEmailVerificationMutationResult = Apollo.MutationResult<SendUserEmailVerificationMutation>;
export type SendUserEmailVerificationMutationOptions = Apollo.BaseMutationOptions<SendUserEmailVerificationMutation, SendUserEmailVerificationMutationVariables>;
export const StockDocument = gql`
    query Stock($input: QueryStockInput) {
  stock(input: $input) {
    id
    productVariantId
    storeId
    quantity
    reserved
    productVariant {
      id
      name
      barcode
      product {
        id
        name
      }
    }
    store {
      id
      name
    }
  }
}
    `;

/**
 * __useStockQuery__
 *
 * To run a query within a React component, call `useStockQuery` and pass it any options that fit your needs.
 * When your component renders, `useStockQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStockQuery({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useStockQuery(baseOptions?: Apollo.QueryHookOptions<StockQuery, StockQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StockQuery, StockQueryVariables>(StockDocument, options);
      }
export function useStockLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StockQuery, StockQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StockQuery, StockQueryVariables>(StockDocument, options);
        }
export function useStockSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StockQuery, StockQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StockQuery, StockQueryVariables>(StockDocument, options);
        }
export type StockQueryHookResult = ReturnType<typeof useStockQuery>;
export type StockLazyQueryHookResult = ReturnType<typeof useStockLazyQuery>;
export type StockSuspenseQueryHookResult = ReturnType<typeof useStockSuspenseQuery>;
export type StockQueryResult = Apollo.QueryResult<StockQuery, StockQueryVariables>;
export const StoresDocument = gql`
    query Stores($take: Int, $where: StoreWhereInput) {
  listStores(take: $take, where: $where) {
    id
    name
    location
    isMain
    manager {
      id
      email
    }
  }
}
    `;

/**
 * __useStoresQuery__
 *
 * To run a query within a React component, call `useStoresQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoresQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoresQuery({
 *   variables: {
 *      take: // value for 'take'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useStoresQuery(baseOptions?: Apollo.QueryHookOptions<StoresQuery, StoresQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoresQuery, StoresQueryVariables>(StoresDocument, options);
      }
export function useStoresLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoresQuery, StoresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoresQuery, StoresQueryVariables>(StoresDocument, options);
        }
export function useStoresSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StoresQuery, StoresQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StoresQuery, StoresQueryVariables>(StoresDocument, options);
        }
export type StoresQueryHookResult = ReturnType<typeof useStoresQuery>;
export type StoresLazyQueryHookResult = ReturnType<typeof useStoresLazyQuery>;
export type StoresSuspenseQueryHookResult = ReturnType<typeof useStoresSuspenseQuery>;
export type StoresQueryResult = Apollo.QueryResult<StoresQuery, StoresQueryVariables>;
export const StoresWithInvalidManagersDocument = gql`
    query StoresWithInvalidManagers {
  storesWithInvalidManagers {
    id
    name
    managerId
    managerEmail
    validManager
  }
}
    `;

/**
 * __useStoresWithInvalidManagersQuery__
 *
 * To run a query within a React component, call `useStoresWithInvalidManagersQuery` and pass it any options that fit your needs.
 * When your component renders, `useStoresWithInvalidManagersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStoresWithInvalidManagersQuery({
 *   variables: {
 *   },
 * });
 */
export function useStoresWithInvalidManagersQuery(baseOptions?: Apollo.QueryHookOptions<StoresWithInvalidManagersQuery, StoresWithInvalidManagersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StoresWithInvalidManagersQuery, StoresWithInvalidManagersQueryVariables>(StoresWithInvalidManagersDocument, options);
      }
export function useStoresWithInvalidManagersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StoresWithInvalidManagersQuery, StoresWithInvalidManagersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StoresWithInvalidManagersQuery, StoresWithInvalidManagersQueryVariables>(StoresWithInvalidManagersDocument, options);
        }
export function useStoresWithInvalidManagersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<StoresWithInvalidManagersQuery, StoresWithInvalidManagersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StoresWithInvalidManagersQuery, StoresWithInvalidManagersQueryVariables>(StoresWithInvalidManagersDocument, options);
        }
export type StoresWithInvalidManagersQueryHookResult = ReturnType<typeof useStoresWithInvalidManagersQuery>;
export type StoresWithInvalidManagersLazyQueryHookResult = ReturnType<typeof useStoresWithInvalidManagersLazyQuery>;
export type StoresWithInvalidManagersSuspenseQueryHookResult = ReturnType<typeof useStoresWithInvalidManagersSuspenseQuery>;
export type StoresWithInvalidManagersQueryResult = Apollo.QueryResult<StoresWithInvalidManagersQuery, StoresWithInvalidManagersQueryVariables>;
export const ListManagersDocument = gql`
    query ListManagers {
  listManagers {
    id
    email
    customerProfile {
      fullName
    }
  }
}
    `;

/**
 * __useListManagersQuery__
 *
 * To run a query within a React component, call `useListManagersQuery` and pass it any options that fit your needs.
 * When your component renders, `useListManagersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListManagersQuery({
 *   variables: {
 *   },
 * });
 */
export function useListManagersQuery(baseOptions?: Apollo.QueryHookOptions<ListManagersQuery, ListManagersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListManagersQuery, ListManagersQueryVariables>(ListManagersDocument, options);
      }
export function useListManagersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListManagersQuery, ListManagersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListManagersQuery, ListManagersQueryVariables>(ListManagersDocument, options);
        }
export function useListManagersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ListManagersQuery, ListManagersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ListManagersQuery, ListManagersQueryVariables>(ListManagersDocument, options);
        }
export type ListManagersQueryHookResult = ReturnType<typeof useListManagersQuery>;
export type ListManagersLazyQueryHookResult = ReturnType<typeof useListManagersLazyQuery>;
export type ListManagersSuspenseQueryHookResult = ReturnType<typeof useListManagersSuspenseQuery>;
export type ListManagersQueryResult = Apollo.QueryResult<ListManagersQuery, ListManagersQueryVariables>;
export const AssignStoreManagerDocument = gql`
    mutation AssignStoreManager($storeId: String!, $managerId: String!) {
  assignStoreManager(storeId: $storeId, managerId: $managerId)
}
    `;
export type AssignStoreManagerMutationFn = Apollo.MutationFunction<AssignStoreManagerMutation, AssignStoreManagerMutationVariables>;

/**
 * __useAssignStoreManagerMutation__
 *
 * To run a mutation, you first call `useAssignStoreManagerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAssignStoreManagerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [assignStoreManagerMutation, { data, loading, error }] = useAssignStoreManagerMutation({
 *   variables: {
 *      storeId: // value for 'storeId'
 *      managerId: // value for 'managerId'
 *   },
 * });
 */
export function useAssignStoreManagerMutation(baseOptions?: Apollo.MutationHookOptions<AssignStoreManagerMutation, AssignStoreManagerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AssignStoreManagerMutation, AssignStoreManagerMutationVariables>(AssignStoreManagerDocument, options);
      }
export type AssignStoreManagerMutationHookResult = ReturnType<typeof useAssignStoreManagerMutation>;
export type AssignStoreManagerMutationResult = Apollo.MutationResult<AssignStoreManagerMutation>;
export type AssignStoreManagerMutationOptions = Apollo.BaseMutationOptions<AssignStoreManagerMutation, AssignStoreManagerMutationVariables>;
export const BulkAssignStoreManagerDocument = gql`
    mutation BulkAssignStoreManager($storeIds: [String!]!, $managerId: String!) {
  bulkAssignStoreManager(storeIds: $storeIds, managerId: $managerId)
}
    `;
export type BulkAssignStoreManagerMutationFn = Apollo.MutationFunction<BulkAssignStoreManagerMutation, BulkAssignStoreManagerMutationVariables>;

/**
 * __useBulkAssignStoreManagerMutation__
 *
 * To run a mutation, you first call `useBulkAssignStoreManagerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBulkAssignStoreManagerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [bulkAssignStoreManagerMutation, { data, loading, error }] = useBulkAssignStoreManagerMutation({
 *   variables: {
 *      storeIds: // value for 'storeIds'
 *      managerId: // value for 'managerId'
 *   },
 * });
 */
export function useBulkAssignStoreManagerMutation(baseOptions?: Apollo.MutationHookOptions<BulkAssignStoreManagerMutation, BulkAssignStoreManagerMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BulkAssignStoreManagerMutation, BulkAssignStoreManagerMutationVariables>(BulkAssignStoreManagerDocument, options);
      }
export type BulkAssignStoreManagerMutationHookResult = ReturnType<typeof useBulkAssignStoreManagerMutation>;
export type BulkAssignStoreManagerMutationResult = Apollo.MutationResult<BulkAssignStoreManagerMutation>;
export type BulkAssignStoreManagerMutationOptions = Apollo.BaseMutationOptions<BulkAssignStoreManagerMutation, BulkAssignStoreManagerMutationVariables>;
export const SupplierPaymentsByPoDocument = gql`
    query SupplierPaymentsByPO($purchaseOrderId: String!) {
  supplierPaymentsByPO(purchaseOrderId: $purchaseOrderId) {
    id
    amount
    paymentDate
    method
    notes
  }
  purchaseOrder(id: $purchaseOrderId) {
    id
    totalAmount
    supplier {
      id
      name
    }
    createdAt
  }
}
    `;

/**
 * __useSupplierPaymentsByPoQuery__
 *
 * To run a query within a React component, call `useSupplierPaymentsByPoQuery` and pass it any options that fit your needs.
 * When your component renders, `useSupplierPaymentsByPoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSupplierPaymentsByPoQuery({
 *   variables: {
 *      purchaseOrderId: // value for 'purchaseOrderId'
 *   },
 * });
 */
export function useSupplierPaymentsByPoQuery(baseOptions: Apollo.QueryHookOptions<SupplierPaymentsByPoQuery, SupplierPaymentsByPoQueryVariables> & ({ variables: SupplierPaymentsByPoQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SupplierPaymentsByPoQuery, SupplierPaymentsByPoQueryVariables>(SupplierPaymentsByPoDocument, options);
      }
export function useSupplierPaymentsByPoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SupplierPaymentsByPoQuery, SupplierPaymentsByPoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SupplierPaymentsByPoQuery, SupplierPaymentsByPoQueryVariables>(SupplierPaymentsByPoDocument, options);
        }
export function useSupplierPaymentsByPoSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SupplierPaymentsByPoQuery, SupplierPaymentsByPoQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SupplierPaymentsByPoQuery, SupplierPaymentsByPoQueryVariables>(SupplierPaymentsByPoDocument, options);
        }
export type SupplierPaymentsByPoQueryHookResult = ReturnType<typeof useSupplierPaymentsByPoQuery>;
export type SupplierPaymentsByPoLazyQueryHookResult = ReturnType<typeof useSupplierPaymentsByPoLazyQuery>;
export type SupplierPaymentsByPoSuspenseQueryHookResult = ReturnType<typeof useSupplierPaymentsByPoSuspenseQuery>;
export type SupplierPaymentsByPoQueryResult = Apollo.QueryResult<SupplierPaymentsByPoQuery, SupplierPaymentsByPoQueryVariables>;
export const CreateSupplierPaymentDocument = gql`
    mutation CreateSupplierPayment($input: CreateSupplierPaymentInput!) {
  createSupplierPayment(input: $input) {
    id
    amount
    paymentDate
    method
  }
}
    `;
export type CreateSupplierPaymentMutationFn = Apollo.MutationFunction<CreateSupplierPaymentMutation, CreateSupplierPaymentMutationVariables>;

/**
 * __useCreateSupplierPaymentMutation__
 *
 * To run a mutation, you first call `useCreateSupplierPaymentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSupplierPaymentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSupplierPaymentMutation, { data, loading, error }] = useCreateSupplierPaymentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateSupplierPaymentMutation(baseOptions?: Apollo.MutationHookOptions<CreateSupplierPaymentMutation, CreateSupplierPaymentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSupplierPaymentMutation, CreateSupplierPaymentMutationVariables>(CreateSupplierPaymentDocument, options);
      }
export type CreateSupplierPaymentMutationHookResult = ReturnType<typeof useCreateSupplierPaymentMutation>;
export type CreateSupplierPaymentMutationResult = Apollo.MutationResult<CreateSupplierPaymentMutation>;
export type CreateSupplierPaymentMutationOptions = Apollo.BaseMutationOptions<CreateSupplierPaymentMutation, CreateSupplierPaymentMutationVariables>;
export const SupplierStatementDataDocument = gql`
    query SupplierStatementData($supplierId: String!) {
  purchaseOrdersBySupplier(supplierId: $supplierId) {
    id
    totalAmount
    createdAt
  }
  supplierPaymentsBySupplier(supplierId: $supplierId) {
    id
    amount
    paymentDate
    method
  }
}
    `;

/**
 * __useSupplierStatementDataQuery__
 *
 * To run a query within a React component, call `useSupplierStatementDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSupplierStatementDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSupplierStatementDataQuery({
 *   variables: {
 *      supplierId: // value for 'supplierId'
 *   },
 * });
 */
export function useSupplierStatementDataQuery(baseOptions: Apollo.QueryHookOptions<SupplierStatementDataQuery, SupplierStatementDataQueryVariables> & ({ variables: SupplierStatementDataQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SupplierStatementDataQuery, SupplierStatementDataQueryVariables>(SupplierStatementDataDocument, options);
      }
export function useSupplierStatementDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SupplierStatementDataQuery, SupplierStatementDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SupplierStatementDataQuery, SupplierStatementDataQueryVariables>(SupplierStatementDataDocument, options);
        }
export function useSupplierStatementDataSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SupplierStatementDataQuery, SupplierStatementDataQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SupplierStatementDataQuery, SupplierStatementDataQueryVariables>(SupplierStatementDataDocument, options);
        }
export type SupplierStatementDataQueryHookResult = ReturnType<typeof useSupplierStatementDataQuery>;
export type SupplierStatementDataLazyQueryHookResult = ReturnType<typeof useSupplierStatementDataLazyQuery>;
export type SupplierStatementDataSuspenseQueryHookResult = ReturnType<typeof useSupplierStatementDataSuspenseQuery>;
export type SupplierStatementDataQueryResult = Apollo.QueryResult<SupplierStatementDataQuery, SupplierStatementDataQueryVariables>;
export const SupplierAgingDataDocument = gql`
    query SupplierAgingData($supplierId: String!) {
  purchaseOrdersBySupplier(supplierId: $supplierId) {
    id
    totalAmount
    createdAt
    dueDate
    payments {
      id
      amount
    }
  }
}
    `;

/**
 * __useSupplierAgingDataQuery__
 *
 * To run a query within a React component, call `useSupplierAgingDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSupplierAgingDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSupplierAgingDataQuery({
 *   variables: {
 *      supplierId: // value for 'supplierId'
 *   },
 * });
 */
export function useSupplierAgingDataQuery(baseOptions: Apollo.QueryHookOptions<SupplierAgingDataQuery, SupplierAgingDataQueryVariables> & ({ variables: SupplierAgingDataQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SupplierAgingDataQuery, SupplierAgingDataQueryVariables>(SupplierAgingDataDocument, options);
      }
export function useSupplierAgingDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SupplierAgingDataQuery, SupplierAgingDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SupplierAgingDataQuery, SupplierAgingDataQueryVariables>(SupplierAgingDataDocument, options);
        }
export function useSupplierAgingDataSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SupplierAgingDataQuery, SupplierAgingDataQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SupplierAgingDataQuery, SupplierAgingDataQueryVariables>(SupplierAgingDataDocument, options);
        }
export type SupplierAgingDataQueryHookResult = ReturnType<typeof useSupplierAgingDataQuery>;
export type SupplierAgingDataLazyQueryHookResult = ReturnType<typeof useSupplierAgingDataLazyQuery>;
export type SupplierAgingDataSuspenseQueryHookResult = ReturnType<typeof useSupplierAgingDataSuspenseQuery>;
export type SupplierAgingDataQueryResult = Apollo.QueryResult<SupplierAgingDataQuery, SupplierAgingDataQueryVariables>;
export const SuppliersDocument = gql`
    query Suppliers($take: Int, $skip: Int) {
  listSuppliers(take: $take, skip: $skip) {
    id
    name
    creditLimit
    currentBalance
    createdAt
  }
}
    `;

/**
 * __useSuppliersQuery__
 *
 * To run a query within a React component, call `useSuppliersQuery` and pass it any options that fit your needs.
 * When your component renders, `useSuppliersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSuppliersQuery({
 *   variables: {
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *   },
 * });
 */
export function useSuppliersQuery(baseOptions?: Apollo.QueryHookOptions<SuppliersQuery, SuppliersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SuppliersQuery, SuppliersQueryVariables>(SuppliersDocument, options);
      }
export function useSuppliersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SuppliersQuery, SuppliersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SuppliersQuery, SuppliersQueryVariables>(SuppliersDocument, options);
        }
export function useSuppliersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SuppliersQuery, SuppliersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SuppliersQuery, SuppliersQueryVariables>(SuppliersDocument, options);
        }
export type SuppliersQueryHookResult = ReturnType<typeof useSuppliersQuery>;
export type SuppliersLazyQueryHookResult = ReturnType<typeof useSuppliersLazyQuery>;
export type SuppliersSuspenseQueryHookResult = ReturnType<typeof useSuppliersSuspenseQuery>;
export type SuppliersQueryResult = Apollo.QueryResult<SuppliersQuery, SuppliersQueryVariables>;
export const MySupportMessagesDocument = gql`
    query MySupportMessages {
  mySupportMessages {
    id
    message
    createdAt
    isAdmin
  }
}
    `;

/**
 * __useMySupportMessagesQuery__
 *
 * To run a query within a React component, call `useMySupportMessagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useMySupportMessagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMySupportMessagesQuery({
 *   variables: {
 *   },
 * });
 */
export function useMySupportMessagesQuery(baseOptions?: Apollo.QueryHookOptions<MySupportMessagesQuery, MySupportMessagesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MySupportMessagesQuery, MySupportMessagesQueryVariables>(MySupportMessagesDocument, options);
      }
export function useMySupportMessagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MySupportMessagesQuery, MySupportMessagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MySupportMessagesQuery, MySupportMessagesQueryVariables>(MySupportMessagesDocument, options);
        }
export function useMySupportMessagesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MySupportMessagesQuery, MySupportMessagesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MySupportMessagesQuery, MySupportMessagesQueryVariables>(MySupportMessagesDocument, options);
        }
export type MySupportMessagesQueryHookResult = ReturnType<typeof useMySupportMessagesQuery>;
export type MySupportMessagesLazyQueryHookResult = ReturnType<typeof useMySupportMessagesLazyQuery>;
export type MySupportMessagesSuspenseQueryHookResult = ReturnType<typeof useMySupportMessagesSuspenseQuery>;
export type MySupportMessagesQueryResult = Apollo.QueryResult<MySupportMessagesQuery, MySupportMessagesQueryVariables>;
export const RecentSupportThreadsDocument = gql`
    query RecentSupportThreads($limit: Int) {
  recentSupportThreads(limit: $limit) {
    id
    userId
    message
    createdAt
    isAdmin
  }
}
    `;

/**
 * __useRecentSupportThreadsQuery__
 *
 * To run a query within a React component, call `useRecentSupportThreadsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRecentSupportThreadsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRecentSupportThreadsQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *   },
 * });
 */
export function useRecentSupportThreadsQuery(baseOptions?: Apollo.QueryHookOptions<RecentSupportThreadsQuery, RecentSupportThreadsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RecentSupportThreadsQuery, RecentSupportThreadsQueryVariables>(RecentSupportThreadsDocument, options);
      }
export function useRecentSupportThreadsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RecentSupportThreadsQuery, RecentSupportThreadsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RecentSupportThreadsQuery, RecentSupportThreadsQueryVariables>(RecentSupportThreadsDocument, options);
        }
export function useRecentSupportThreadsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<RecentSupportThreadsQuery, RecentSupportThreadsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RecentSupportThreadsQuery, RecentSupportThreadsQueryVariables>(RecentSupportThreadsDocument, options);
        }
export type RecentSupportThreadsQueryHookResult = ReturnType<typeof useRecentSupportThreadsQuery>;
export type RecentSupportThreadsLazyQueryHookResult = ReturnType<typeof useRecentSupportThreadsLazyQuery>;
export type RecentSupportThreadsSuspenseQueryHookResult = ReturnType<typeof useRecentSupportThreadsSuspenseQuery>;
export type RecentSupportThreadsQueryResult = Apollo.QueryResult<RecentSupportThreadsQuery, RecentSupportThreadsQueryVariables>;
export const SupportConversationDocument = gql`
    query SupportConversation($userId: String!) {
  supportConversation(userId: $userId) {
    id
    message
    createdAt
    isAdmin
  }
}
    `;

/**
 * __useSupportConversationQuery__
 *
 * To run a query within a React component, call `useSupportConversationQuery` and pass it any options that fit your needs.
 * When your component renders, `useSupportConversationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSupportConversationQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSupportConversationQuery(baseOptions: Apollo.QueryHookOptions<SupportConversationQuery, SupportConversationQueryVariables> & ({ variables: SupportConversationQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SupportConversationQuery, SupportConversationQueryVariables>(SupportConversationDocument, options);
      }
export function useSupportConversationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SupportConversationQuery, SupportConversationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SupportConversationQuery, SupportConversationQueryVariables>(SupportConversationDocument, options);
        }
export function useSupportConversationSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SupportConversationQuery, SupportConversationQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SupportConversationQuery, SupportConversationQueryVariables>(SupportConversationDocument, options);
        }
export type SupportConversationQueryHookResult = ReturnType<typeof useSupportConversationQuery>;
export type SupportConversationLazyQueryHookResult = ReturnType<typeof useSupportConversationLazyQuery>;
export type SupportConversationSuspenseQueryHookResult = ReturnType<typeof useSupportConversationSuspenseQuery>;
export type SupportConversationQueryResult = Apollo.QueryResult<SupportConversationQuery, SupportConversationQueryVariables>;
export const SendSupportMessageDocument = gql`
    mutation SendSupportMessage($message: String!) {
  sendSupportMessage(input: {message: $message}) {
    id
    message
    createdAt
    isAdmin
  }
}
    `;
export type SendSupportMessageMutationFn = Apollo.MutationFunction<SendSupportMessageMutation, SendSupportMessageMutationVariables>;

/**
 * __useSendSupportMessageMutation__
 *
 * To run a mutation, you first call `useSendSupportMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendSupportMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendSupportMessageMutation, { data, loading, error }] = useSendSupportMessageMutation({
 *   variables: {
 *      message: // value for 'message'
 *   },
 * });
 */
export function useSendSupportMessageMutation(baseOptions?: Apollo.MutationHookOptions<SendSupportMessageMutation, SendSupportMessageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendSupportMessageMutation, SendSupportMessageMutationVariables>(SendSupportMessageDocument, options);
      }
export type SendSupportMessageMutationHookResult = ReturnType<typeof useSendSupportMessageMutation>;
export type SendSupportMessageMutationResult = Apollo.MutationResult<SendSupportMessageMutation>;
export type SendSupportMessageMutationOptions = Apollo.BaseMutationOptions<SendSupportMessageMutation, SendSupportMessageMutationVariables>;
export const AdminSendSupportMessageDocument = gql`
    mutation AdminSendSupportMessage($userId: String!, $message: String!) {
  adminSendSupportMessage(input: {userId: $userId, message: $message}) {
    id
    message
    createdAt
    isAdmin
  }
}
    `;
export type AdminSendSupportMessageMutationFn = Apollo.MutationFunction<AdminSendSupportMessageMutation, AdminSendSupportMessageMutationVariables>;

/**
 * __useAdminSendSupportMessageMutation__
 *
 * To run a mutation, you first call `useAdminSendSupportMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAdminSendSupportMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [adminSendSupportMessageMutation, { data, loading, error }] = useAdminSendSupportMessageMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      message: // value for 'message'
 *   },
 * });
 */
export function useAdminSendSupportMessageMutation(baseOptions?: Apollo.MutationHookOptions<AdminSendSupportMessageMutation, AdminSendSupportMessageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AdminSendSupportMessageMutation, AdminSendSupportMessageMutationVariables>(AdminSendSupportMessageDocument, options);
      }
export type AdminSendSupportMessageMutationHookResult = ReturnType<typeof useAdminSendSupportMessageMutation>;
export type AdminSendSupportMessageMutationResult = Apollo.MutationResult<AdminSendSupportMessageMutation>;
export type AdminSendSupportMessageMutationOptions = Apollo.BaseMutationOptions<AdminSendSupportMessageMutation, AdminSendSupportMessageMutationVariables>;
export const UsersDocument = gql`
    query Users($take: Int) {
  listUsers(take: $take) {
    id
    email
    createdAt
    isEmailVerified
    role {
      name
    }
    customerProfile {
      fullName
    }
    resellerProfile {
      tier
    }
  }
}
    `;

/**
 * __useUsersQuery__
 *
 * To run a query within a React component, call `useUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsersQuery({
 *   variables: {
 *      take: // value for 'take'
 *   },
 * });
 */
export function useUsersQuery(baseOptions?: Apollo.QueryHookOptions<UsersQuery, UsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
      }
export function useUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export function useUsersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export type UsersQueryHookResult = ReturnType<typeof useUsersQuery>;
export type UsersLazyQueryHookResult = ReturnType<typeof useUsersLazyQuery>;
export type UsersSuspenseQueryHookResult = ReturnType<typeof useUsersSuspenseQuery>;
export type UsersQueryResult = Apollo.QueryResult<UsersQuery, UsersQueryVariables>;
export const ListFacetsDocument = gql`
    query ListFacets {
  listFacets {
    id
    name
    code
    values
    isPrivate
  }
}
    `;

/**
 * __useListFacetsQuery__
 *
 * To run a query within a React component, call `useListFacetsQuery` and pass it any options that fit your needs.
 * When your component renders, `useListFacetsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListFacetsQuery({
 *   variables: {
 *   },
 * });
 */
export function useListFacetsQuery(baseOptions?: Apollo.QueryHookOptions<ListFacetsQuery, ListFacetsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListFacetsQuery, ListFacetsQueryVariables>(ListFacetsDocument, options);
      }
export function useListFacetsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListFacetsQuery, ListFacetsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListFacetsQuery, ListFacetsQueryVariables>(ListFacetsDocument, options);
        }
export function useListFacetsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ListFacetsQuery, ListFacetsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ListFacetsQuery, ListFacetsQueryVariables>(ListFacetsDocument, options);
        }
export type ListFacetsQueryHookResult = ReturnType<typeof useListFacetsQuery>;
export type ListFacetsLazyQueryHookResult = ReturnType<typeof useListFacetsLazyQuery>;
export type ListFacetsSuspenseQueryHookResult = ReturnType<typeof useListFacetsSuspenseQuery>;
export type ListFacetsQueryResult = Apollo.QueryResult<ListFacetsQuery, ListFacetsQueryVariables>;
export const ListFacetsAllDocument = gql`
    query ListFacetsAll {
  listFacets {
    id
    name
    code
    values
    isPrivate
  }
}
    `;

/**
 * __useListFacetsAllQuery__
 *
 * To run a query within a React component, call `useListFacetsAllQuery` and pass it any options that fit your needs.
 * When your component renders, `useListFacetsAllQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useListFacetsAllQuery({
 *   variables: {
 *   },
 * });
 */
export function useListFacetsAllQuery(baseOptions?: Apollo.QueryHookOptions<ListFacetsAllQuery, ListFacetsAllQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ListFacetsAllQuery, ListFacetsAllQueryVariables>(ListFacetsAllDocument, options);
      }
export function useListFacetsAllLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ListFacetsAllQuery, ListFacetsAllQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ListFacetsAllQuery, ListFacetsAllQueryVariables>(ListFacetsAllDocument, options);
        }
export function useListFacetsAllSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ListFacetsAllQuery, ListFacetsAllQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ListFacetsAllQuery, ListFacetsAllQueryVariables>(ListFacetsAllDocument, options);
        }
export type ListFacetsAllQueryHookResult = ReturnType<typeof useListFacetsAllQuery>;
export type ListFacetsAllLazyQueryHookResult = ReturnType<typeof useListFacetsAllLazyQuery>;
export type ListFacetsAllSuspenseQueryHookResult = ReturnType<typeof useListFacetsAllSuspenseQuery>;
export type ListFacetsAllQueryResult = Apollo.QueryResult<ListFacetsAllQuery, ListFacetsAllQueryVariables>;
export const CreateFacetDocument = gql`
    mutation CreateFacet($input: CreateFacetInput!) {
  createFacet(input: $input) {
    id
    name
    code
    isPrivate
    values
  }
}
    `;
export type CreateFacetMutationFn = Apollo.MutationFunction<CreateFacetMutation, CreateFacetMutationVariables>;

/**
 * __useCreateFacetMutation__
 *
 * To run a mutation, you first call `useCreateFacetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateFacetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createFacetMutation, { data, loading, error }] = useCreateFacetMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateFacetMutation(baseOptions?: Apollo.MutationHookOptions<CreateFacetMutation, CreateFacetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateFacetMutation, CreateFacetMutationVariables>(CreateFacetDocument, options);
      }
export type CreateFacetMutationHookResult = ReturnType<typeof useCreateFacetMutation>;
export type CreateFacetMutationResult = Apollo.MutationResult<CreateFacetMutation>;
export type CreateFacetMutationOptions = Apollo.BaseMutationOptions<CreateFacetMutation, CreateFacetMutationVariables>;
export const UpdateFacetDocument = gql`
    mutation UpdateFacet($input: UpdateFacetInput!) {
  updateFacet(input: $input) {
    id
    name
    code
    isPrivate
    values
  }
}
    `;
export type UpdateFacetMutationFn = Apollo.MutationFunction<UpdateFacetMutation, UpdateFacetMutationVariables>;

/**
 * __useUpdateFacetMutation__
 *
 * To run a mutation, you first call `useUpdateFacetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFacetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFacetMutation, { data, loading, error }] = useUpdateFacetMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateFacetMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFacetMutation, UpdateFacetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFacetMutation, UpdateFacetMutationVariables>(UpdateFacetDocument, options);
      }
export type UpdateFacetMutationHookResult = ReturnType<typeof useUpdateFacetMutation>;
export type UpdateFacetMutationResult = Apollo.MutationResult<UpdateFacetMutation>;
export type UpdateFacetMutationOptions = Apollo.BaseMutationOptions<UpdateFacetMutation, UpdateFacetMutationVariables>;
export const DeleteFacetDocument = gql`
    mutation DeleteFacet($id: String!) {
  deleteFacet(id: $id)
}
    `;
export type DeleteFacetMutationFn = Apollo.MutationFunction<DeleteFacetMutation, DeleteFacetMutationVariables>;

/**
 * __useDeleteFacetMutation__
 *
 * To run a mutation, you first call `useDeleteFacetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteFacetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteFacetMutation, { data, loading, error }] = useDeleteFacetMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteFacetMutation(baseOptions?: Apollo.MutationHookOptions<DeleteFacetMutation, DeleteFacetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteFacetMutation, DeleteFacetMutationVariables>(DeleteFacetDocument, options);
      }
export type DeleteFacetMutationHookResult = ReturnType<typeof useDeleteFacetMutation>;
export type DeleteFacetMutationResult = Apollo.MutationResult<DeleteFacetMutation>;
export type DeleteFacetMutationOptions = Apollo.BaseMutationOptions<DeleteFacetMutation, DeleteFacetMutationVariables>;
export const VariantFacetsDocument = gql`
    query VariantFacets($productVariantId: String!) {
  variantFacets(productVariantId: $productVariantId) {
    facet {
      id
      name
      code
      values
      isPrivate
    }
    value
  }
}
    `;

/**
 * __useVariantFacetsQuery__
 *
 * To run a query within a React component, call `useVariantFacetsQuery` and pass it any options that fit your needs.
 * When your component renders, `useVariantFacetsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVariantFacetsQuery({
 *   variables: {
 *      productVariantId: // value for 'productVariantId'
 *   },
 * });
 */
export function useVariantFacetsQuery(baseOptions: Apollo.QueryHookOptions<VariantFacetsQuery, VariantFacetsQueryVariables> & ({ variables: VariantFacetsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VariantFacetsQuery, VariantFacetsQueryVariables>(VariantFacetsDocument, options);
      }
export function useVariantFacetsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VariantFacetsQuery, VariantFacetsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VariantFacetsQuery, VariantFacetsQueryVariables>(VariantFacetsDocument, options);
        }
export function useVariantFacetsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<VariantFacetsQuery, VariantFacetsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<VariantFacetsQuery, VariantFacetsQueryVariables>(VariantFacetsDocument, options);
        }
export type VariantFacetsQueryHookResult = ReturnType<typeof useVariantFacetsQuery>;
export type VariantFacetsLazyQueryHookResult = ReturnType<typeof useVariantFacetsLazyQuery>;
export type VariantFacetsSuspenseQueryHookResult = ReturnType<typeof useVariantFacetsSuspenseQuery>;
export type VariantFacetsQueryResult = Apollo.QueryResult<VariantFacetsQuery, VariantFacetsQueryVariables>;
export const AssignFacetToVariantDocument = gql`
    mutation AssignFacetToVariant($productVariantId: String!, $facetId: String!, $value: String!) {
  assignFacetToVariant(
    productVariantId: $productVariantId
    facetId: $facetId
    value: $value
  )
}
    `;
export type AssignFacetToVariantMutationFn = Apollo.MutationFunction<AssignFacetToVariantMutation, AssignFacetToVariantMutationVariables>;

/**
 * __useAssignFacetToVariantMutation__
 *
 * To run a mutation, you first call `useAssignFacetToVariantMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAssignFacetToVariantMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [assignFacetToVariantMutation, { data, loading, error }] = useAssignFacetToVariantMutation({
 *   variables: {
 *      productVariantId: // value for 'productVariantId'
 *      facetId: // value for 'facetId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useAssignFacetToVariantMutation(baseOptions?: Apollo.MutationHookOptions<AssignFacetToVariantMutation, AssignFacetToVariantMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AssignFacetToVariantMutation, AssignFacetToVariantMutationVariables>(AssignFacetToVariantDocument, options);
      }
export type AssignFacetToVariantMutationHookResult = ReturnType<typeof useAssignFacetToVariantMutation>;
export type AssignFacetToVariantMutationResult = Apollo.MutationResult<AssignFacetToVariantMutation>;
export type AssignFacetToVariantMutationOptions = Apollo.BaseMutationOptions<AssignFacetToVariantMutation, AssignFacetToVariantMutationVariables>;
export const RemoveFacetFromVariantDocument = gql`
    mutation RemoveFacetFromVariant($productVariantId: String!, $facetId: String!, $value: String!) {
  removeFacetFromVariant(
    productVariantId: $productVariantId
    facetId: $facetId
    value: $value
  )
}
    `;
export type RemoveFacetFromVariantMutationFn = Apollo.MutationFunction<RemoveFacetFromVariantMutation, RemoveFacetFromVariantMutationVariables>;

/**
 * __useRemoveFacetFromVariantMutation__
 *
 * To run a mutation, you first call `useRemoveFacetFromVariantMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveFacetFromVariantMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeFacetFromVariantMutation, { data, loading, error }] = useRemoveFacetFromVariantMutation({
 *   variables: {
 *      productVariantId: // value for 'productVariantId'
 *      facetId: // value for 'facetId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useRemoveFacetFromVariantMutation(baseOptions?: Apollo.MutationHookOptions<RemoveFacetFromVariantMutation, RemoveFacetFromVariantMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveFacetFromVariantMutation, RemoveFacetFromVariantMutationVariables>(RemoveFacetFromVariantDocument, options);
      }
export type RemoveFacetFromVariantMutationHookResult = ReturnType<typeof useRemoveFacetFromVariantMutation>;
export type RemoveFacetFromVariantMutationResult = Apollo.MutationResult<RemoveFacetFromVariantMutation>;
export type RemoveFacetFromVariantMutationOptions = Apollo.BaseMutationOptions<RemoveFacetFromVariantMutation, RemoveFacetFromVariantMutationVariables>;
export const BulkAssignFacetToVariantsDocument = gql`
    mutation BulkAssignFacetToVariants($variantIds: [String!]!, $facetId: String!, $value: String!) {
  bulkAssignFacetToVariants(
    variantIds: $variantIds
    facetId: $facetId
    value: $value
  )
}
    `;
export type BulkAssignFacetToVariantsMutationFn = Apollo.MutationFunction<BulkAssignFacetToVariantsMutation, BulkAssignFacetToVariantsMutationVariables>;

/**
 * __useBulkAssignFacetToVariantsMutation__
 *
 * To run a mutation, you first call `useBulkAssignFacetToVariantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBulkAssignFacetToVariantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [bulkAssignFacetToVariantsMutation, { data, loading, error }] = useBulkAssignFacetToVariantsMutation({
 *   variables: {
 *      variantIds: // value for 'variantIds'
 *      facetId: // value for 'facetId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useBulkAssignFacetToVariantsMutation(baseOptions?: Apollo.MutationHookOptions<BulkAssignFacetToVariantsMutation, BulkAssignFacetToVariantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BulkAssignFacetToVariantsMutation, BulkAssignFacetToVariantsMutationVariables>(BulkAssignFacetToVariantsDocument, options);
      }
export type BulkAssignFacetToVariantsMutationHookResult = ReturnType<typeof useBulkAssignFacetToVariantsMutation>;
export type BulkAssignFacetToVariantsMutationResult = Apollo.MutationResult<BulkAssignFacetToVariantsMutation>;
export type BulkAssignFacetToVariantsMutationOptions = Apollo.BaseMutationOptions<BulkAssignFacetToVariantsMutation, BulkAssignFacetToVariantsMutationVariables>;
export const BulkRemoveFacetFromVariantsDocument = gql`
    mutation BulkRemoveFacetFromVariants($variantIds: [String!]!, $facetId: String!, $value: String!) {
  bulkRemoveFacetFromVariants(
    variantIds: $variantIds
    facetId: $facetId
    value: $value
  )
}
    `;
export type BulkRemoveFacetFromVariantsMutationFn = Apollo.MutationFunction<BulkRemoveFacetFromVariantsMutation, BulkRemoveFacetFromVariantsMutationVariables>;

/**
 * __useBulkRemoveFacetFromVariantsMutation__
 *
 * To run a mutation, you first call `useBulkRemoveFacetFromVariantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBulkRemoveFacetFromVariantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [bulkRemoveFacetFromVariantsMutation, { data, loading, error }] = useBulkRemoveFacetFromVariantsMutation({
 *   variables: {
 *      variantIds: // value for 'variantIds'
 *      facetId: // value for 'facetId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useBulkRemoveFacetFromVariantsMutation(baseOptions?: Apollo.MutationHookOptions<BulkRemoveFacetFromVariantsMutation, BulkRemoveFacetFromVariantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BulkRemoveFacetFromVariantsMutation, BulkRemoveFacetFromVariantsMutationVariables>(BulkRemoveFacetFromVariantsDocument, options);
      }
export type BulkRemoveFacetFromVariantsMutationHookResult = ReturnType<typeof useBulkRemoveFacetFromVariantsMutation>;
export type BulkRemoveFacetFromVariantsMutationResult = Apollo.MutationResult<BulkRemoveFacetFromVariantsMutation>;
export type BulkRemoveFacetFromVariantsMutationOptions = Apollo.BaseMutationOptions<BulkRemoveFacetFromVariantsMutation, BulkRemoveFacetFromVariantsMutationVariables>;
export const BulkAssignFacetToProductsDocument = gql`
    mutation BulkAssignFacetToProducts($productIds: [String!]!, $facetId: String!, $value: String!) {
  bulkAssignFacetToProducts(
    productIds: $productIds
    facetId: $facetId
    value: $value
  )
}
    `;
export type BulkAssignFacetToProductsMutationFn = Apollo.MutationFunction<BulkAssignFacetToProductsMutation, BulkAssignFacetToProductsMutationVariables>;

/**
 * __useBulkAssignFacetToProductsMutation__
 *
 * To run a mutation, you first call `useBulkAssignFacetToProductsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBulkAssignFacetToProductsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [bulkAssignFacetToProductsMutation, { data, loading, error }] = useBulkAssignFacetToProductsMutation({
 *   variables: {
 *      productIds: // value for 'productIds'
 *      facetId: // value for 'facetId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useBulkAssignFacetToProductsMutation(baseOptions?: Apollo.MutationHookOptions<BulkAssignFacetToProductsMutation, BulkAssignFacetToProductsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BulkAssignFacetToProductsMutation, BulkAssignFacetToProductsMutationVariables>(BulkAssignFacetToProductsDocument, options);
      }
export type BulkAssignFacetToProductsMutationHookResult = ReturnType<typeof useBulkAssignFacetToProductsMutation>;
export type BulkAssignFacetToProductsMutationResult = Apollo.MutationResult<BulkAssignFacetToProductsMutation>;
export type BulkAssignFacetToProductsMutationOptions = Apollo.BaseMutationOptions<BulkAssignFacetToProductsMutation, BulkAssignFacetToProductsMutationVariables>;
export const BulkRemoveFacetFromProductsDocument = gql`
    mutation BulkRemoveFacetFromProducts($productIds: [String!]!, $facetId: String!, $value: String!) {
  bulkRemoveFacetFromProducts(
    productIds: $productIds
    facetId: $facetId
    value: $value
  )
}
    `;
export type BulkRemoveFacetFromProductsMutationFn = Apollo.MutationFunction<BulkRemoveFacetFromProductsMutation, BulkRemoveFacetFromProductsMutationVariables>;

/**
 * __useBulkRemoveFacetFromProductsMutation__
 *
 * To run a mutation, you first call `useBulkRemoveFacetFromProductsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBulkRemoveFacetFromProductsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [bulkRemoveFacetFromProductsMutation, { data, loading, error }] = useBulkRemoveFacetFromProductsMutation({
 *   variables: {
 *      productIds: // value for 'productIds'
 *      facetId: // value for 'facetId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useBulkRemoveFacetFromProductsMutation(baseOptions?: Apollo.MutationHookOptions<BulkRemoveFacetFromProductsMutation, BulkRemoveFacetFromProductsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BulkRemoveFacetFromProductsMutation, BulkRemoveFacetFromProductsMutationVariables>(BulkRemoveFacetFromProductsDocument, options);
      }
export type BulkRemoveFacetFromProductsMutationHookResult = ReturnType<typeof useBulkRemoveFacetFromProductsMutation>;
export type BulkRemoveFacetFromProductsMutationResult = Apollo.MutationResult<BulkRemoveFacetFromProductsMutation>;
export type BulkRemoveFacetFromProductsMutationOptions = Apollo.BaseMutationOptions<BulkRemoveFacetFromProductsMutation, BulkRemoveFacetFromProductsMutationVariables>;
export const VariantsDocument = gql`
    query Variants($take: Int, $skip: Int, $where: ProductVariantWhereInput) {
  listProductVariants(take: $take, skip: $skip, where: $where) {
    id
    name
    barcode
    price
    resellerPrice
    createdAt
    product {
      id
      name
    }
    stockItems {
      quantity
      reserved
    }
  }
}
    `;

/**
 * __useVariantsQuery__
 *
 * To run a query within a React component, call `useVariantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useVariantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVariantsQuery({
 *   variables: {
 *      take: // value for 'take'
 *      skip: // value for 'skip'
 *      where: // value for 'where'
 *   },
 * });
 */
export function useVariantsQuery(baseOptions?: Apollo.QueryHookOptions<VariantsQuery, VariantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VariantsQuery, VariantsQueryVariables>(VariantsDocument, options);
      }
export function useVariantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VariantsQuery, VariantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VariantsQuery, VariantsQueryVariables>(VariantsDocument, options);
        }
export function useVariantsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<VariantsQuery, VariantsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<VariantsQuery, VariantsQueryVariables>(VariantsDocument, options);
        }
export type VariantsQueryHookResult = ReturnType<typeof useVariantsQuery>;
export type VariantsLazyQueryHookResult = ReturnType<typeof useVariantsLazyQuery>;
export type VariantsSuspenseQueryHookResult = ReturnType<typeof useVariantsSuspenseQuery>;
export type VariantsQueryResult = Apollo.QueryResult<VariantsQuery, VariantsQueryVariables>;
export const ProductVariantsCountDocument = gql`
    query ProductVariantsCount($where: ProductVariantWhereInput) {
  productVariantsCount(where: $where)
}
    `;

/**
 * __useProductVariantsCountQuery__
 *
 * To run a query within a React component, call `useProductVariantsCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useProductVariantsCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProductVariantsCountQuery({
 *   variables: {
 *      where: // value for 'where'
 *   },
 * });
 */
export function useProductVariantsCountQuery(baseOptions?: Apollo.QueryHookOptions<ProductVariantsCountQuery, ProductVariantsCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProductVariantsCountQuery, ProductVariantsCountQueryVariables>(ProductVariantsCountDocument, options);
      }
export function useProductVariantsCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProductVariantsCountQuery, ProductVariantsCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProductVariantsCountQuery, ProductVariantsCountQueryVariables>(ProductVariantsCountDocument, options);
        }
export function useProductVariantsCountSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<ProductVariantsCountQuery, ProductVariantsCountQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProductVariantsCountQuery, ProductVariantsCountQueryVariables>(ProductVariantsCountDocument, options);
        }
export type ProductVariantsCountQueryHookResult = ReturnType<typeof useProductVariantsCountQuery>;
export type ProductVariantsCountLazyQueryHookResult = ReturnType<typeof useProductVariantsCountLazyQuery>;
export type ProductVariantsCountSuspenseQueryHookResult = ReturnType<typeof useProductVariantsCountSuspenseQuery>;
export type ProductVariantsCountQueryResult = Apollo.QueryResult<ProductVariantsCountQuery, ProductVariantsCountQueryVariables>;
export const VariantDocument = gql`
    query Variant($id: String!) {
  findUniqueProductVariant(where: {id: $id}) {
    id
    name
    barcode
    price
    resellerPrice
    createdAt
    product {
      id
      name
    }
  }
}
    `;

/**
 * __useVariantQuery__
 *
 * To run a query within a React component, call `useVariantQuery` and pass it any options that fit your needs.
 * When your component renders, `useVariantQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVariantQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useVariantQuery(baseOptions: Apollo.QueryHookOptions<VariantQuery, VariantQueryVariables> & ({ variables: VariantQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VariantQuery, VariantQueryVariables>(VariantDocument, options);
      }
export function useVariantLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VariantQuery, VariantQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VariantQuery, VariantQueryVariables>(VariantDocument, options);
        }
export function useVariantSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<VariantQuery, VariantQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<VariantQuery, VariantQueryVariables>(VariantDocument, options);
        }
export type VariantQueryHookResult = ReturnType<typeof useVariantQuery>;
export type VariantLazyQueryHookResult = ReturnType<typeof useVariantLazyQuery>;
export type VariantSuspenseQueryHookResult = ReturnType<typeof useVariantSuspenseQuery>;
export type VariantQueryResult = Apollo.QueryResult<VariantQuery, VariantQueryVariables>;
export const VerifyEmailDocument = gql`
    mutation VerifyEmail($token: String!) {
  verifyEmail(token: $token)
}
    `;
export type VerifyEmailMutationFn = Apollo.MutationFunction<VerifyEmailMutation, VerifyEmailMutationVariables>;

/**
 * __useVerifyEmailMutation__
 *
 * To run a mutation, you first call `useVerifyEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVerifyEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [verifyEmailMutation, { data, loading, error }] = useVerifyEmailMutation({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useVerifyEmailMutation(baseOptions?: Apollo.MutationHookOptions<VerifyEmailMutation, VerifyEmailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<VerifyEmailMutation, VerifyEmailMutationVariables>(VerifyEmailDocument, options);
      }
export type VerifyEmailMutationHookResult = ReturnType<typeof useVerifyEmailMutation>;
export type VerifyEmailMutationResult = Apollo.MutationResult<VerifyEmailMutation>;
export type VerifyEmailMutationOptions = Apollo.BaseMutationOptions<VerifyEmailMutation, VerifyEmailMutationVariables>;
export const AdminProcessInvoiceUrlDocument = gql`
    mutation AdminProcessInvoiceUrl($input: ProcessInvoiceUrlInput!) {
  adminProcessInvoiceUrl(input: $input) {
    status
    message
    supplierId
    supplierName
    invoiceNumber
    purchaseOrderId
    totalAmount
    lines {
      description
      qty
      unitPrice
      discountPct
      discountedUnitPrice
      lineTotal
      variantId
    }
  }
}
    `;
export type AdminProcessInvoiceUrlMutationFn = Apollo.MutationFunction<AdminProcessInvoiceUrlMutation, AdminProcessInvoiceUrlMutationVariables>;

/**
 * __useAdminProcessInvoiceUrlMutation__
 *
 * To run a mutation, you first call `useAdminProcessInvoiceUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAdminProcessInvoiceUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [adminProcessInvoiceUrlMutation, { data, loading, error }] = useAdminProcessInvoiceUrlMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAdminProcessInvoiceUrlMutation(baseOptions?: Apollo.MutationHookOptions<AdminProcessInvoiceUrlMutation, AdminProcessInvoiceUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AdminProcessInvoiceUrlMutation, AdminProcessInvoiceUrlMutationVariables>(AdminProcessInvoiceUrlDocument, options);
      }
export type AdminProcessInvoiceUrlMutationHookResult = ReturnType<typeof useAdminProcessInvoiceUrlMutation>;
export type AdminProcessInvoiceUrlMutationResult = Apollo.MutationResult<AdminProcessInvoiceUrlMutation>;
export type AdminProcessInvoiceUrlMutationOptions = Apollo.BaseMutationOptions<AdminProcessInvoiceUrlMutation, AdminProcessInvoiceUrlMutationVariables>;
export const MeForPermsDocument = gql`
    query MeForPerms {
  me {
    role {
      permissions {
        name
      }
    }
  }
}
    `;

/**
 * __useMeForPermsQuery__
 *
 * To run a query within a React component, call `useMeForPermsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeForPermsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeForPermsQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeForPermsQuery(baseOptions?: Apollo.QueryHookOptions<MeForPermsQuery, MeForPermsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MeForPermsQuery, MeForPermsQueryVariables>(MeForPermsDocument, options);
      }
export function useMeForPermsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeForPermsQuery, MeForPermsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MeForPermsQuery, MeForPermsQueryVariables>(MeForPermsDocument, options);
        }
export function useMeForPermsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<MeForPermsQuery, MeForPermsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MeForPermsQuery, MeForPermsQueryVariables>(MeForPermsDocument, options);
        }
export type MeForPermsQueryHookResult = ReturnType<typeof useMeForPermsQuery>;
export type MeForPermsLazyQueryHookResult = ReturnType<typeof useMeForPermsLazyQuery>;
export type MeForPermsSuspenseQueryHookResult = ReturnType<typeof useMeForPermsSuspenseQuery>;
export type MeForPermsQueryResult = Apollo.QueryResult<MeForPermsQuery, MeForPermsQueryVariables>;
export const SearchUsersDocument = gql`
    query SearchUsers($where: UserWhereInput, $take: Int) {
  listUsers(where: $where, take: $take) {
    id
    email
  }
}
    `;

/**
 * __useSearchUsersQuery__
 *
 * To run a query within a React component, call `useSearchUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchUsersQuery({
 *   variables: {
 *      where: // value for 'where'
 *      take: // value for 'take'
 *   },
 * });
 */
export function useSearchUsersQuery(baseOptions?: Apollo.QueryHookOptions<SearchUsersQuery, SearchUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchUsersQuery, SearchUsersQueryVariables>(SearchUsersDocument, options);
      }
export function useSearchUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchUsersQuery, SearchUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchUsersQuery, SearchUsersQueryVariables>(SearchUsersDocument, options);
        }
export function useSearchUsersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SearchUsersQuery, SearchUsersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchUsersQuery, SearchUsersQueryVariables>(SearchUsersDocument, options);
        }
export type SearchUsersQueryHookResult = ReturnType<typeof useSearchUsersQuery>;
export type SearchUsersLazyQueryHookResult = ReturnType<typeof useSearchUsersLazyQuery>;
export type SearchUsersSuspenseQueryHookResult = ReturnType<typeof useSearchUsersSuspenseQuery>;
export type SearchUsersQueryResult = Apollo.QueryResult<SearchUsersQuery, SearchUsersQueryVariables>;
export const SearchStoresDocument = gql`
    query SearchStores($where: StoreWhereInput, $take: Int) {
  listStores(where: $where, take: $take) {
    id
    name
    location
  }
}
    `;

/**
 * __useSearchStoresQuery__
 *
 * To run a query within a React component, call `useSearchStoresQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchStoresQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchStoresQuery({
 *   variables: {
 *      where: // value for 'where'
 *      take: // value for 'take'
 *   },
 * });
 */
export function useSearchStoresQuery(baseOptions?: Apollo.QueryHookOptions<SearchStoresQuery, SearchStoresQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchStoresQuery, SearchStoresQueryVariables>(SearchStoresDocument, options);
      }
export function useSearchStoresLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchStoresQuery, SearchStoresQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchStoresQuery, SearchStoresQueryVariables>(SearchStoresDocument, options);
        }
export function useSearchStoresSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SearchStoresQuery, SearchStoresQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchStoresQuery, SearchStoresQueryVariables>(SearchStoresDocument, options);
        }
export type SearchStoresQueryHookResult = ReturnType<typeof useSearchStoresQuery>;
export type SearchStoresLazyQueryHookResult = ReturnType<typeof useSearchStoresLazyQuery>;
export type SearchStoresSuspenseQueryHookResult = ReturnType<typeof useSearchStoresSuspenseQuery>;
export type SearchStoresQueryResult = Apollo.QueryResult<SearchStoresQuery, SearchStoresQueryVariables>;
export const SearchVariantsDocument = gql`
    query SearchVariants($where: ProductVariantWhereInput, $take: Int) {
  listProductVariants(where: $where, take: $take) {
    id
    name
    barcode
  }
}
    `;

/**
 * __useSearchVariantsQuery__
 *
 * To run a query within a React component, call `useSearchVariantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchVariantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchVariantsQuery({
 *   variables: {
 *      where: // value for 'where'
 *      take: // value for 'take'
 *   },
 * });
 */
export function useSearchVariantsQuery(baseOptions?: Apollo.QueryHookOptions<SearchVariantsQuery, SearchVariantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchVariantsQuery, SearchVariantsQueryVariables>(SearchVariantsDocument, options);
      }
export function useSearchVariantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchVariantsQuery, SearchVariantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchVariantsQuery, SearchVariantsQueryVariables>(SearchVariantsDocument, options);
        }
export function useSearchVariantsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SearchVariantsQuery, SearchVariantsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchVariantsQuery, SearchVariantsQueryVariables>(SearchVariantsDocument, options);
        }
export type SearchVariantsQueryHookResult = ReturnType<typeof useSearchVariantsQuery>;
export type SearchVariantsLazyQueryHookResult = ReturnType<typeof useSearchVariantsLazyQuery>;
export type SearchVariantsSuspenseQueryHookResult = ReturnType<typeof useSearchVariantsSuspenseQuery>;
export type SearchVariantsQueryResult = Apollo.QueryResult<SearchVariantsQuery, SearchVariantsQueryVariables>;
export const SearchSuppliersDocument = gql`
    query SearchSuppliers($where: SupplierWhereInput, $take: Int) {
  listSuppliers(where: $where, take: $take) {
    id
    name
  }
}
    `;

/**
 * __useSearchSuppliersQuery__
 *
 * To run a query within a React component, call `useSearchSuppliersQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchSuppliersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchSuppliersQuery({
 *   variables: {
 *      where: // value for 'where'
 *      take: // value for 'take'
 *   },
 * });
 */
export function useSearchSuppliersQuery(baseOptions?: Apollo.QueryHookOptions<SearchSuppliersQuery, SearchSuppliersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchSuppliersQuery, SearchSuppliersQueryVariables>(SearchSuppliersDocument, options);
      }
export function useSearchSuppliersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchSuppliersQuery, SearchSuppliersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchSuppliersQuery, SearchSuppliersQueryVariables>(SearchSuppliersDocument, options);
        }
export function useSearchSuppliersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<SearchSuppliersQuery, SearchSuppliersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchSuppliersQuery, SearchSuppliersQueryVariables>(SearchSuppliersDocument, options);
        }
export type SearchSuppliersQueryHookResult = ReturnType<typeof useSearchSuppliersQuery>;
export type SearchSuppliersLazyQueryHookResult = ReturnType<typeof useSearchSuppliersLazyQuery>;
export type SearchSuppliersSuspenseQueryHookResult = ReturnType<typeof useSearchSuppliersSuspenseQuery>;
export type SearchSuppliersQueryResult = Apollo.QueryResult<SearchSuppliersQuery, SearchSuppliersQueryVariables>;